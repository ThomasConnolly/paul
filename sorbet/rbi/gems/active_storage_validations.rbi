# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/active_storage_validations/all/active_storage_validations.rbi
#
# active_storage_validations-1.1.4

module ActiveStorageValidations
end
class ActiveStorageValidations::Railtie < Rails::Railtie
end
class ActiveStorageValidations::Engine < Rails::Engine
end
module ActiveStorageValidations::OptionProcUnfolding
  def unfold_procs(record, object, only_keys); end
end
module ActiveStorageValidations::Errorable
  def add_error(record, attribute, error_type, **errors_options); end
  def get_filename(file); end
  def initialize_error_options(options, file = nil); end
  extend ActiveSupport::Concern
end
module ActiveStorageValidations::Symbolizable
  extend ActiveSupport::Concern
end
module ActiveStorageValidations::Symbolizable::ClassMethods
  def to_sym; end
end
class ActiveStorageValidations::AttachedValidator < ActiveModel::EachValidator
  def check_validity!; end
  def validate_each(record, attribute, _value); end
  extend ActiveStorageValidations::Symbolizable::ClassMethods
  include ActiveStorageValidations::Errorable
  include ActiveStorageValidations::Symbolizable
end
class ActiveStorageValidations::ContentTypeValidator < ActiveModel::EachValidator
  def authorized_types(record); end
  def check_validity!; end
  def content_type(file); end
  def ensure_content_types_validity; end
  def ensure_exactly_one_validator_option; end
  def invalid_content_type?(content_type); end
  def invalid_content_type_message(content_type); end
  def is_valid?(file, types); end
  def types_to_human_format(types); end
  def validate_each(record, attribute, _value); end
  extend ActiveStorageValidations::Symbolizable::ClassMethods
  include ActiveStorageValidations::Errorable
  include ActiveStorageValidations::OptionProcUnfolding
  include ActiveStorageValidations::Symbolizable
end
class ActiveStorageValidations::SizeValidator < ActiveModel::EachValidator
  def check_validity!; end
  def is_valid?(file_size, flat_options); end
  def max_size(flat_options); end
  def min_size(flat_options); end
  def number_to_human_size(*, **, &); end
  def validate_each(record, attribute, _value); end
  extend ActiveStorageValidations::Symbolizable::ClassMethods
  include ActiveStorageValidations::Errorable
  include ActiveStorageValidations::OptionProcUnfolding
  include ActiveStorageValidations::Symbolizable
end
class ActiveStorageValidations::LimitValidator < ActiveModel::EachValidator
  def check_validity!; end
  def ensure_arguments_validity; end
  def ensure_at_least_one_validator_option; end
  def files_count_valid?(count, flat_options); end
  def min_higher_than_max?; end
  def min_max_are_proc?; end
  def min_or_max_defined_and_not_integer?; end
  def min_or_max_is_proc_and_other_not_present?; end
  def validate_each(record, attribute, _); end
  extend ActiveStorageValidations::Symbolizable::ClassMethods
  include ActiveStorageValidations::Errorable
  include ActiveStorageValidations::OptionProcUnfolding
  include ActiveStorageValidations::Symbolizable
end
class ActiveStorageValidations::Metadata
  def exception_class; end
  def file; end
  def image_processor; end
  def initialize(file); end
  def logger; end
  def metadata; end
  def new_image_from_path(path); end
  def read_file_path; end
  def read_image; end
  def require_image_processor; end
  def rotated_image?(image); end
  def valid?; end
  def valid_image?(image); end
  def vips_image_processor?; end
end
class ActiveStorageValidations::Metadata::InvalidImageError < StandardError
end
class ActiveStorageValidations::DimensionValidator < ActiveModel::EachValidator
  def check_validity!; end
  def is_valid?(record, attribute, file, metadata); end
  def process_options(record); end
  def validate_each(record, attribute, _value); end
  extend ActiveStorageValidations::Symbolizable::ClassMethods
  include ActiveStorageValidations::Errorable
  include ActiveStorageValidations::OptionProcUnfolding
  include ActiveStorageValidations::Symbolizable
end
class ActiveStorageValidations::AspectRatioValidator < ActiveModel::EachValidator
  def check_validity!; end
  def ensure_aspect_ratio_validity; end
  def ensure_at_least_one_validator_option; end
  def is_valid?(record, attribute, file, metadata); end
  def validate_each(record, attribute, _value); end
  extend ActiveStorageValidations::Symbolizable::ClassMethods
  include ActiveStorageValidations::Errorable
  include ActiveStorageValidations::OptionProcUnfolding
  include ActiveStorageValidations::Symbolizable
end
class ActiveStorageValidations::ProcessableImageValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, _value); end
  extend ActiveStorageValidations::Symbolizable::ClassMethods
  include ActiveStorageValidations::Errorable
  include ActiveStorageValidations::OptionProcUnfolding
  include ActiveStorageValidations::Symbolizable
end
