# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def deconstruct(); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Sexp
  def s(type, *children); end
end

class AbstractController::ActionNotFound
  def action(); end

  def controller(); end

  def initialize(message=T.unsafe(nil), controller=T.unsafe(nil), action=T.unsafe(nil)); end
end

class AbstractController::Base
  def action_methods(); end

  def action_name(); end

  def action_name=(action_name); end

  def available_action?(action_name); end

  def controller_path(); end

  def formats(); end

  def formats=(formats); end

  def performed?(); end

  def process(action, *args, **arg); end

  def response_body(); end

  def response_body=(response_body); end

  def send_action(*arg); end
end

class AbstractController::Base
  def self.abstract(); end

  def self.abstract!(); end

  def self.abstract?(); end

  def self.action_methods(); end

  def self.clear_action_methods!(); end

  def self.controller_path(); end

  def self.eager_load!(); end

  def self.inherited(klass); end

  def self.internal_methods(); end

  def self.method_added(name); end

  def self.supports_path?(); end
end

module AbstractController::Caching
  def view_cache_dependencies(); end
end

module AbstractController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module AbstractController::Caching::ConfigMethods
  def cache_store(); end

  def cache_store=(store); end
end

module AbstractController::Caching::Fragments
  def combined_fragment_cache_key(key); end

  def expire_fragment(key, options=T.unsafe(nil)); end

  def fragment_exist?(key, options=T.unsafe(nil)); end

  def instrument_fragment_cache(name, key, &block); end

  def read_fragment(key, options=T.unsafe(nil)); end

  def write_fragment(key, content, options=T.unsafe(nil)); end
end

module AbstractController::Caching::Fragments::ClassMethods
  def fragment_cache_key(value=T.unsafe(nil), &key); end
end

class AbstractController::Callbacks::ActionFilter
  def after(controller); end

  def around(controller); end

  def before(controller); end

  def initialize(filters, conditional_key, actions); end

  def match?(controller); end
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block=T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  def _normalize_callback_options(options); end
end

module AbstractController::Collector
  def atom(*args, **arg, &block); end

  def bmp(*args, **arg, &block); end

  def css(*args, **arg, &block); end

  def csv(*args, **arg, &block); end

  def gif(*args, **arg, &block); end

  def gzip(*args, **arg, &block); end

  def html(*args, **arg, &block); end

  def ics(*args, **arg, &block); end

  def jpeg(*args, **arg, &block); end

  def js(*args, **arg, &block); end

  def json(*args, **arg, &block); end

  def m4a(*args, **arg, &block); end

  def mp3(*args, **arg, &block); end

  def mp4(*args, **arg, &block); end

  def mpeg(*args, **arg, &block); end

  def multipart_form(*args, **arg, &block); end

  def ogg(*args, **arg, &block); end

  def otf(*args, **arg, &block); end

  def pdf(*args, **arg, &block); end

  def png(*args, **arg, &block); end

  def rss(*args, **arg, &block); end

  def svg(*args, **arg, &block); end

  def text(*args, **arg, &block); end

  def tiff(*args, **arg, &block); end

  def ttf(*args, **arg, &block); end

  def turbo_stream(*args, **arg, &block); end

  def url_encoded_form(*args, **arg, &block); end

  def vcf(*args, **arg, &block); end

  def vtt(*args, **arg, &block); end

  def webm(*args, **arg, &block); end

  def webp(*args, **arg, &block); end

  def woff(*args, **arg, &block); end

  def woff2(*args, **arg, &block); end

  def xml(*args, **arg, &block); end

  def yaml(*args, **arg, &block); end

  def zip(*args, **arg, &block); end
end

module AbstractController::Collector
  def self.generate_method_for_mime(mime); end
end

class AbstractController::DoubleRenderError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module AbstractController::Helpers
  def _helpers(); end
end

module AbstractController::Helpers::ClassMethods
  def _helpers=(_helpers); end

  def _helpers_for_modification(); end

  def clear_helpers(); end

  def helper(*args, &block); end

  def helper_method(*methods); end

  def inherited(klass); end
end

class AbstractController::Helpers::DeprecatedMissingHelperError
  def initialize(error, path); end
end

module AbstractController::Helpers::Resolution
  def all_helpers_from_path(path); end

  def helper_modules_from_paths(paths); end

  def modules_for_helpers(modules_or_helper_prefixes); end
end

module AbstractController::Rendering
  def render(*args, &block); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*args, &block); end

  def rendered_format(); end

  def view_assigns(); end
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Translation
  def l(object, **options); end

  def localize(object, **options); end

  def t(key, **options); end

  def translate(key, **options); end
end

module AbstractController::UrlFor
  def _routes(); end
end

module AbstractController::UrlFor::ClassMethods
  def _routes(); end

  def action_methods(); end
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

class ActionCable::Channel::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _run_subscribe_callbacks(&block); end

  def _run_unsubscribe_callbacks(&block); end

  def _subscribe_callbacks(); end

  def _unsubscribe_callbacks(); end

  def broadcast_to(model, message, &block); end

  def broadcasting_for(model, &block); end

  def channel_name(&block); end

  def connection(); end

  def identifier(); end

  def initialize(connection, identifier, params=T.unsafe(nil)); end

  def logger(*arg, **arg1, &arg2); end

  def params(); end

  def perform_action(data); end

  def periodic_timers=(periodic_timers); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def subscribe_to_channel(); end

  def unsubscribe_from_channel(); end
end

class ActionCable::Channel::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._subscribe_callbacks(); end

  def self._subscribe_callbacks=(value); end

  def self._unsubscribe_callbacks(); end

  def self._unsubscribe_callbacks=(value); end

  def self.action_methods(); end

  def self.periodic_timers(); end

  def self.periodic_timers=(value); end

  def self.periodic_timers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
  def broadcast_to(model, message); end

  def broadcasting_for(model); end

  def serialize_broadcasting(object); end
end

module ActionCable::Channel::Callbacks::ClassMethods
  def after_subscribe(*methods, &block); end

  def after_unsubscribe(*methods, &block); end

  def before_subscribe(*methods, &block); end

  def before_unsubscribe(*methods, &block); end

  def on_subscribe(*methods, &block); end

  def on_unsubscribe(*methods, &block); end
end

module ActionCable::Channel::ChannelStub
  def confirmed?(); end

  def rejected?(); end

  def start_periodic_timers(); end

  def stop_all_streams(); end

  def stop_periodic_timers(); end

  def stream_from(broadcasting, *arg); end

  def streams(); end
end

class ActionCable::Channel::ConnectionStub
  def config(*arg, **arg1, &arg2); end

  def connection_identifier(); end

  def identifiers(); end

  def initialize(identifiers=T.unsafe(nil)); end

  def logger(); end

  def pubsub(*arg, **arg1, &arg2); end

  def server(); end

  def subscriptions(); end

  def transmissions(); end

  def transmit(cable_message); end
end

module ActionCable::Channel::Naming::ClassMethods
  def channel_name(); end
end

class ActionCable::Channel::NonInferrableChannelError
  def initialize(name); end
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  def periodically(callback_or_method_name=T.unsafe(nil), every:, &block); end
end

module ActionCable::Channel::Streams
  def pubsub(*arg, **arg1, &arg2); end

  def stop_all_streams(); end

  def stop_stream_for(model); end

  def stop_stream_from(broadcasting); end

  def stream_for(model, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_from(broadcasting, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_or_reject_for(model); end
end

class ActionCable::Channel::TestCase
  def _channel_class(); end

  def _channel_class=(_channel_class); end

  def _channel_class?(); end

  def connection(); end

  def subscription(); end
end

module ActionCable::Channel::TestCase::Behavior
  def assert_broadcast_on(stream_or_object, *args); end

  def assert_broadcasts(stream_or_object, *args); end

  def assert_has_stream(stream); end

  def assert_has_stream_for(object); end

  def assert_no_streams(); end

  def perform(action, data=T.unsafe(nil)); end

  def stub_connection(identifiers=T.unsafe(nil)); end

  def subscribe(params=T.unsafe(nil)); end

  def transmissions(); end

  def unsubscribe(); end
  CHANNEL_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
  def channel_class(); end

  def determine_default_channel(name); end

  def tests(channel); end
end

class ActionCable::Channel::TestCase
  def self._channel_class(); end

  def self._channel_class=(value); end

  def self._channel_class?(); end
end

module ActionCable::Connection::Assertions
  def assert_reject_connection(&block); end
end

module ActionCable::Connection::Authorization
  def reject_unauthorized_connection(); end
end

class ActionCable::Connection::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _command_callbacks(); end

  def _run_command_callbacks(&block); end

  def beat(); end

  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  def config(*arg, **arg1, &arg2); end

  def dispatch_websocket_message(websocket_message); end

  def env(); end

  def event_loop(*arg, **arg1, &arg2); end

  def handle_channel_command(payload); end

  def identifiers(); end

  def identifiers=(identifiers); end

  def identifiers?(); end

  def initialize(server, env, coder: T.unsafe(nil)); end

  def logger(); end

  def on_close(reason, code); end

  def on_error(message); end

  def on_message(message); end

  def on_open(); end

  def process(); end

  def protocol(); end

  def pubsub(*arg, **arg1, &arg2); end

  def receive(websocket_message); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def send_async(method, *arguments); end

  def server(); end

  def statistics(); end

  def subscriptions(); end

  def transmit(cable_message); end

  def worker_pool(); end
end

class ActionCable::Connection::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._command_callbacks(); end

  def self._command_callbacks=(value); end

  def self.identifiers(); end

  def self.identifiers=(value); end

  def self.identifiers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end
end

module ActionCable::Connection::Callbacks::ClassMethods
  def after_command(*methods, &block); end

  def around_command(*methods, &block); end

  def before_command(*methods, &block); end
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

module ActionCable::Connection::Identification
  def connection_identifier(); end
end

module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::NonInferrableConnectionError
  def initialize(name); end
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*arg, **arg1, &arg2); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message=T.unsafe(nil), &block); end

  def error(message=T.unsafe(nil), &block); end

  def fatal(message=T.unsafe(nil), &block); end

  def info(message=T.unsafe(nil), &block); end

  def initialize(logger, tags:); end

  def tag(logger, &block); end

  def tags(); end

  def unknown(message=T.unsafe(nil), &block); end

  def warn(message=T.unsafe(nil), &block); end
end

class ActionCable::Connection::TestCase
  def _connection_class(); end

  def _connection_class=(_connection_class); end

  def _connection_class?(); end

  def connection(); end
end

module ActionCable::Connection::TestCase::Behavior
  def connect(path=T.unsafe(nil), **request_params); end

  def cookies(); end

  def disconnect(); end
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
  def connection_class(); end

  def determine_default_connection(name); end

  def tests(connection); end
end

class ActionCable::Connection::TestCase
  def self._connection_class(); end

  def self._connection_class=(value); end

  def self._connection_class?(); end
end

module ActionCable::Connection::TestConnection
  def initialize(request); end

  def logger(); end

  def request(); end
end

class ActionCable::Connection::TestCookieJar
  def encrypted(); end

  def signed(); end
end

class ActionCable::Connection::TestRequest
  def cookie_jar=(cookie_jar); end

  def session=(session); end
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end
end

module ActionCable::Helpers::ActionCableHelper
  def action_cable_meta_tag(); end
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  def disconnect(reconnect: T.unsafe(nil)); end

  def identifiers(); end

  def identifiers=(identifiers); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection
  def self.identifiers(); end

  def self.identifiers=(value); end

  def self.identifiers?(); end
end

class ActionCable::Server::Base
  def call(env); end

  def config(); end

  def connection_identifiers(); end

  def disconnect(identifiers); end

  def event_loop(); end

  def initialize(config: T.unsafe(nil)); end

  def logger(*arg, **arg1, &arg2); end

  def mutex(); end

  def pubsub(); end

  def remote_connections(); end

  def restart(); end

  def worker_pool(); end
end

class ActionCable::Server::Base
  def self.config(); end

  def self.config=(val); end

  def self.logger(); end
end

module ActionCable::Server::Broadcasting
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

class ActionCable::Server::Broadcasting::Broadcaster
  def broadcast(message); end

  def broadcasting(); end

  def coder(); end

  def initialize(server, broadcasting, coder:); end

  def server(); end
end

class ActionCable::Server::Configuration
  def allow_same_origin_as_host(); end

  def allow_same_origin_as_host=(allow_same_origin_as_host); end

  def allowed_request_origins(); end

  def allowed_request_origins=(allowed_request_origins); end

  def cable(); end

  def cable=(cable); end

  def connection_class(); end

  def connection_class=(connection_class); end

  def disable_request_forgery_protection(); end

  def disable_request_forgery_protection=(disable_request_forgery_protection); end

  def filter_parameters(); end

  def filter_parameters=(filter_parameters); end

  def health_check_application(); end

  def health_check_application=(health_check_application); end

  def health_check_path(); end

  def health_check_path=(health_check_path); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def mount_path(); end

  def mount_path=(mount_path); end

  def precompile_assets(); end

  def precompile_assets=(precompile_assets); end

  def pubsub_adapter(); end

  def url(); end

  def url=(url); end

  def worker_pool_size(); end

  def worker_pool_size=(worker_pool_size); end
end

module ActionCable::Server::Connections
  def add_connection(connection); end

  def connections(); end

  def open_connections_statistics(); end

  def remove_connection(connection); end

  def setup_heartbeat_timer(); end
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class ActionCable::Server::Worker
  def __callbacks(); end

  def __callbacks?(); end

  def _run_work_callbacks(&block); end

  def _work_callbacks(); end

  def async_exec(receiver, *args, connection:, &block); end

  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  def connection(); end

  def connection=(obj); end

  def executor(); end

  def halt(); end

  def initialize(max_size: T.unsafe(nil)); end

  def invoke(receiver, method, *args, connection:, &block); end

  def stopping?(); end

  def work(connection, &block); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections(&block); end
end

class ActionCable::Server::Worker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._work_callbacks(); end

  def self._work_callbacks=(value); end

  def self.connection(); end

  def self.connection=(obj); end
end

class ActionCable::SubscriptionAdapter::Async::AsyncSubscriberMap
  def add_subscriber(*arg); end

  def initialize(event_loop); end

  def invoke_callback(*arg); end
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def identifier(); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::Inline
  def initialize(*arg); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::PostgreSQL
  include ::ActionCable::SubscriptionAdapter::ChannelPrefix
  def initialize(*arg); end

  def with_broadcast_connection(&block); end

  def with_subscriptions_connection(&block); end
end

class ActionCable::SubscriptionAdapter::PostgreSQL::Listener
  def initialize(adapter, event_loop); end

  def invoke_callback(*arg); end

  def listen(); end

  def shutdown(); end
end

class ActionCable::SubscriptionAdapter::PostgreSQL::Listener
end

class ActionCable::SubscriptionAdapter::PostgreSQL
end

class ActionCable::SubscriptionAdapter::Redis
  include ::ActionCable::SubscriptionAdapter::ChannelPrefix
  def initialize(*arg); end

  def redis_connection_for_subscriptions(); end

  def redis_connector(); end

  def redis_connector=(val); end
end

class ActionCable::SubscriptionAdapter::Redis::Listener
  def initialize(adapter, config_options, event_loop); end

  def invoke_callback(*arg); end

  def listen(conn); end

  def shutdown(); end
end

ActionCable::SubscriptionAdapter::Redis::Listener::ConnectionError = RedisClient::ConnectionError

class ActionCable::SubscriptionAdapter::Redis::Listener
end

class ActionCable::SubscriptionAdapter::Redis
  def self.redis_connector(); end

  def self.redis_connector=(val); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::Test
  def broadcasts(channel); end

  def clear(); end

  def clear_messages(channel); end
end

module ActionCable::TestHelper
  def after_teardown(); end

  def assert_broadcast_on(stream, data, &block); end

  def assert_broadcasts(stream, number, &block); end

  def assert_no_broadcasts(stream, &block); end

  def before_setup(); end

  def broadcasts(*arg, **arg1, &arg2); end

  def capture_broadcasts(stream, &block); end

  def clear_messages(*arg, **arg1, &arg2); end

  def pubsub_adapter(); end
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(_renderers); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _serialization_scope(); end

  def _serialization_scope=(_serialization_scope); end

  def _serialization_scope?(); end

  def _wrapper_options(); end

  def _wrapper_options=(_wrapper_options); end

  def _wrapper_options?(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def etaggers(); end

  def etaggers=(etaggers); end

  def etaggers?(); end

  def helpers_path(); end

  def helpers_path=(helpers_path); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(include_all_helpers); end

  def include_all_helpers?(); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(mimes_for_respond_to); end

  def mimes_for_respond_to?(); end

  def namespace_for_serializer=(namespace_for_serializer); end

  def raise_on_missing_callback_actions(); end

  def raise_on_missing_callback_actions=(val); end

  def raise_on_open_redirects(); end

  def raise_on_open_redirects=(val); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(responder); end

  def responder?(); end
end

module ActionController::API::HelperMethods
  def current_user(*args, **arg, &block); end

  def devise_controller?(*args, **arg, &block); end

  def signed_in?(*args, **arg, &block); end

  def user_session(*args, **arg, &block); end

  def user_signed_in?(*args, **arg, &block); end

  def warden(*args, **arg, &block); end
end

class ActionController::API
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(value); end

  def self._renderers?(); end

  def self._serialization_scope(); end

  def self._serialization_scope=(value); end

  def self._serialization_scope?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(value); end

  def self._wrapper_options?(); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.etaggers(); end

  def self.etaggers=(value); end

  def self.etaggers?(); end

  def self.helpers_path(); end

  def self.helpers_path=(value); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(value); end

  def self.include_all_helpers?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(value); end

  def self.mimes_for_respond_to?(); end

  def self.raise_on_missing_callback_actions(); end

  def self.raise_on_missing_callback_actions=(val); end

  def self.raise_on_open_redirects(); end

  def self.raise_on_open_redirects=(val); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(value); end

  def self.responder?(); end

  def self.without_modules(*modules); end
end

module ActionController::ApiRendering
  def render_to_body(options=T.unsafe(nil)); end
end

class ActionController::Base
  include ::Turbo::Native::Navigation
  include ::Turbo::Frames::FrameRequest
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _layout_conditions(&block); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(_renderers); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _serialization_scope(); end

  def _serialization_scope=(_serialization_scope); end

  def _serialization_scope?(); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(_view_cache_dependencies); end

  def _view_cache_dependencies?(); end

  def _wrapper_options(); end

  def _wrapper_options=(_wrapper_options); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def csrf_token_storage_strategy(); end

  def csrf_token_storage_strategy=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_protect_from_forgery(); end

  def default_protect_from_forgery=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(etag_with_template_digest); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(etaggers); end

  def etaggers?(); end

  def flash(*arg, **arg1, &arg2); end

  def forgery_protection_origin_check(); end

  def forgery_protection_origin_check=(value); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(fragment_cache_keys); end

  def fragment_cache_keys?(); end

  def helpers_path(); end

  def helpers_path=(helpers_path); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(include_all_helpers); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(mimes_for_respond_to); end

  def mimes_for_respond_to?(); end

  def namespace_for_serializer=(namespace_for_serializer); end

  def notice(); end

  def per_form_csrf_tokens(); end

  def per_form_csrf_tokens=(value); end

  def perform_caching(); end

  def perform_caching=(value); end

  def raise_on_missing_callback_actions(); end

  def raise_on_missing_callback_actions=(val); end

  def raise_on_open_redirects(); end

  def raise_on_open_redirects=(val); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(responder); end

  def responder?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end
end

module ActionController::Base::HelperMethods
  def alert(*args, **arg, &block); end

  def combined_fragment_cache_key(*args, **arg, &block); end

  def content_security_policy?(*args, **arg, &block); end

  def content_security_policy_nonce(*args, **arg, &block); end

  def cookies(*args, **arg, &block); end

  def current_user(*args, **arg, &block); end

  def devise_controller?(*args, **arg, &block); end

  def form_authenticity_token(*args, **arg, &block); end

  def notice(*args, **arg, &block); end

  def protect_against_forgery?(*args, **arg, &block); end

  def signed_in?(*args, **arg, &block); end

  def turbo_frame_request_id(*args, **arg, &block); end

  def turbo_native_app?(*args, **arg, &block); end

  def user_session(*args, **arg, &block); end

  def user_signed_in?(*args, **arg, &block); end

  def view_cache_dependencies(*args, **arg, &block); end

  def warden(*args, **arg, &block); end
end

class ActionController::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(value); end

  def self._default_form_builder?(); end

  def self._flash_types(); end

  def self._flash_types=(value); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._layout(); end

  def self._layout=(value); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(value); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(value); end

  def self._renderers?(); end

  def self._serialization_scope(); end

  def self._serialization_scope=(value); end

  def self._serialization_scope?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(value); end

  def self._view_cache_dependencies?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(value); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.csrf_token_storage_strategy(); end

  def self.csrf_token_storage_strategy=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_protect_from_forgery(); end

  def self.default_protect_from_forgery=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(value); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(value); end

  def self.etaggers?(); end

  def self.forgery_protection_origin_check(); end

  def self.forgery_protection_origin_check=(value); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(value); end

  def self.fragment_cache_keys?(); end

  def self.helpers_path(); end

  def self.helpers_path=(value); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(value); end

  def self.include_all_helpers?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(value); end

  def self.mimes_for_respond_to?(); end

  def self.per_form_csrf_tokens(); end

  def self.per_form_csrf_tokens=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.raise_on_missing_callback_actions(); end

  def self.raise_on_missing_callback_actions=(val); end

  def self.raise_on_open_redirects(); end

  def self.raise_on_open_redirects=(val); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(value); end

  def self.responder?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.without_modules(*modules); end
end

module ActionController::BasicImplicitRender
  def default_render(); end

  def send_action(method, *args); end
end

module ActionController::ConditionalGet
  def expires_in(seconds, options=T.unsafe(nil)); end

  def expires_now(); end

  def fresh_when(object=T.unsafe(nil), etag: T.unsafe(nil), weak_etag: T.unsafe(nil), strong_etag: T.unsafe(nil), last_modified: T.unsafe(nil), public: T.unsafe(nil), cache_control: T.unsafe(nil), template: T.unsafe(nil)); end

  def http_cache_forever(public: T.unsafe(nil)); end

  def no_store(); end

  def stale?(object=T.unsafe(nil), **freshness_kwargs); end
end

module ActionController::ConditionalGet::ClassMethods
  def etag(&etagger); end
end

module ActionController::ContentSecurityPolicy::ClassMethods
  def content_security_policy(enabled=T.unsafe(nil), **options, &block); end

  def content_security_policy_report_only(report_only=T.unsafe(nil), **options); end
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DefaultHeaders::ClassMethods
  def make_response!(request); end
end

module ActionController::Flash::ClassMethods
  def action_methods(); end
end

module ActionController::FormBuilder
  def default_form_builder(); end
end

module ActionController::FormBuilder::ClassMethods
  def default_form_builder(builder); end
end

module ActionController::Head
  def head(status, options=T.unsafe(nil)); end
end

module ActionController::Helpers
  def helpers(); end
end

module ActionController::Helpers::ClassMethods
  def helper_attr(*attrs); end

  def modules_for_helpers(args); end
end

module ActionController::Helpers
  def self.helpers_path(); end

  def self.helpers_path=(helpers_path); end
end

module ActionController::HttpAuthentication::Basic
  def auth_param(request); end

  def auth_scheme(request); end

  def authenticate(request, &login_procedure); end

  def authentication_request(controller, realm, message); end

  def decode_credentials(request); end

  def encode_credentials(user_name, password); end

  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  def authenticate_or_request_with_http_basic(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_basic(&login_procedure); end

  def http_basic_authenticate_or_request_with(name:, password:, realm: T.unsafe(nil), message: T.unsafe(nil)); end

  def request_http_basic_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def decode_credentials(header); end

  def decode_credentials_header(request); end

  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  def expected_response(http_method, uri, credentials, password, password_is_ha1=T.unsafe(nil)); end

  def ha1(credentials, password); end

  def nonce(secret_key, time=T.unsafe(nil)); end

  def opaque(secret_key); end

  def secret_token(request); end

  def validate_digest_response(request, realm, &password_procedure); end

  def validate_nonce(secret_key, request, value, seconds_to_timeout=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm=T.unsafe(nil), message=T.unsafe(nil), &password_procedure); end

  def authenticate_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def request_http_digest_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token
  def authenticate(controller, &login_procedure); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def encode_credentials(token, options=T.unsafe(nil)); end

  def params_array_from(raw_params); end

  def raw_params(auth); end

  def rewrite_param_values(array_params); end

  def token_and_options(request); end

  def token_params_from(auth); end
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_token(&login_procedure); end

  def request_http_token_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::ImplicitRender
  def default_render(); end

  def method_for_action(action_name); end
end

module ActionController::Instrumentation
  def initialize(*arg, **arg1, &arg2); end

  def redirect_to(*arg); end

  def render(*arg); end

  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end

  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

module ActionController::Instrumentation::ClassMethods
  def log_process_action(payload); end
end

module ActionController::Live
  def new_controller_thread(); end

  def process(name); end

  def response_body=(body); end

  def send_stream(filename:, disposition: T.unsafe(nil), type: T.unsafe(nil)); end
end

class ActionController::Live::Buffer
  def call_on_error(); end

  def connected?(); end

  def ignore_disconnect(); end

  def ignore_disconnect=(ignore_disconnect); end

  def initialize(response); end

  def on_error(&block); end

  def writeln(string); end
end

class ActionController::Live::Buffer
  def self.queue_size(); end

  def self.queue_size=(queue_size); end
end

module ActionController::Live::ClassMethods
  def make_response!(request); end
end

class ActionController::Live::SSE
  def close(); end

  def initialize(stream, options=T.unsafe(nil)); end

  def write(object, options=T.unsafe(nil)); end
  PERMITTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::LiveTestResponse
  def error?(); end

  def missing?(); end

  def success?(); end
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

module ActionController::Logging::ClassMethods
  def log_at(level, **options); end
end

class ActionController::Metal
  def content_type(*arg, **arg1, &arg2); end

  def content_type=(arg); end

  def controller_name(); end

  def dispatch(name, request, response); end

  def headers(*arg, **arg1, &arg2); end

  def location(*arg, **arg1, &arg2); end

  def location=(arg); end

  def media_type(*arg, **arg1, &arg2); end

  def middleware_stack(); end

  def middleware_stack=(middleware_stack); end

  def middleware_stack?(); end

  def response=(response); end

  def response_body=(body); end

  def response_code(*arg, **arg1, &arg2); end

  def session(*arg, **arg1, &arg2); end

  def set_request!(request); end

  def set_response!(response); end

  def status(*arg, **arg1, &arg2); end

  def status=(arg); end

  def to_a(); end

  def url_for(string); end
end

class ActionController::Metal
  def self.action(name); end

  def self.action_encoding_template(action); end

  def self.controller_name(); end

  def self.dispatch(name, req, res); end

  def self.make_response!(request); end

  def self.middleware(); end

  def self.middleware_stack(); end

  def self.middleware_stack=(value); end

  def self.middleware_stack?(); end

  def self.use(*arg, **arg1, &arg2); end
end

class ActionController::MiddlewareStack
  def build(action, app=T.unsafe(nil), &block); end
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack::Middleware
  def initialize(klass, args, actions, strategy, block); end

  def valid?(action); end
end

class ActionController::MimeResponds::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def any_response?(); end

  def custom(mime_type, &block); end

  def format(); end

  def format=(format); end

  def initialize(mimes, variant=T.unsafe(nil)); end

  def negotiate_format(request); end

  def response(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def all(*args, &block); end

  def any(*args, &block); end

  def initialize(variant=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def variant(); end
end

module ActionController::ParameterEncoding::ClassMethods
  def action_encoding_template(action); end

  def inherited(klass); end

  def param_encoding(action, param, encoding); end

  def setup_param_encode(); end

  def skip_parameter_encoding(action); end
end

class ActionController::Parameters
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  def inherited(klass); end

  def wrap_parameters(name_or_model_or_options, options=T.unsafe(nil)); end
end

class ActionController::ParamsWrapper::Options
  def initialize(name, format, include, exclude, klass, model); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActionController::ParamsWrapper::Options
  def self.from_hash(hash); end
end

module ActionController::PermissionsPolicy::ClassMethods
  def permissions_policy(**options, &block); end
end

module ActionController::Redirecting
  def _compute_redirect_to_location(request, options); end

  def redirect_back(fallback_location:, allow_other_host: T.unsafe(nil), **args); end

  def redirect_back_or_to(fallback_location, allow_other_host: T.unsafe(nil), **options); end

  def redirect_to(options=T.unsafe(nil), response_options=T.unsafe(nil)); end

  def url_from(location); end
  ILLEGAL_HEADER_VALUE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::Redirecting
  def self._compute_redirect_to_location(request, options); end
end

class ActionController::Renderer
  def controller(); end

  def defaults(); end

  def initialize(controller, env, defaults); end

  def new(env=T.unsafe(nil)); end

  def normalize_env(env, &block); end

  def render(*args); end

  def render_to_string(*args); end

  def with_defaults(defaults); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionController::Renderer
  def self.for(controller, env=T.unsafe(nil), defaults=T.unsafe(nil)); end

  def self.normalize_env(env); end
end

module ActionController::Renderers
  def _render_with_renderer_turbo_stream(turbo_streams_html, options); end
end

module ActionController::Rendering
  def render(*args); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*arg); end
end

module ActionController::Rendering::ClassMethods
  def inherited(klass); end

  def render(*arg, **arg1, &arg2); end

  def renderer(); end

  def setup_renderer!(); end
end

module ActionController::RequestForgeryProtection
  def commit_csrf_token(request); end

  def initialize(*arg, **arg1, &arg2); end

  def reset_csrf_token(request); end
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  CSRF_TOKEN = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RequestForgeryProtection::CookieStore
  def fetch(request); end

  def initialize(cookie=T.unsafe(nil)); end

  def reset(request); end

  def store(request, csrf_token); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  def handle_unverified_request(); end

  def initialize(controller); end

  def warning_message(); end

  def warning_message=(warning_message); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
  def write(*arg); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
  def enabled?(); end

  def initialize(req); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::SessionStore
  def fetch(request); end

  def reset(request); end

  def store(request, csrf_token); end
end

module ActionController::Rescue
  def show_detailed_exceptions?(); end
end

class ActionController::Streaming::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

module ActionController::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end
end

class ActionController::TestCase
  def _controller_class(); end

  def _controller_class=(_controller_class); end

  def _controller_class?(); end
end

module ActionController::TestCase::Behavior
  def build_response(klass); end

  def controller_class_name(); end

  def delete(action, **args); end

  def generated_path(generated_extras); end

  def get(action, **args); end

  def head(action, **args); end

  def patch(action, **args); end

  def post(action, **args); end

  def process(action, method: T.unsafe(nil), params: T.unsafe(nil), session: T.unsafe(nil), body: T.unsafe(nil), flash: T.unsafe(nil), format: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def put(action, **args); end

  def query_parameter_names(generated_extras); end

  def request(); end

  def response(); end

  def setup_controller_request_and_response(); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class(); end

  def controller_class=(new_class); end

  def determine_default_controller_class(name); end

  def tests(controller_class); end
end

class ActionController::TestCase
  def self._controller_class(); end

  def self._controller_class=(value); end

  def self._controller_class?(); end

  def self.executor_around_each_request(); end

  def self.executor_around_each_request=(executor_around_each_request); end
end

class ActionController::TestRequest
  def assign_parameters(routes, controller_path, action, parameters, generated_path, query_string_keys); end

  def content_type=(type); end

  def initialize(env, session, controller_class); end

  def query_string=(string); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
  def self.create(controller_class); end

  def self.new_session(); end
end

class ActionController::TestSession
  def dig(*keys); end

  def enabled?(); end

  def fetch(key, *args, &block); end

  def id_was(); end

  def initialize(session=T.unsafe(nil), id=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::Testing::Functional
  def clear_instance_variables_between_requests(); end

  def recycle!(); end
end

module ActionController::UrlFor
  def initialize(*arg, **arg1, &arg2); end

  def url_options(); end
end

class ActionDispatch::ActionableExceptions
  def call(env); end

  def endpoint(); end

  def endpoint=(val); end

  def initialize(app); end
end

class ActionDispatch::ActionableExceptions
  def self.endpoint(); end

  def self.endpoint=(val); end
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(url_options=T.unsafe(nil), options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, **arg, &block); end

  def setup(); end

  def with_routing(&block); end
end

class ActionDispatch::AssumeSSL
  def call(env); end

  def initialize(app); end
end

class ActionDispatch::AssumeSSL
end

class ActionDispatch::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end
end

module ActionDispatch::Constants
  CONTENT_ENCODING = ::T.let(nil, ::T.untyped)
  CONTENT_SECURITY_POLICY = ::T.let(nil, ::T.untyped)
  CONTENT_SECURITY_POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
  FEATURE_POLICY = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  SERVER_TIMING = ::T.let(nil, ::T.untyped)
  STRICT_TRANSPORT_SECURITY = ::T.let(nil, ::T.untyped)
  VARY = ::T.let(nil, ::T.untyped)
  X_CASCADE = ::T.let(nil, ::T.untyped)
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_DIRECTIVES = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SAME_SITE_PROTECTION = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
  USE_COOKIES_WITH_METADATA = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::AbstractCookieJar
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar); end

  def request(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(val); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def has_key?(name); end

  def initialize(request); end

  def key?(name); end

  def request(); end

  def to_hash(*arg); end

  def to_header(); end

  def update(other_hash); end

  def update_cookies_from_jar(); end

  def write(response); end
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(val); end

  def self.build(req, cookies); end
end

module ActionDispatch::Cookies::SerializedCookieJars
  def digest(); end
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil), interceptors=T.unsafe(nil)); end
end

class ActionDispatch::DebugExceptions
  def self.interceptors(); end

  def self.register_interceptor(object=T.unsafe(nil), &block); end
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def error_highlight_available?(); end

  def initialize(assigns); end

  def params_valid?(); end

  def protect_against_forgery?(); end

  def render(*arg); end
  RESCUES_TEMPLATE_PATHS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugView
end

class ActionDispatch::ExceptionWrapper
  def actions(); end

  def annotated_source_code(); end

  def application_trace(); end

  def backtrace_cleaner(); end

  def corrections(); end

  def error_highlight_available?(); end

  def exception(); end

  def exception_class_name(); end

  def exception_id(); end

  def exception_inspect(); end

  def exception_name(); end

  def exception_trace(); end

  def failures(); end

  def file_name(); end

  def framework_trace(); end

  def full_trace(); end

  def has_cause?(); end

  def has_corrections?(); end

  def initialize(backtrace_cleaner, exception); end

  def line_number(); end

  def message(); end

  def original_message(); end

  def rescue_response?(); end

  def rescue_responses(); end

  def rescue_responses=(val); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(val); end

  def routing_error?(); end

  def show?(request); end

  def silent_exceptions(); end

  def silent_exceptions=(val); end

  def source_extracts(); end

  def source_to_show_id(); end

  def status_code(); end

  def sub_template_message(); end

  def template_error?(); end

  def trace_to_show(); end

  def traces(); end

  def unwrapped_exception(); end

  def wrapped_causes(); end

  def wrapper_exceptions(); end

  def wrapper_exceptions=(val); end
end

class ActionDispatch::ExceptionWrapper::SourceMapLocation
  def initialize(location, template); end

  def spot(exc); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(val); end

  def self.rescue_templates(); end

  def self.rescue_templates=(val); end

  def self.silent_exceptions(); end

  def self.silent_exceptions=(val); end

  def self.status_code_for_exception(class_name); end

  def self.wrapper_exceptions(); end

  def self.wrapper_exceptions=(val); end
end

class ActionDispatch::Executor
  def call(env); end

  def initialize(app, executor); end
end

class ActionDispatch::FileHandler
  def attempt(env); end

  def call(env); end

  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil), precompressed: T.unsafe(nil), compressible_content_types: T.unsafe(nil)); end
  PRECOMPRESSED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

module ActionDispatch::Flash::RequestMethods
  def commit_flash(); end

  def flash(); end

  def flash=(flash); end

  def flash_hash(); end

  def reset_session(); end
end

class ActionDispatch::Flash
  def self.new(app); end
end

class ActionDispatch::HostAuthorization
  def call(env); end

  def initialize(app, hosts, exclude: T.unsafe(nil), response_app: T.unsafe(nil)); end
  ALLOWED_HOSTS_IN_DEVELOPMENT = ::T.let(nil, ::T.untyped)
  IPV4_HOSTNAME = ::T.let(nil, ::T.untyped)
  IPV6_HOSTNAME = ::T.let(nil, ::T.untyped)
  IPV6_HOSTNAME_WITH_PORT = ::T.let(nil, ::T.untyped)
  PORT_REGEX = ::T.let(nil, ::T.untyped)
  SUBDOMAIN_REGEX = ::T.let(nil, ::T.untyped)
  VALID_IP_HOSTNAME = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::DefaultResponseApp
  def call(env); end
  RESPONSE_STATUS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::Permissions
  def allows?(host); end

  def empty?(); end

  def initialize(hosts); end
end

module ActionDispatch::Http::Cache::Response
  NO_STORE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
end

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, **args); end

  def follow_redirect!(headers: T.unsafe(nil), **args); end

  def get(path, **args); end

  def head(path, **args); end

  def options(path, **args); end

  def patch(path, **args); end

  def post(path, **args); end

  def put(path, **args); end
end

module ActionDispatch::Integration::RequestHelpers
end

module ActionDispatch::Integration::Runner
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  def app(); end

  def assertions(); end

  def assertions=(assertions); end

  def assigns(*arg, **arg1, &arg2); end

  def before_setup(); end

  def cookies(*arg, **arg1, &arg2); end

  def copy_session_variables!(); end

  def create_session(app); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*arg, **arg1, &arg2); end

  def follow_redirect!(*arg, **arg1, &arg2); end

  def get(*arg, **arg1, &arg2); end

  def head(*arg, **arg1, &arg2); end

  def initialize(*args, &blk); end

  def integration_session(); end

  def open_session(); end

  def patch(*arg, **arg1, &arg2); end

  def post(*arg, **arg1, &arg2); end

  def put(*arg, **arg1, &arg2); end

  def remove!(); end

  def reset!(); end

  def root_session(); end

  def root_session=(root_session); end
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
end

class ActionDispatch::Integration::Session
  include ::Minitest::Assertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::ActionDispatch::Integration::RequestHelpers
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def accept(); end

  def accept=(accept); end

  def body(*arg, **arg1, &arg2); end

  def controller(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def headers(*arg, **arg1, &arg2); end

  def host(); end

  def host!(arg); end

  def host=(host); end

  def https!(flag=T.unsafe(nil)); end

  def https?(); end

  def initialize(app); end

  def path(*arg, **arg1, &arg2); end

  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def redirect?(*arg, **arg1, &arg2); end

  def remote_addr(); end

  def remote_addr=(remote_addr); end

  def request(); end

  def request_count(); end

  def request_count=(request_count); end

  def reset!(); end

  def response(); end

  def status(*arg, **arg1, &arg2); end

  def status_message(*arg, **arg1, &arg2); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end
end

module ActionDispatch::Integration
end

class ActionDispatch::IntegrationTest
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::IntegrationTest::UrlOptions
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestCase::ClearTestDeliveries
  include ::Turbo::TestAssertions::IntegrationTestAssertions
end

module ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::ActionController::TemplateAssertions
  def app(); end

  def document_root_element(); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app(); end

  def app=(app); end

  def register_encoder(*args, **options); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::IntegrationTest::Behavior
  extend ::ActiveSupport::Concern
end

module ActionDispatch::IntegrationTest::UrlOptions
  def url_options(); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::IntegrationTest
  extend ::ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

class ActionDispatch::Journey::Format
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
  DUMMY_END_NODE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Simulator
  INITIAL_STATE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::TransitionTable
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
  DEFAULT_EXP_ANCHORED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
  GREEDY_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::LogSubscriber
  def redirect(event); end
end

class ActionDispatch::MiddlewareStack
  def [](i); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def delete!(target); end

  def each(&block); end

  def initialize(*args); end

  def insert(index, klass, *args, **arg, &block); end

  def insert_after(index, *args, **arg, &block); end

  def insert_before(index, klass, *args, **arg, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def move(target, source); end

  def move_after(target, source); end

  def move_before(target, source); end

  def size(); end

  def swap(target, *args, **arg, &block); end

  def unshift(klass, *args, **arg, &block); end

  def use(klass, *args, **arg, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def build_instrumented(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

module ActionDispatch::PermissionsPolicy::Request
  POLICY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, ip_spoofing_check=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def initialize(req, check_ip, proxies); end
end

class ActionDispatch::Request
  include ::ActionDispatch::Flash::RequestMethods
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::RequestCookieMethods
  def authenticated_encrypted_cookie_salt(); end

  def commit_cookie_jar!(); end

  def cookie_jar(); end

  def cookie_jar=(jar); end

  def cookies_digest(); end

  def cookies_rotations(); end

  def cookies_same_site_protection(); end

  def cookies_serializer(); end

  def encrypted_cookie_cipher(); end

  def encrypted_cookie_salt(); end

  def encrypted_signed_cookie_salt(); end

  def have_cookie_jar?(); end

  def key_generator(); end

  def secret_key_base(); end

  def signed_cookie_digest(); end

  def signed_cookie_salt(); end

  def use_authenticated_cookie_encryption(); end

  def use_cookies_with_metadata(); end
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app, header:); end
end

class ActionDispatch::Response
  def [](*arg, **arg1, &arg2); end

  def []=(*arg, **arg1, &arg2); end

  def _cache_control(); end

  def _cache_control=(value); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(val); end

  def default_headers(); end

  def default_headers=(val); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), headers=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
  def <<(string); end

  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def to_ary(); end

  def write(string); end
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), headers=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(val); end

  def self.default_headers(); end

  def self.default_headers=(val); end

  def self.merge_default_headers(original, default); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::ConsoleFormatter::Base
  def header(routes); end

  def no_routes(routes, filter); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
  def initialize(width: T.unsafe(nil)); end
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(*arg); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::Mapper
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Resources
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
  POISON = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet
  include ::Devise::RouteSet
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _letter_opener_web(); end

  def _main_app(); end

  def letter_opener_web(); end

  def main_app(); end
end

class ActionDispatch::Routing::RouteWrapper
  def action(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def internal?(); end

  def matches_filter?(filter, value); end

  def name(); end

  def path(); end

  def rack_app(); end

  def reqs(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil), ssl_default_redirect_status: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
  PERMANENT_REDIRECT_REQUEST_METHODS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

class ActionDispatch::ServerTiming
  def call(env); end

  def initialize(app); end
end

class ActionDispatch::ServerTiming::Subscriber
  def call(event); end

  def collect_events(); end

  def ensure_subscribed(); end

  def unsubscribe(); end
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ServerTiming
  def self.unsubscribe(); end
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
  DEFAULT_SAME_SITE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Session::CookieStore::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Session::SessionObject
  def commit_session(req, res); end

  def loaded_session?(session); end

  def prepare_session(req); end
end

class ActionDispatch::Session::SessionRestoreError
  def initialize(); end
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class ActionDispatch::SystemTestCase
  include ::Capybara::DSL
  include ::Capybara::Minitest::Assertions
  include ::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  include ::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  include ::ActionText::SystemTestHelper
  def initialize(*arg); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SystemTestCase
  def self.driven_by(driver, using: T.unsafe(nil), screen_size: T.unsafe(nil), options: T.unsafe(nil), &capabilities); end

  def self.driver(); end

  def self.driver=(value); end

  def self.driver?(); end

  def self.start_application(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def take_failed_screenshot(); end

  def take_screenshot(html: T.unsafe(nil), screenshot: T.unsafe(nil)); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  def after_teardown(); end

  def before_teardown(); end
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
end

module ActionDispatch::TestProcess
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess::FixtureFile
  def file_fixture_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def path=(path); end

  def port=(number); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.create(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def parsed_body(); end

  def response_parser(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

class ActionMailbox::Base
  include ::ActionMailbox::Routing
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_now_with(message); end

  def bounce_with(message); end

  def bounced!(*arg, **arg1, &arg2); end

  def delivered!(*arg, **arg1, &arg2); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(&block); end

  def mail(*arg, **arg1, &arg2); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def router(); end

  def router=(val); end
end

class ActionMailbox::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(val); end
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks::ClassMethods
  def after_processing(*methods, &block); end

  def around_processing(*methods, &block); end

  def before_processing(*methods, &block); end
end

class ActionMailbox::InboundEmail
  include ::ActionMailbox::InboundEmail::Routable
  include ::ActionMailbox::InboundEmail::MessageId
  def autosave_associated_records_for_raw_email_attachment(*args); end

  def autosave_associated_records_for_raw_email_blob(*args); end

  def instrumentation_payload(); end

  def mail(); end

  def processed?(); end

  def source(); end
end

module ActionMailbox::InboundEmail::GeneratedAssociationMethods
  def build_raw_email_attachment(*args, &block); end

  def build_raw_email_blob(*args, &block); end

  def create_raw_email_attachment(*args, &block); end

  def create_raw_email_attachment!(*args, &block); end

  def create_raw_email_blob(*args, &block); end

  def create_raw_email_blob!(*args, &block); end

  def raw_email(); end

  def raw_email=(attachable); end

  def raw_email_attachment(); end

  def raw_email_attachment=(value); end

  def raw_email_blob(); end

  def raw_email_blob=(value); end

  def reload_raw_email_attachment(); end

  def reload_raw_email_blob(); end

  def reset_raw_email_attachment(); end

  def reset_raw_email_blob(); end
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::Incineratable
  def incinerate(); end

  def incinerate_later(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
  def initialize(inbound_email); end

  def run(); end
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
  def create_and_extract_message_id!(source, **options); end
end

module ActionMailbox::InboundEmail::Routable
  def route(); end

  def route_later(); end
end

class ActionMailbox::InboundEmail
  def self.bounced(*args, **arg); end

  def self.delivered(*args, **arg); end

  def self.failed(*args, **arg); end

  def self.not_bounced(*args, **arg); end

  def self.not_delivered(*args, **arg); end

  def self.not_failed(*args, **arg); end

  def self.not_pending(*args, **arg); end

  def self.not_processing(*args, **arg); end

  def self.pending(*args, **arg); end

  def self.processing(*args, **arg); end

  def self.statuses(); end

  def self.with_attached_raw_email(*args, **arg); end
end

class ActionMailbox::IncinerationJob
  def perform(inbound_email); end
end

class ActionMailbox::IncinerationJob
  def self.schedule(inbound_email); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(key:, timestamp:, token:, signature:); end

  def key(); end

  def signature(); end

  def timestamp(); end

  def token(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
  def create(); end

  def health_check(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(request, key); end

  def key(); end

  def request(); end
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
  def create(); end
end

module ActionMailbox::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def mailbox_for(inbound_email); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

module ActionMailbox::Routing::ClassMethods
  def mailbox_for(inbound_email); end

  def route(inbound_email); end

  def routing(routes); end
end

class ActionMailbox::RoutingJob
  def perform(inbound_email); end
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options, &block); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs, &block); end

  def receive_inbound_email_from_source(*args); end
end

module ActionMailbox::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _deliver_callbacks(); end

  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def _layout_conditions(&block); end

  def _process_action_callbacks(); end

  def _run_deliver_callbacks(&block); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(_view_cache_dependencies); end

  def _view_cache_dependencies?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def attachments(); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_params(); end

  def default_params=(default_params); end

  def default_params?(); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def deliver_later_queue_name(); end

  def deliver_later_queue_name=(deliver_later_queue_name); end

  def deliver_later_queue_name?(); end

  def delivery_job(); end

  def delivery_job=(delivery_job); end

  def delivery_job?(); end

  def delivery_method(); end

  def delivery_method=(delivery_method); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(delivery_methods); end

  def delivery_methods?(); end

  def email_address_with_name(address, name); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def file_settings(); end

  def file_settings=(file_settings); end

  def file_settings?(); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(fragment_cache_keys); end

  def fragment_cache_keys?(); end

  def headers(args=T.unsafe(nil)); end

  def initialize(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def letter_opener_settings(); end

  def letter_opener_settings=(letter_opener_settings); end

  def letter_opener_settings?(); end

  def letter_opener_web_settings(); end

  def letter_opener_web_settings=(letter_opener_web_settings); end

  def letter_opener_web_settings?(); end

  def logger(); end

  def logger=(value); end

  def mailer_name(); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def perform_caching(); end

  def perform_caching=(value); end

  def perform_deliveries(); end

  def perform_deliveries=(val); end

  def preview_interceptors(); end

  def preview_paths(); end

  def process(method_name, *args, **arg); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(val); end

  def raise_on_missing_callback_actions(); end

  def raise_on_missing_callback_actions=(val); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def sendmail_settings(); end

  def sendmail_settings=(sendmail_settings); end

  def sendmail_settings?(); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(smtp_settings); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(test_settings); end

  def test_settings?(); end
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionMailer::Base::HelperMethods
  def combined_fragment_cache_key(*args, **arg, &block); end

  def view_cache_dependencies(*args, **arg, &block); end
end

class ActionMailer::Base::LateAttachmentsProxy
  def []=(_name, _content); end

  def inline(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::NullMail
  def body(); end

  def header(); end

  def method_missing(*args); end

  def respond_to?(string, include_all=T.unsafe(nil)); end
end

class ActionMailer::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(value); end

  def self._default_form_builder?(); end

  def self._deliver_callbacks(); end

  def self._deliver_callbacks=(value); end

  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._layout(); end

  def self._layout=(value); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(value); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(value); end

  def self._view_cache_dependencies?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default(value=T.unsafe(nil)); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_options=(value=T.unsafe(nil)); end

  def self.default_params(); end

  def self.default_params=(value); end

  def self.default_params?(); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.deliver_later_queue_name(); end

  def self.deliver_later_queue_name=(value); end

  def self.deliver_later_queue_name?(); end

  def self.deliver_mail(mail); end

  def self.delivery_job(); end

  def self.delivery_job=(value); end

  def self.delivery_job?(); end

  def self.delivery_method(); end

  def self.delivery_method=(value); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(value); end

  def self.delivery_methods?(); end

  def self.email_address_with_name(address, name); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.file_settings(); end

  def self.file_settings=(value); end

  def self.file_settings?(); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(value); end

  def self.fragment_cache_keys?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.letter_opener_settings(); end

  def self.letter_opener_settings=(value); end

  def self.letter_opener_settings?(); end

  def self.letter_opener_web_settings(); end

  def self.letter_opener_web_settings=(value); end

  def self.letter_opener_web_settings?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mailer_name(); end

  def self.mailer_name=(mailer_name); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(val); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(val); end

  def self.preview_paths(); end

  def self.preview_paths=(val); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(val); end

  def self.raise_on_missing_callback_actions(); end

  def self.raise_on_missing_callback_actions=(val); end

  def self.register_interceptor(interceptor); end

  def self.register_interceptors(*interceptors); end

  def self.register_observer(observer); end

  def self.register_observers(*observers); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(value); end

  def self.sendmail_settings?(); end

  def self.show_previews(); end

  def self.show_previews=(val); end

  def self.smtp_settings(); end

  def self.smtp_settings=(value); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(value); end

  def self.test_settings?(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_interceptors(*interceptors); end

  def self.unregister_observer(observer); end

  def self.unregister_observers(*observers); end
end

module ActionMailer::Callbacks::ClassMethods
  def after_deliver(*filters, &blk); end

  def around_deliver(*filters, &blk); end

  def before_deliver(*filters, &blk); end
end

class ActionMailer::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

module ActionMailer::DeliveryMethods
  def wrap_delivery_behavior!(*args); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  def add_delivery_method(symbol, klass, default_options=T.unsafe(nil)); end

  def deliveries(&block); end

  def deliveries=(arg); end

  def wrap_delivery_behavior(mail, method=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionMailer::FormBuilder
  def default_form_builder(); end
end

module ActionMailer::FormBuilder::ClassMethods
  def default_form_builder(builder); end
end

class ActionMailer::InlinePreviewInterceptor
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

class ActionMailer::LogSubscriber
  def deliver(event); end

  def process(event); end
end

class ActionMailer::MailDeliveryJob
  def perform(mailer, mail_method, delivery_method, args:, kwargs: T.unsafe(nil), params: T.unsafe(nil)); end
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

class ActionMailer::MessageDelivery
  def __setobj__(mail_message); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer_class, action, *args, **arg); end

  def message(); end

  def processed?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::NonInferrableMailerError
  def initialize(name); end
end

class ActionMailer::NonInferrableMailerError
end

module ActionMailer::Parameterized::ClassMethods
  def with(params); end
end

class ActionMailer::Parameterized::Mailer
  def initialize(mailer, params); end
end

class ActionMailer::Parameterized::MessageDelivery
  def initialize(mailer_class, action, params, *args, **arg); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Preview
  def initialize(params=T.unsafe(nil)); end

  def params(); end
end

class ActionMailer::Preview
  def self.all(); end

  def self.call(email, params=T.unsafe(nil)); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.preview_name(); end
end

module ActionMailer::Previews
  def preview_path(); end
end

module ActionMailer::Previews::ClassMethods
  def preview_path(); end

  def preview_path=(value); end

  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end

  def unregister_preview_interceptor(interceptor); end

  def unregister_preview_interceptors(*interceptors); end
end

module ActionMailer::Rescuable
  def handle_exceptions(); end
end

module ActionMailer::Rescuable::ClassMethods
  def handle_exception(exception); end
end

class ActionMailer::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def _mailer_class(); end

  def _mailer_class=(_mailer_class); end

  def _mailer_class?(); end
end

module ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActiveSupport::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def read_fixture(action); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
  def determine_default_mailer(name); end

  def mailer_class(); end

  def tests(mailer); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
end

module ActionMailer::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

module ActionMailer::TestCase::ClearTestDeliveries
end

module ActionMailer::TestCase::ClearTestDeliveries
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  extend ::ActionMailer::TestCase::Behavior::ClassMethods
  def self._mailer_class(); end

  def self._mailer_class=(value); end

  def self._mailer_class?(); end
end

module ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActiveSupport::Testing::Assertions
  def assert_emails(number, &block); end

  def assert_enqueued_email_with(mailer, method, params: T.unsafe(nil), args: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_emails(number, &block); end

  def assert_no_emails(&block); end

  def assert_no_enqueued_emails(&block); end

  def capture_emails(&block); end

  def deliver_enqueued_emails(queue: T.unsafe(nil), at: T.unsafe(nil), &block); end
end

module ActionMailer::TestHelper
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable
  def attachable_content_type(); end

  def attachable_filename(); end

  def attachable_filesize(); end

  def attachable_metadata(); end

  def attachable_sgid(); end

  def previewable_attachable?(); end

  def to_attachable_partial_path(); end

  def to_rich_text_attributes(attributes=T.unsafe(nil)); end

  def to_trix_content_attachment_partial_path(); end
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end

  def to_missing_attachable_partial_path(); end
end

module ActionText::Attachable
  def self.from_attachable_sgid(sgid, options=T.unsafe(nil)); end

  def self.from_node(node); end
end

class ActionText::Attachables::ContentAttachment
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachable_plain_text_representation(caption); end

  def content(); end

  def content=(content); end

  def content_type(); end

  def content_type=(content_type); end

  def model_name(&block); end

  def param_delimiter=(param_delimiter); end

  def to_html(); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.from_node(node); end

  def self.param_delimiter(); end

  def self.param_delimiter=(value); end

  def self.param_delimiter?(); end
end

class ActionText::Attachables::MissingAttachable
  def initialize(sgid); end

  def model(); end

  def model_name(&block); end

  def to_partial_path(); end
  DEFAULT_PARTIAL_PATH = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachables::RemoteImage
  def attachable_plain_text_representation(caption); end

  def content_type(); end

  def height(); end

  def initialize(attributes=T.unsafe(nil)); end

  def model_name(&block); end

  def to_partial_path(); end

  def url(); end

  def width(); end
end

class ActionText::Attachables::RemoteImage
  def self.from_node(node); end
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  def attachable(); end

  def caption(); end

  def full_attributes(); end

  def initialize(node, attachable); end

  def method_missing(method, *args, **arg, &block); end

  def node(); end

  def tag_name(); end

  def tag_name=(val); end

  def to_html(); end

  def to_param(*arg, **arg1, &arg2); end

  def to_plain_text(); end

  def with_full_attributes(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachment
  def self.fragment_by_canonicalizing_attachments(content); end

  def self.from_attachable(attachable, attributes=T.unsafe(nil)); end

  def self.from_attachables(attachables); end

  def self.from_attributes(attributes, attachable=T.unsafe(nil)); end

  def self.from_node(node, attachable=T.unsafe(nil)); end

  def self.tag_name(); end

  def self.tag_name=(val); end
end

class ActionText::AttachmentGallery
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachments(); end

  def initialize(node); end

  def model_name(&block); end

  def node(); end

  def param_delimiter=(param_delimiter); end

  def size(); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.attachment_selector(); end

  def self.find_attachment_gallery_nodes(content); end

  def self.fragment_by_canonicalizing_attachment_galleries(content); end

  def self.fragment_by_replacing_attachment_gallery_nodes(content); end

  def self.from_node(node); end

  def self.param_delimiter(); end

  def self.param_delimiter=(value); end

  def self.param_delimiter?(); end

  def self.selector(); end
end

module ActionText::Attachments::Caching
  def cache_key(*args); end
end

module ActionText::Attachments::TrixConversion
  def to_trix_attachment(content=T.unsafe(nil)); end
end

class ActionText::Content
  include ::ActionText::Serialization
  def ==(other); end

  def append_attachables(attachables); end

  def as_json(*arg); end

  def attachables(); end

  def attachment_galleries(); end

  def attachments(); end

  def blank?(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def fragment(); end

  def gallery_attachments(); end

  def html_safe(*arg, **arg1, &arg2); end

  def initialize(content=T.unsafe(nil), options=T.unsafe(nil)); end

  def links(); end

  def present?(*arg, **arg1, &arg2); end

  def render(*arg, **arg1, &arg2); end

  def render_attachment_galleries(&block); end

  def render_attachments(**options, &block); end

  def to_html(); end

  def to_partial_path(); end

  def to_plain_text(); end

  def to_rendered_html_with_layout(); end

  def to_trix_html(); end
end

class ActionText::Content
  def self.fragment_by_canonicalizing_content(content); end

  def self.renderer(); end

  def self.renderer=(obj); end
end

module ActionText::ContentHelper
  def allowed_attributes(); end

  def allowed_attributes=(val); end

  def allowed_tags(); end

  def allowed_tags=(val); end

  def render_action_text_attachment(attachment, locals: T.unsafe(nil)); end

  def render_action_text_attachments(content); end

  def render_action_text_content(content); end

  def sanitize_action_text_content(content); end

  def sanitizer(); end

  def sanitizer=(val); end

  def sanitizer_allowed_attributes(); end

  def sanitizer_allowed_tags(); end

  def scrubber(); end

  def scrubber=(val); end
end

module ActionText::ContentHelper
  def self.allowed_attributes(); end

  def self.allowed_attributes=(val); end

  def self.allowed_tags(); end

  def self.allowed_tags=(val); end

  def self.sanitizer(); end

  def self.sanitizer=(val); end

  def self.scrubber(); end

  def self.scrubber=(val); end
end

module ActionText::EncryptedRichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::Encryption
  def decrypt(); end

  def encrypt(); end
end

class ActionText::FixtureSet
end

class ActionText::FixtureSet
  def self.attachment(fixture_set_name, label, column_type: T.unsafe(nil)); end
end

class ActionText::Fragment
  def find_all(selector); end

  def initialize(source); end

  def replace(selector); end

  def source(); end

  def to_html(); end

  def to_plain_text(); end

  def update(); end
end

class ActionText::Fragment
  def self.from_html(html); end

  def self.wrap(fragment_or_html); end
end

module ActionText::HtmlConversion
  def create_element(tag_name, attributes=T.unsafe(nil)); end

  def fragment_for_html(html); end

  def node_to_html(node); end
end

module ActionText::PlainTextConversion
  def node_to_plain_text(node); end
end

module ActionText::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::Rendering::ClassMethods
  def action_controller_renderer(); end

  def render(*args, &block); end

  def with_renderer(renderer); end
end

class ActionText::RichText
  def autosave_associated_records_for_embeds_attachments(*args); end

  def autosave_associated_records_for_embeds_blobs(*args); end

  def autosave_associated_records_for_record(*args); end

  def blank?(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def nil?(*arg, **arg1, &arg2); end

  def present?(*arg, **arg1, &arg2); end

  def to_plain_text(); end

  def to_s(*arg, **arg1, &arg2); end

  def to_trix_html(); end

  def validate_associated_records_for_embeds_attachments(*args); end

  def validate_associated_records_for_embeds_blobs(*args); end
end

module ActionText::RichText::GeneratedAssociationMethods
  def embeds(); end

  def embeds=(attachables); end

  def embeds_attachment_ids(); end

  def embeds_attachment_ids=(ids); end

  def embeds_attachments(); end

  def embeds_attachments=(value); end

  def embeds_blob_ids(); end

  def embeds_blob_ids=(ids); end

  def embeds_blobs(); end

  def embeds_blobs=(value); end

  def record(); end

  def record=(value); end

  def record_changed?(); end

  def record_previously_changed?(); end

  def reload_record(); end

  def reset_record(); end
end

module ActionText::RichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActionText::RichText
  def self.with_attached_embeds(*args, **arg); end
end

module ActionText::Serialization
  def _dump(*arg); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end

  def dump(content); end

  def load(content); end
end

module ActionText::SystemTestHelper
  def fill_in_rich_text_area(locator=T.unsafe(nil), with:); end
end

module ActionText::SystemTestHelper
end

module ActionText::TagHelper
  def rich_text_area_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionText::TagHelper
  def self.id(); end

  def self.id=(val); end
end

class ActionText::TrixAttachment
  def attributes(); end

  def initialize(node); end

  def node(); end

  def to_html(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::TrixAttachment
  def self.from_attributes(attributes); end
end

module ActionText::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  NO_DETAILS = ::T.let(nil, ::T.untyped)
end

module ActionView::AbstractRenderer::ObjectRendering
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedTemplate
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  include ::ActionView::Context
  include ::ERB::Util
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil
  def _routes(); end

  def _routes=(_routes); end

  def _routes?(); end

  def _run(method, template, locals, buffer, add_to_stack: T.unsafe(nil), has_strict_locals: T.unsafe(nil), &block); end

  def annotate_rendered_view_with_filenames(); end

  def annotate_rendered_view_with_filenames=(val); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def automatically_disable_submit_tag(); end

  def automatically_disable_submit_tag=(val); end

  def compiled_method_container(); end

  def config(); end

  def config=(config); end

  def debug_missing_translation(); end

  def debug_missing_translation=(val); end

  def default_formats(); end

  def default_formats=(val); end

  def field_error_proc(); end

  def field_error_proc=(val); end

  def formats(*arg, **arg1, &arg2); end

  def formats=(arg); end

  def image_path_without_cloudinary(source, options=T.unsafe(nil)); end

  def image_tag_without_cloudinary(source, options=T.unsafe(nil)); end

  def in_rendering_context(options); end

  def initialize(lookup_context, assigns, controller); end

  def locale(*arg, **arg1, &arg2); end

  def locale=(arg); end

  def logger=(logger); end

  def logger?(); end

  def lookup_context(); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(prefix_partial_path_with_controller_namespace); end

  def prefix_partial_path_with_controller_namespace?(); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(val); end

  def view_paths(*arg, **arg1, &arg2); end

  def view_paths=(arg); end

  def view_renderer(); end
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(value); end

  def self._routes?(); end

  def self.annotate_rendered_view_with_filenames(); end

  def self.annotate_rendered_view_with_filenames=(val); end

  def self.automatically_disable_submit_tag(); end

  def self.automatically_disable_submit_tag=(val); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.changed?(other); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(val); end

  def self.default_form_builder(); end

  def self.default_form_builder=(val); end

  def self.default_formats(); end

  def self.default_formats=(val); end

  def self.empty(); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(val); end

  def self.logger(); end

  def self.logger=(value); end

  def self.logger?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(value); end

  def self.prefix_partial_path_with_controller_namespace?(); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(val); end

  def self.with_context(context, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.with_empty_template_cache(); end

  def self.with_view_paths(view_paths, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.xss_safe?(); end
end

class ActionView::CacheExpiry::ViewReloader
  def execute(); end

  def initialize(watcher:, &block); end

  def updated?(); end
end

module ActionView::Context
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

class ActionView::DependencyTracker::ERBTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::ERBTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker::RipperTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::RipperTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker
  def self.find_dependencies(name, template, view_paths=T.unsafe(nil)); end

  def self.register_tracker(extension, tracker); end

  def self.remove_tracker(handler); end
end

class ActionView::Digestor::Injected
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Missing
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Node
  def children(); end

  def dependency_digest(finder, stack); end

  def digest(finder, stack=T.unsafe(nil)); end

  def initialize(name, logical_name, template, children=T.unsafe(nil)); end

  def logical_name(); end

  def name(); end

  def template(); end

  def to_dep_map(); end
end

class ActionView::Digestor::Node
  def self.create(name, logical_name, template, partial); end
end

class ActionView::Digestor::NullLogger
  def self.debug(_); end

  def self.error(_); end
end

class ActionView::Digestor
  def self.digest(name:, finder:, format: T.unsafe(nil), dependencies: T.unsafe(nil)); end

  def self.logger(); end

  def self.tree(name, finder, partial=T.unsafe(nil), seen=T.unsafe(nil)); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path); end

  def path(); end

  def to_path(); end
end

module ActionView::Helpers::AssetTagHelper
  MAX_HEADER_SIZE = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ContentExfiltrationPreventionHelper
  CLOSE_CDATA_COMMENT = ::T.let(nil, ::T.untyped)
  CLOSE_FORM_TAG = ::T.let(nil, ::T.untyped)
  CLOSE_OPTION_TAG = ::T.let(nil, ::T.untyped)
  CLOSE_QUOTES_COMMENT = ::T.let(nil, ::T.untyped)
  CONTENT_EXFILTRATION_PREVENTION_MARKUP = ::T.let(nil, ::T.untyped)
end

class ActionView::Helpers::FormBuilder
  def rich_text_area(method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  def rich_text_area(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::TagHelper
  ARIA_PREFIXES = ::T.let(nil, ::T.untyped)
  DATA_PREFIXES = ::T.let(nil, ::T.untyped)
  TAG_TYPES = ::T.let(nil, ::T.untyped)
end

class ActionView::I18nProxy
  def initialize(original_config, lookup_context); end

  def locale=(value); end

  def lookup_context(); end

  def original_config(); end
end

module ActionView::Layouts
  def _normalize_options(options); end

  def action_has_layout=(action_has_layout); end

  def action_has_layout?(); end

  def initialize(*arg); end
end

class ActionView::LogSubscriber
  def render_collection(event); end

  def render_layout(event); end

  def render_partial(event); end

  def render_template(event); end
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber::Start
  def finish(name, id, payload); end

  def start(name, id, payload); end
end

module ActionView::LogSubscriber::Utils
  def logger(); end
end

class ActionView::LogSubscriber
  def self.attach_to(*arg); end
end

class ActionView::LookupContext
  def digest_cache(); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def with_prepended_formats(formats); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::DetailsCache
  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.details_cache_key(details); end

  def self.digest_cache(details); end

  def self.digest_caches(); end

  def self.view_context_class(); end
end

module ActionView::LookupContext::ViewPaths
  def any?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def any_templates?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def append_view_paths(paths); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def prepend_view_paths(paths); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def view_paths(); end
end

class ActionView::LookupContext
  def self.register_detail(name, &block); end

  def self.registered_details(); end

  def self.registered_details=(registered_details); end
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *arg); end

  def partial(); end

  def paths(); end

  def prefixes(); end
end

class ActionView::MissingTemplate::Results
  def add(path, score); end

  def initialize(size); end

  def should_record?(score); end

  def to_a(); end
end

class ActionView::MissingTemplate::Results::Result
  def path(); end

  def path=(_); end

  def score(); end

  def score=(_); end
end

class ActionView::MissingTemplate::Results::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActionView::ObjectRenderer
  include ::ActionView::AbstractRenderer::ObjectRendering
  def render_object_derive_partial(object, context, block); end

  def render_object_with_partial(object, partial, context, block); end
end

class ActionView::ObjectRenderer
end

class ActionView::OutputBuffer
  def <<(value); end

  def ==(other); end

  def append=(value); end

  def blank?(*arg, **arg1, &arg2); end

  def capture(*args); end

  def concat(value); end

  def empty?(*arg, **arg1, &arg2); end

  def encode!(*arg, **arg1, &arg2); end

  def encoding(*arg, **arg1, &arg2); end

  def force_encoding(*arg, **arg1, &arg2); end

  def html_safe(); end

  def initialize(buffer=T.unsafe(nil)); end

  def length(*arg, **arg1, &arg2); end

  def raw(); end

  def raw_buffer(); end

  def safe_append=(value); end

  def safe_concat(value); end

  def safe_expr_append=(val); end

  def to_str(); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

module ActionView::PathRegistry
  def self.all_file_system_resolvers(); end

  def self.all_resolvers(); end

  def self.cast_file_system_resolvers(paths); end

  def self.file_system_resolver_hooks(); end

  def self.get_view_paths(klass); end

  def self.set_view_paths(klass, paths); end
end

class ActionView::PathSet
  def +(other); end

  def [](*arg, **arg1, &arg2); end

  def each(*arg, **arg1, &arg2); end

  def exists?(path, prefixes, partial, details, details_key, locals); end

  def find(path, prefixes, partial, details, details_key, locals); end

  def find_all(path, prefixes, partial, details, details_key, locals); end

  def include?(*arg, **arg1, &arg2); end

  def initialize(paths=T.unsafe(nil)); end

  def paths(); end

  def size(*arg, **arg1, &arg2); end

  def to_ary(); end
end

class ActionView::RenderParser
  def initialize(name, code); end

  def render_calls(); end
  ALL_KNOWN_KEYS = ::T.let(nil, ::T.untyped)
  RENDER_TYPE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionView::RenderParser::RipperASTParser
  def parse_render_nodes(code); end
end

class ActionView::RenderParser::RipperASTParser::Node
  def argument_nodes(); end

  def call?(); end

  def call_method_name(); end

  def children(); end

  def fcall?(); end

  def fcall_named?(name); end

  def hash?(); end

  def hash_from_body(body); end

  def initialize(type, arr, opts=T.unsafe(nil)); end

  def string?(); end

  def symbol?(); end

  def to_hash(); end

  def to_string(); end

  def to_symbol(); end

  def type(); end

  def variable_name(); end

  def variable_reference?(); end

  def vcall?(); end
end

class ActionView::RenderParser::RipperASTParser::NodeParser
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(list, item); end

  def on_args_add_block(list, item); end

  def on_args_add_star(list, item); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_dedent(*args); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(list, item); end

  def on_method_add_block(list, item); end

  def on_mlhs_add(list, item); end

  def on_mlhs_add_post(list, item); end

  def on_mlhs_add_star(list, item); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(list, item); end

  def on_mrhs_add_star(list, item); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(list, item); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(list, item); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(list, item); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(list, item); end

  def on_stmts_new(*args); end

  def on_string_add(list, item); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(list, item); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(list, item); end

  def on_word_new(*args); end

  def on_words_add(list, item); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(list, item); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class ActionView::RenderParser::RipperASTParser::RenderCallExtractor
  def initialize(*args); end

  def render_calls(); end
  METHODS_TO_PARSE = ::T.let(nil, ::T.untyped)
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_partial_to_object(context, options, &block); end

  def render_template(context, options); end

  def render_template_to_object(context, options); end

  def render_to_object(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def initialize(); end

  def process(*arg, **arg1, &arg2); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_renderer(); end
end

class ActionView::Resolver
  def all_template_paths(); end

  def built_templates(); end

  def caching(); end

  def caching=(val); end

  def caching?(&block); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::Resolver::PathParser
  def build_path_regex(); end

  def parse(path); end
end

class ActionView::Resolver::PathParser::ParsedPath
  def details(); end

  def details=(_); end

  def path(); end

  def path=(_); end
end

class ActionView::Resolver::PathParser::ParsedPath
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(val); end

  def self.caching?(); end
end

module ActionView::RoutingUrlFor
  def default_url_options=(val); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(val); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def block(); end

  def capture(); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def raw(); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(view, template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::SyntaxErrorInTemplate
  def initialize(template, offending_code_string); end
end

class ActionView::Template
  def encode!(); end

  def format(); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, locals:, format: T.unsafe(nil), variant: T.unsafe(nil), virtual_path: T.unsafe(nil)); end

  def locals(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def method_name(); end

  def render(view, locals, buffer=T.unsafe(nil), implicit_locals: T.unsafe(nil), add_to_stack: T.unsafe(nil), &block); end

  def short_identifier(); end

  def source(); end

  def spot(location); end

  def strict_locals!(); end

  def strict_locals?(); end

  def supports_streaming?(); end

  def translate_location(backtrace_location, spot); end

  def type(); end

  def variable(); end

  def variant(); end

  def virtual_path(); end
  NONE = ::T.let(nil, ::T.untyped)
  STRICT_LOCALS_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Error
  def annotated_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end

  def template(); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::HTML
  def format(); end

  def identifier(); end

  def initialize(string, type); end

  def render(*args); end

  def to_str(); end

  def type(); end
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template, source); end

  def default_format(); end

  def default_format=(default_format); end

  def default_format?(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(value); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template, source); end

  def erb_implementation(); end

  def erb_implementation=(erb_implementation); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(erb_trim_mode); end

  def erb_trim_mode?(); end

  def escape_ignore_list(); end

  def escape_ignore_list=(escape_ignore_list); end

  def escape_ignore_list?(); end

  def handles_encoding?(); end

  def strip_trailing_newlines(); end

  def strip_trailing_newlines=(strip_trailing_newlines); end

  def strip_trailing_newlines?(); end

  def supports_streaming?(); end

  def translate_location(spot, backtrace_location, source); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB
  def self.call(template, source); end

  def self.erb_implementation(); end

  def self.erb_implementation=(value); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(value); end

  def self.erb_trim_mode?(); end

  def self.escape_ignore_list(); end

  def self.escape_ignore_list=(value); end

  def self.escape_ignore_list?(); end

  def self.strip_trailing_newlines(); end

  def self.strip_trailing_newlines=(value); end

  def self.strip_trailing_newlines?(); end
end

class ActionView::Template::Handlers::Raw
  def call(template, source); end
end

module ActionView::Template::Handlers
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::RawFile
  def format(); end

  def format=(format); end

  def identifier(); end

  def initialize(filename); end

  def render(*args); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Renderable
  def format(); end

  def identifier(); end

  def initialize(renderable); end

  def render(context, *args); end
end

class ActionView::Template::Renderable
end

class ActionView::Template::SimpleType
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_str(); end

  def to_sym(); end
end

class ActionView::Template::SimpleType
  def self.[](type); end

  def self.symbols(); end

  def self.valid_symbols?(symbols); end
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

class ActionView::Template::Text
  def format(); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

ActionView::Template::Types = Mime

class ActionView::Template
  def self.frozen_string_literal(); end

  def self.frozen_string_literal=(frozen_string_literal); end

  def self.mime_types_implementation=(implementation); end
end

class ActionView::TemplateDetails
  def format(); end

  def format_or_default(); end

  def handler(); end

  def handler_class(); end

  def initialize(locale, handler, format, variant); end

  def locale(); end

  def matches?(requested); end

  def sort_key_for(requested); end

  def variant(); end
end

class ActionView::TemplateDetails::Requested
  def formats(); end

  def formats_idx(); end

  def handlers(); end

  def handlers_idx(); end

  def initialize(locale:, handlers:, formats:, variants:); end

  def locale(); end

  def locale_idx(); end

  def variants(); end

  def variants_idx(); end
  ANY_HASH = ::T.let(nil, ::T.untyped)
end

class ActionView::TemplateDetails::Requested
end

class ActionView::TemplateDetails
end

class ActionView::TemplatePath
  def ==(other); end

  def eql?(other); end

  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end

  def virtual_path(); end
end

class ActionView::TemplatePath
  def self.build(name, prefix, partial); end

  def self.parse(virtual); end

  def self.virtual(name, prefix, partial); end
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(val); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*arg, **arg1, &arg2); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered_views(); end

  def request(); end

  def request=(request); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def inherited(descendant); end

  def new(*arg); end

  def register_parser(format, callable=T.unsafe(nil), &block); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

class ActionView::TestCase::Behavior::RenderedViewContent
  def html(); end

  def json(); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

module ActionView::TestCase::HelperMethods
  def _test_case(); end

  def protect_against_forgery?(); end
end

class ActionView::TestCase::TestController
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end

  def response=(response); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self.content_class(); end

  def self.content_class=(value); end

  def self.content_class?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(val); end
end

class ActionView::UnboundTemplate
  def bind_locals(locals); end

  def built_templates(); end

  def details(); end

  def format(*arg, **arg1, &arg2); end

  def handler(*arg, **arg1, &arg2); end

  def initialize(source, identifier, details:, virtual_path:); end

  def locale(*arg, **arg1, &arg2); end

  def variant(*arg, **arg1, &arg2); end

  def virtual_path(); end
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::ViewPaths
  def _prefixes(); end

  def any_templates?(*arg, **arg1, &arg2); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*arg, **arg1, &arg2); end

  def formats=(arg); end

  def locale(*arg, **arg1, &arg2); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*arg, **arg1, &arg2); end

  def view_paths(*arg, **arg1, &arg2); end
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Base
  include ::ActiveJob::TestHelper::TestQueueAdapter
  def __callbacks(); end

  def __callbacks?(); end

  def _enqueue_callbacks(); end

  def _perform_callbacks(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def after_discard_procs(); end

  def after_discard_procs=(after_discard_procs); end

  def after_discard_procs?(); end

  def logger(); end

  def logger=(val); end

  def queue_adapter(&block); end

  def queue_name_prefix(); end

  def queue_name_prefix=(queue_name_prefix); end

  def queue_name_prefix?(); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ActiveJob::Base
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(value); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(value); end

  def self._queue_adapter(); end

  def self._queue_adapter=(value); end

  def self._queue_adapter_name(); end

  def self._queue_adapter_name=(value); end

  def self._test_adapter(); end

  def self._test_adapter=(value); end

  def self.after_discard_procs(); end

  def self.after_discard_procs=(value); end

  def self.after_discard_procs?(); end

  def self.log_arguments(); end

  def self.log_arguments=(value); end

  def self.log_arguments?(); end

  def self.logger(); end

  def self.logger=(val); end

  def self.priority(); end

  def self.priority=(value); end

  def self.priority?(); end

  def self.queue_name(); end

  def self.queue_name=(value); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(value); end

  def self.queue_name_delimiter?(); end

  def self.queue_name_prefix(); end

  def self.queue_name_prefix=(value); end

  def self.queue_name_prefix?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.retry_jitter(); end

  def self.retry_jitter=(value); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Callbacks
  def self.__callbacks(); end

  def self.__callbacks?(); end

  def self._execute_callbacks(); end

  def self._run_execute_callbacks(&block); end
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_all_later(multi_args); end

  def perform_later(*arg, **arg1, &arg2); end

  def perform_now(*arg, **arg1, &arg2); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  def _scheduled_at_time(); end

  def arguments(); end

  def arguments=(arguments); end

  def deserialize(job_data); end

  def enqueue_error(); end

  def enqueue_error=(enqueue_error); end

  def enqueued_at(); end

  def enqueued_at=(enqueued_at); end

  def exception_executions(); end

  def exception_executions=(exception_executions); end

  def executions(); end

  def executions=(executions); end

  def initialize(*arguments, **arg); end

  def job_id(); end

  def job_id=(job_id); end

  def locale(); end

  def locale=(locale); end

  def priority=(priority); end

  def provider_job_id(); end

  def provider_job_id=(provider_job_id); end

  def queue_name=(queue_name); end

  def scheduled_at(); end

  def scheduled_at=(value); end

  def serialize(); end

  def serialized_arguments=(serialized_arguments); end

  def set(options=T.unsafe(nil)); end

  def successfully_enqueued=(successfully_enqueued); end

  def successfully_enqueued?(); end

  def timezone(); end

  def timezone=(timezone); end
end

class ActiveJob::DeserializationError
  def initialize(); end
end

module ActiveJob::Enqueuing
  def enqueue(options=T.unsafe(nil)); end
end

module ActiveJob::Exceptions
  def retry_job(options=T.unsafe(nil)); end
end

module ActiveJob::Execution
  def perform(*arg); end

  def perform_now(); end
end

module ActiveJob::Instrumentation
  def perform_now(); end
end

class ActiveJob::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(backtrace_cleaner); end

  def backtrace_cleaner?(); end

  def discard(event); end

  def enqueue(event); end

  def enqueue_all(event); end

  def enqueue_at(event); end

  def enqueue_retry(event); end

  def perform(event); end

  def perform_start(event); end

  def retry_stopped(event); end
end

class ActiveJob::LogSubscriber
  def self.backtrace_cleaner(); end

  def self.backtrace_cleaner=(value); end

  def self.backtrace_cleaner?(); end
end

module ActiveJob::Logging
  def perform_now(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def immediate=(immediate); end

  def initialize(**executor_options); end

  def shutdown(wait: T.unsafe(nil)); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
  def initialize(job); end

  def perform(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  def enqueue(job, queue_name:); end

  def enqueue_at(job, timestamp, queue_name:); end

  def executor(); end

  def immediate(); end

  def immediate=(immediate); end

  def initialize(**options); end

  def shutdown(wait: T.unsafe(nil)); end
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*arg); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::SidekiqAdapter
  def enqueue(job); end

  def enqueue_all(jobs); end

  def enqueue_at(job, timestamp); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter::JobWrapper
  include ::Sidekiq::Job
  include ::Sidekiq::Job::Options
  def perform(job_data); end

  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter::JobWrapper
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def at(); end

  def at=(at); end

  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def queue(); end

  def queue=(queue); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  def self.lookup(name); end
end

module ActiveJob::QueueName
  def queue_name(); end
end

module ActiveJob::QueuePriority
  def priority(); end
end

module ActiveJob::Serializers
  def _additional_serializers(); end

  def _additional_serializers=(val); end
end

class ActiveJob::Serializers::BigDecimalSerializer
  def deserialize(hash); end

  def serialize(big_decimal); end
end

class ActiveJob::Serializers::DateSerializer
  def deserialize(hash); end

  def serialize(date); end
end

class ActiveJob::Serializers::DateTimeSerializer
  def deserialize(hash); end
end

class ActiveJob::Serializers::DurationSerializer
  def deserialize(hash); end

  def serialize(duration); end
end

class ActiveJob::Serializers::ModuleSerializer
  def deserialize(hash); end

  def serialize(constant); end
end

class ActiveJob::Serializers::ObjectSerializer
  def deserialize(json); end

  def serialize(hash); end

  def serialize?(argument); end
end

class ActiveJob::Serializers::ObjectSerializer
  def self.deserialize(*arg, **arg1, &arg2); end

  def self.serialize(*arg, **arg1, &arg2); end

  def self.serialize?(*arg, **arg1, &arg2); end
end

class ActiveJob::Serializers::RangeSerializer
  def deserialize(hash); end

  def serialize(range); end
  KEYS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Serializers::SymbolSerializer
  def deserialize(argument); end

  def serialize(argument); end
end

class ActiveJob::Serializers::TimeObjectSerializer
  def serialize(time); end
  NANO_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveJob::Serializers::TimeSerializer
  def deserialize(hash); end
end

class ActiveJob::Serializers::TimeWithZoneSerializer
  def deserialize(hash); end

  def serialize(time_with_zone); end
  NANO_PRECISION = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Serializers
  def self._additional_serializers(); end

  def self._additional_serializers=(val); end

  def self.add_serializers(*new_serializers); end

  def self.deserialize(argument); end

  def self.serialize(argument); end

  def self.serializers(); end
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper
  include ::ActiveSupport::Testing::Assertions
  def after_teardown(); end

  def assert_enqueued_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), priority: T.unsafe(nil), &block); end

  def assert_no_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_no_performed_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), priority: T.unsafe(nil), &block); end

  def before_setup(); end

  def enqueued_jobs(*arg, **arg1, &arg2); end

  def enqueued_jobs=(arg); end

  def perform_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), at: T.unsafe(nil), &block); end

  def performed_jobs(*arg, **arg1, &arg2); end

  def performed_jobs=(arg); end

  def queue_adapter(); end

  def queue_adapter_for_test(); end
end

module ActiveJob::TestHelper::TestQueueAdapter
end

module ActiveJob::TestHelper::TestQueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::TestHelper
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob
  def self.adapter_name(adapter); end

  def self.perform_all_later(*jobs); end
end

module ActiveModel::API
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

module ActiveModel::AttributeMethods
  FORWARD_PARAMETERS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeRegistration
end

module ActiveModel::AttributeRegistration::ClassMethods
  def _default_attributes(); end

  def attribute(name, type=T.unsafe(nil), default: T.unsafe(nil), **options); end

  def attribute_types(); end
end

class ActiveModel::AttributeRegistration::ClassMethods::PendingAttribute
  def apply_to(attribute); end

  def default(); end

  def default=(default); end

  def type(); end

  def type=(type); end
end

class ActiveModel::AttributeRegistration::ClassMethods::PendingAttribute
end

module ActiveModel::AttributeRegistration::ClassMethods
end

module ActiveModel::AttributeRegistration
  extend ::ActiveSupport::Concern
end

module ActiveModel::Attributes
  def attribute_names(); end

  def attributes(); end

  def freeze(); end

  def initialize(*arg); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, *arg, **arg1, &arg2); end

  def attribute_names(); end
end

module ActiveModel::Attributes::ClassMethods
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveModel::Error
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Errors
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

class ActiveModel::Name
  MISSING_TRANSLATION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Serializer
  REFLECTION_OPTIONS = ::T.let(nil, ::T.untyped)
  SERIALIZABLE_HASH_VALID_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Serializer::Adapter
end

class ActiveModel::Serializer::Adapter::Attributes
  def initialize(serializer, options=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Serializer::Adapter::Attributes
  def self._deprecated_new(*arg, **arg1); end

  def self.new(*args, &block); end
end

class ActiveModel::Serializer::Adapter::Base
  def initialize(serializer, options=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Serializer::Adapter::Base
  def self.inherited(*args, &block); end
end

class ActiveModel::Serializer::Adapter::Json
  def initialize(serializer, options=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Serializer::Adapter::Json
  def self._deprecated_new(*arg, **arg1); end

  def self.new(*args, &block); end
end

class ActiveModel::Serializer::Adapter::JsonApi
  def initialize(serializer, options=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Serializer::Adapter::JsonApi
  def self._deprecated_new(*arg, **arg1); end

  def self.new(*args, &block); end
end

class ActiveModel::Serializer::Adapter::Null
  def initialize(serializer, options=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Serializer::Adapter::Null
  def self._deprecated_new(*arg, **arg1); end

  def self.new(*args, &block); end
end

module ActiveModel::Serializer::Adapter
  def self._deprecated_adapter_class(adapter, &block); end

  def self._deprecated_adapter_map(&block); end

  def self._deprecated_adapters(&block); end

  def self._deprecated_create(*arg, **arg1, &arg2); end

  def self._deprecated_lookup(adapter, &block); end

  def self._deprecated_register(*arg, **arg1, &arg2); end

  def self.adapter_class(*args, &block); end

  def self.adapter_map(*args, &block); end

  def self.adapters(*args, &block); end

  def self.create(*args, &block); end

  def self.lookup(*args, &block); end

  def self.register(*args, &block); end
end

class ActiveModel::Serializer::Association
  def association_options(); end

  def association_options=(_); end

  def belongs_to?(); end

  def collection?(*arg, **arg1, &arg2); end

  def include_data?(*arg, **arg1, &arg2); end

  def initialize(*arg); end

  def key(); end

  def key?(); end

  def lazy_association(); end

  def links(); end

  def meta(); end

  def name(*arg, **arg1, &arg2); end

  def object(*arg, **arg1, &arg2); end

  def polymorphic?(); end

  def reflection(); end

  def reflection=(_); end

  def reflection_options(*arg, **arg1, &arg2); end

  def serializable_hash(adapter_options, adapter_instance); end

  def virtual_value(*arg, **arg1, &arg2); end
end

class ActiveModel::Serializer::Association
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveModel::Serializer::Attribute
end

class ActiveModel::Serializer::Attribute
end

class ActiveModel::Serializer::BelongsToReflection
end

class ActiveModel::Serializer::BelongsToReflection
end

module ActiveModel::Serializer::Caching
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Serializer::Field
  def block(); end

  def block=(_); end

  def excluded?(serializer); end

  def initialize(*arg); end

  def name(); end

  def name=(_); end

  def options(); end

  def options=(_); end

  def value(serializer); end
end

class ActiveModel::Serializer::Field
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveModel::Serializer::HasManyReflection
end

class ActiveModel::Serializer::HasManyReflection
end

class ActiveModel::Serializer::HasOneReflection
end

class ActiveModel::Serializer::HasOneReflection
end

class ActiveModel::Serializer::Link
end

class ActiveModel::Serializer::Link
end

class ActiveModel::Serializer::Null
  def associations(*arg); end

  def attributes(*arg); end

  def serializable_hash(*arg); end
end

class ActiveModel::Serializer::Null
end

class ActiveModel::Serializer::Reflection
  def build_association(parent_serializer, parent_serializer_options, include_slice=T.unsafe(nil)); end

  def collection?(); end

  def foreign_key(); end

  def foreign_key_on(); end

  def include_data(value=T.unsafe(nil)); end

  def include_data?(include_slice); end

  def link(name, value=T.unsafe(nil), &block); end

  def meta(value=T.unsafe(nil), &block); end

  def object(); end

  def object=(object); end

  def scope(); end

  def scope=(scope); end

  def type(); end

  def value(serializer, include_slice); end
end

class ActiveModel::Serializer::Reflection
end

module ActiveModel::Translation
  MISSING_TRANSLATION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::TimeValue
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Integer
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModelSerializers::Adapter
end

class ActiveModelSerializers::Adapter::Attributes
  def initialize(*arg); end

  def serializable_hash(options=T.unsafe(nil)); end
end

class ActiveModelSerializers::Adapter::Attributes
end

class ActiveModelSerializers::Adapter::Base
  def cache_key(); end

  def fragment_cache(cached_hash, non_cached_hash); end

  def initialize(serializer, options=T.unsafe(nil)); end

  def instance_options(); end

  def serializable_hash(_options=T.unsafe(nil)); end

  def serializer(); end
end

class ActiveModelSerializers::Adapter::Base
  def self.cache_key(); end

  def self.default_key_transform(); end

  def self.fragment_cache(cached_hash, non_cached_hash); end

  def self.inherited(subclass); end

  def self.transform(options); end

  def self.transform_key_casing!(value, options); end
end

class ActiveModelSerializers::Adapter::Json
  def meta(); end

  def meta_key(); end

  def serializable_hash(options=T.unsafe(nil)); end
end

class ActiveModelSerializers::Adapter::Json
end

class ActiveModelSerializers::Adapter::JsonApi
  def failure_document(); end

  def fieldset(); end

  def serializable_hash(*arg); end

  def success_document(); end
end

module ActiveModelSerializers::Adapter::JsonApi::Deserialization
end

class ActiveModelSerializers::Adapter::JsonApi::Deserialization::InvalidDocument
end

class ActiveModelSerializers::Adapter::JsonApi::Deserialization::InvalidDocument
end

module ActiveModelSerializers::Adapter::JsonApi::Deserialization
  def self.field_key(field, options); end

  def self.filter_fields(fields, options); end

  def self.parse(document, options=T.unsafe(nil)); end

  def self.parse!(document, options=T.unsafe(nil)); end

  def self.parse_attributes(attributes, options); end

  def self.parse_relationship(assoc_name, assoc_data, options); end

  def self.parse_relationships(relationships, options); end

  def self.transform_keys(hash, options); end

  def self.validate_payload(payload); end
end

module ActiveModelSerializers::Adapter::JsonApi::Error
end

class ActiveModelSerializers::Adapter::JsonApi::Error::UnknownSourceTypeError
end

class ActiveModelSerializers::Adapter::JsonApi::Error::UnknownSourceTypeError
end

module ActiveModelSerializers::Adapter::JsonApi::Error
  def self.attribute_error_objects(attribute_name, attribute_errors); end

  def self.error_source(source_type, attribute_name); end

  def self.resource_errors(error_serializer, options); end
end

module ActiveModelSerializers::Adapter::JsonApi::Jsonapi
end

module ActiveModelSerializers::Adapter::JsonApi::Jsonapi
  def self.add!(hash); end

  def self.include_object?(); end

  def self.object(); end
end

class ActiveModelSerializers::Adapter::JsonApi::Link
  include ::ActiveModelSerializers::SerializationContext::UrlHelpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def as_json(); end

  def href(value); end

  def initialize(serializer, value); end

  def meta(value); end

  def object(); end

  def scope(); end
end

class ActiveModelSerializers::Adapter::JsonApi::Link
  def self._routes(); end
end

class ActiveModelSerializers::Adapter::JsonApi::Meta
  def as_json(); end

  def initialize(serializer); end

  def object(); end

  def scope(); end
end

class ActiveModelSerializers::Adapter::JsonApi::Meta
end

class ActiveModelSerializers::Adapter::JsonApi::PaginationLinks
  def adapter_options(); end

  def as_json(); end

  def collection(); end

  def context(); end

  def initialize(collection, adapter_options); end
  FIRST_PAGE = ::T.let(nil, ::T.untyped)
end

class ActiveModelSerializers::Adapter::JsonApi::PaginationLinks::MissingSerializationContextError
end

class ActiveModelSerializers::Adapter::JsonApi::PaginationLinks::MissingSerializationContextError
end

class ActiveModelSerializers::Adapter::JsonApi::PaginationLinks
end

class ActiveModelSerializers::Adapter::JsonApi::Relationship
  def as_json(); end

  def association(); end

  def initialize(parent_serializer, serializable_resource_options, association); end

  def parent_serializer(); end

  def serializable_resource_options(); end
end

class ActiveModelSerializers::Adapter::JsonApi::Relationship
end

class ActiveModelSerializers::Adapter::JsonApi::ResourceIdentifier
  def as_json(); end

  def id(); end

  def initialize(serializer, options); end

  def type(); end
end

class ActiveModelSerializers::Adapter::JsonApi::ResourceIdentifier
  def self.for_type_with_id(type, id, options); end

  def self.inflect_type(type); end

  def self.raw_type_from_serializer_object(object); end

  def self.type_for(serializer, serializer_type=T.unsafe(nil), transform_options=T.unsafe(nil)); end
end

class ActiveModelSerializers::Adapter::JsonApi
  extend ::ActiveSupport::Autoload
  def self.fragment_cache(cached_hash, non_cached_hash, root=T.unsafe(nil)); end
end

class ActiveModelSerializers::Adapter::Null
  def serializable_hash(*arg); end
end

class ActiveModelSerializers::Adapter::Null
end

class ActiveModelSerializers::Adapter::UnknownAdapterError
end

class ActiveModelSerializers::Adapter::UnknownAdapterError
end

module ActiveModelSerializers::Adapter
  extend ::ActiveSupport::Autoload
  def self.adapter_class(adapter); end

  def self.adapter_map(); end

  def self.adapters(); end

  def self.configured_adapter(); end

  def self.create(resource, options=T.unsafe(nil)); end

  def self.lookup(adapter); end

  def self.new(*args); end

  def self.register(name, klass=T.unsafe(nil)); end

  def self.registered_name(adapter_class); end
end

module ActiveModelSerializers::Deserialization
end

module ActiveModelSerializers::Deserialization
  def self.jsonapi_parse(*args); end

  def self.jsonapi_parse!(*args); end
end

module ActiveModelSerializers::JsonPointer
  POINTERS = ::T.let(nil, ::T.untyped)
end

module ActiveModelSerializers::JsonPointer
  def self.new(pointer_type, value=T.unsafe(nil)); end
end

module ActiveModelSerializers::Logging
  RENDER_EVENT = ::T.let(nil, ::T.untyped)
end

class ActiveModelSerializers::Logging::LogSubscriber
  def render(event); end
end

module ActiveModelSerializers::LookupChain
  BY_NAMESPACE = ::T.let(nil, ::T.untyped)
  BY_PARENT_SERIALIZER = ::T.let(nil, ::T.untyped)
  BY_RESOURCE = ::T.let(nil, ::T.untyped)
  BY_RESOURCE_NAMESPACE = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class ActiveModelSerializers::Model
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::API
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::Model
  include ::ActiveModel::Access
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attributes(); end

  def cache_key(); end

  def id(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def model_name(&block); end

  def param_delimiter=(param_delimiter); end

  def updated_at(); end

  def updated_at=(updated_at); end

  def validation_context(); end
end

module ActiveModelSerializers::Model::DeriveAttributesFromNamesAndFixAccessors
  def attributes(); end
end

module ActiveModelSerializers::Model::DeriveAttributesFromNamesAndFixAccessors
  def self.included(base); end
end

class ActiveModelSerializers::Model
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.attribute_names(); end

  def self.attribute_names=(value); end

  def self.attribute_names?(); end

  def self.attributes(*names); end

  def self.derive_attributes_from_names_and_fix_accessors(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(value); end

  def self.include_root_in_json?(); end

  def self.param_delimiter(); end

  def self.param_delimiter=(value); end

  def self.param_delimiter?(); end
end

class ActiveModelSerializers::SerializableResource
  ADAPTER_OPTION_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveModelSerializers::Test
end

module ActiveModelSerializers::Test::Schema
  def assert_request_response_schema(schema_path=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_request_schema(schema_path=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response_schema(schema_path=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_schema(payload, schema_path=T.unsafe(nil), message=T.unsafe(nil)); end
end

class ActiveModelSerializers::Test::Schema::AssertRequestSchema
  def initialize(*arg); end
end

class ActiveModelSerializers::Test::Schema::AssertRequestSchema
end

class ActiveModelSerializers::Test::Schema::AssertResponseSchema
  def initialize(*arg); end
end

class ActiveModelSerializers::Test::Schema::AssertResponseSchema
end

class ActiveModelSerializers::Test::Schema::AssertSchema
  def action(); end

  def add_schema_to_document_store(); end

  def call(); end

  def controller_path(); end

  def document_store(); end

  def initialize(schema_path, request, response, message, payload=T.unsafe(nil)); end

  def json_schema(); end

  def load_json(json); end

  def load_json_file(path); end

  def message(); end

  def payload(); end

  def request(); end

  def request_params(); end

  def require_json_schema!(); end

  def response(); end

  def response_body(); end

  def schema_data(); end

  def schema_directory(); end

  def schema_full_path(); end

  def schema_path(); end

  def schema_path_default(); end
end

class ActiveModelSerializers::Test::Schema::AssertSchema
end

class ActiveModelSerializers::Test::Schema::InvalidSchemaError
end

class ActiveModelSerializers::Test::Schema::InvalidSchemaError
end

class ActiveModelSerializers::Test::Schema::MissingSchema
end

class ActiveModelSerializers::Test::Schema::MissingSchema
end

module ActiveModelSerializers::Test::Schema
end

module ActiveModelSerializers::Test::Serializer
  def assert_serializer(expectation, message=T.unsafe(nil)); end
end

class ActiveModelSerializers::Test::Serializer::AssertSerializer
  def expectation(); end

  def expectation=(expectation); end

  def matches?(); end

  def message(); end

  def message=(message); end

  def response(); end

  def response=(response); end

  def serializers(); end

  def subscribe(); end

  def unsubscribe(); end
end

class ActiveModelSerializers::Test::Serializer::AssertSerializer
end

module ActiveModelSerializers::Test::Serializer
  extend ::ActiveSupport::Concern
end

module ActiveModelSerializers::Test
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::AssociationRelation
  def initialize(klass, association, **arg); end

  def insert(attributes, **kwargs); end

  def insert!(attributes, **kwargs); end

  def insert_all(attributes, **kwargs); end

  def insert_all!(attributes, **kwargs); end

  def proxy_association(); end

  def upsert(attributes, **kwargs); end

  def upsert_all(attributes, **kwargs); end
end

class ActiveRecord::AsynchronousQueriesTracker
  def current_session(); end

  def finalize_session(); end

  def start_session(); end
end

module ActiveRecord::AsynchronousQueriesTracker::NullSession
  def self.active?(); end

  def self.finalize(); end
end

class ActiveRecord::AsynchronousQueriesTracker::Session
  def active?(); end

  def finalize(); end
end

class ActiveRecord::AsynchronousQueriesTracker
  def self.complete(asynchronous_queries_tracker); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

class ActiveRecord::Base
  include ::GlobalID::Identification
  include ::ActiveStorage::Attached::Model
  include ::ActiveStorage::Reflection::ActiveRecordExtensions
  include ::ActionText::Attribute
  include ::Turbo::Broadcastable
  include ::ActionText::Encryption
  def attachment_reflections(); end

  def attachment_reflections?(); end

  def suppressed_turbo_broadcasts?(&block); end
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::Base
  extend ::Geocoder::Model::ActiveRecord
  extend ::Geocoder::Model::Base
  extend ::ActiveRecord::Import::Connection
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._counter_cache_columns(); end

  def self._counter_cache_columns=(value); end

  def self._counter_cache_columns?(); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._reflections(); end

  def self._reflections=(value); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(value); end

  def self.aggregate_reflections?(); end

  def self.attachment_reflections(); end

  def self.attachment_reflections=(value); end

  def self.attachment_reflections?(); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(value); end

  def self.attribute_aliases?(); end

  def self.attribute_method_patterns(); end

  def self.attribute_method_patterns=(value); end

  def self.attribute_method_patterns?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(value); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.automatic_scope_inversing(); end

  def self.automatic_scope_inversing=(value); end

  def self.automatic_scope_inversing?(); end

  def self.bulk_import(*args); end

  def self.bulk_import!(*args); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(value); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(value); end

  def self.cache_versioning?(); end

  def self.collection_cache_versioning(); end

  def self.collection_cache_versioning=(value); end

  def self.collection_cache_versioning?(); end

  def self.default_column_serializer(); end

  def self.default_column_serializer=(value); end

  def self.default_column_serializer?(); end

  def self.encrypted_attributes(); end

  def self.encrypted_attributes=(value); end

  def self.encrypted_attributes?(); end

  def self.generated_token_verifier(); end

  def self.generated_token_verifier=(value); end

  def self.import(*args); end

  def self.import!(*args); end

  def self.import_helper(*args); end

  def self.import_with_validations(column_names, array_of_attributes, options=T.unsafe(nil)); end

  def self.import_without_validations_or_callbacks(column_names, array_of_attributes, options=T.unsafe(nil)); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(value); end

  def self.include_root_in_json?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(value); end

  def self.lock_optimistically?(); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(value); end

  def self.nested_attributes_options?(); end

  def self.normalized_attributes(); end

  def self.normalized_attributes=(value); end

  def self.normalized_attributes?(); end

  def self.param_delimiter(); end

  def self.param_delimiter=(value); end

  def self.param_delimiter?(); end

  def self.partial_inserts(); end

  def self.partial_inserts=(value); end

  def self.partial_inserts?(); end

  def self.partial_updates(); end

  def self.partial_updates=(value); end

  def self.partial_updates?(); end

  def self.record_timestamps(); end

  def self.record_timestamps=(value); end

  def self.record_timestamps?(); end

  def self.signed_id_verifier_secret(); end

  def self.signed_id_verifier_secret=(value); end

  def self.signed_id_verifier_secret?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(value); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.supports_import?(*args); end

  def self.supports_on_duplicate_key_update?(); end

  def self.supports_setting_primary_key_of_imported_objects?(); end

  def self.suppressed_turbo_broadcasts(); end

  def self.suppressed_turbo_broadcasts=(obj); end

  def self.synchronize(instances, keys=T.unsafe(nil)); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(value); end

  def self.time_zone_aware_attributes?(); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(value); end

  def self.time_zone_aware_types?(); end

  def self.token_definitions(); end

  def self.token_definitions=(value); end
end

module ActiveRecord::Batches
  DEFAULT_ORDER = ::T.let(nil, ::T.untyped)
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  EXTENDED_TYPE_MAPS = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
  TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def column(); end

  def column=(_); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_check_constraint(expression, options); end

  def add_column(name, type, **options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def check_constraint_adds(); end

  def check_constraint_drops(); end

  def drop_check_constraint(constraint_name); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::BoundSchemaReflection
  def add(name); end

  def cached?(table_name); end

  def clear!(); end

  def clear_data_source_cache!(name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def columns_hash?(table_name); end

  def data_source_exists?(name); end

  def data_sources(name); end

  def database_version(); end

  def dump_to(filename); end

  def indexes(table_name); end

  def initialize(abstract_schema_reflection, connection); end

  def load!(); end

  def primary_keys(table_name); end

  def size(); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefaultDefinition
  def column(); end

  def column=(_); end

  def default(); end

  def default=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefaultDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def column(); end

  def column=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition
  def defined_for?(name:, expression: T.unsafe(nil), validate: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def expression(); end

  def expression=(_); end

  def name(); end

  def options(); end

  def options=(_); end

  def table_name(); end

  def table_name=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::Column
  def ==(other); end

  def auto_incremented_by_db?(); end

  def auto_populated?(); end

  def bigint?(); end

  def collation(); end

  def comment(); end

  def default(); end

  def default_function(); end

  def encode_with(coder); end

  def eql?(other); end

  def has_default?(); end

  def human_name(); end

  def init_with(coder); end

  def initialize(name, default, sql_type_metadata=T.unsafe(nil), null=T.unsafe(nil), default_function=T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), **arg); end

  def limit(*arg, **arg1, &arg2); end

  def name(); end

  def null(); end

  def precision(*arg, **arg1, &arg2); end

  def scale(*arg, **arg1, &arg2); end

  def sql_type(*arg, **arg1, &arg2); end

  def sql_type_metadata(); end

  def type(*arg, **arg1, &arg2); end

  def virtual?(); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def aliased_types(name, fallback); end

  def collation(); end

  def collation=(value); end

  def comment(); end

  def comment=(value); end

  def default(); end

  def default=(value); end

  def if_exists(); end

  def if_exists=(value); end

  def if_not_exists(); end

  def if_not_exists=(value); end

  def limit(); end

  def limit=(value); end

  def name(); end

  def name=(_); end

  def null(); end

  def null=(value); end

  def options(); end

  def options=(_); end

  def precision(); end

  def precision=(value); end

  def primary_key?(); end

  def scale(); end

  def scale=(value); end

  def sql_type(); end

  def sql_type=(_); end

  def type(); end

  def type=(_); end
  OPTION_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  def active_connection?(); end

  def async_executor(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(checkout_timeout=T.unsafe(nil)); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connection_class(); end

  def connection_klass(*args, **arg, &block); end

  def connections(); end

  def db_config(); end

  def discard!(); end

  def discarded?(); end

  def disconnect(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def disconnect!(); end

  def flush(minimum_idle=T.unsafe(nil)); end

  def flush!(); end

  def initialize(pool_config); end

  def lock_thread=(lock_thread); end

  def num_waiting_in_queue(); end

  def pool_config(); end

  def reap(); end

  def reaper(); end

  def release_connection(owner_thread=T.unsafe(nil)); end

  def remove(conn); end

  def role(); end

  def schedule_query(future_result); end

  def schema_reflection(*arg, **arg1, &arg2); end

  def schema_reflection=(arg); end

  def shard(); end

  def size(); end

  def stat(); end

  def with_connection(); end
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  def broadcast(); end

  def broadcast_on_biased(); end

  def initialize(lock, other_cond, preferred_thread); end

  def signal(); end

  def wait(timeout); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def self.register_pool(pool, frequency); end
end

class ActiveRecord::ConnectionAdapters::CreateIndexDefinition
  def algorithm(); end

  def algorithm=(_); end

  def if_not_exists(); end

  def if_not_exists=(_); end

  def index(); end

  def index=(_); end
end

class ActiveRecord::ConnectionAdapters::CreateIndexDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def deferrable(); end

  def defined_for?(to_table: T.unsafe(nil), validate: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def from_table(); end

  def from_table=(_); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def options(); end

  def options=(_); end

  def primary_key(); end

  def to_table(); end

  def to_table=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
  def column_options(); end

  def columns(); end

  def comment(); end

  def defined_for?(columns=T.unsafe(nil), name: T.unsafe(nil), unique: T.unsafe(nil), valid: T.unsafe(nil), include: T.unsafe(nil), nulls_not_distinct: T.unsafe(nil), **options); end

  def include(); end

  def initialize(table, name, unique=T.unsafe(nil), columns=T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), include: T.unsafe(nil), nulls_not_distinct: T.unsafe(nil), comment: T.unsafe(nil), valid: T.unsafe(nil)); end

  def lengths(); end

  def name(); end

  def nulls_not_distinct(); end

  def opclasses(); end

  def orders(); end

  def table(); end

  def type(); end

  def unique(); end

  def using(); end

  def valid(); end

  def valid?(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::NullColumn
  def initialize(name, **arg); end
end

class ActiveRecord::ConnectionAdapters::NullPool
  def async_executor(); end

  def checkin(_); end

  def connection_class(); end

  def db_config(); end

  def remove(_); end

  def schema_reflection(); end
  NULL_CONFIG = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::NullPool::NullConfig
  def method_missing(*arg); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record, _=T.unsafe(nil)); end

  def closed?(); end

  def dirty!(); end

  def dirty?(); end

  def invalidate!(); end

  def invalidated?(); end

  def joinable?(); end

  def open?(); end

  def restartable?(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::PoolConfig
  def connection_class(); end

  def connection_class=(connection_class); end

  def connection_name(); end

  def db_config(); end

  def discard_pool!(); end

  def disconnect!(automatic_reconnect: T.unsafe(nil)); end

  def initialize(connection_class, db_config, role, shard); end

  def lock(); end

  def locked?(); end

  def pool(); end

  def role(); end

  def schema_reflection(); end

  def schema_reflection=(schema_reflection); end

  def shard(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActiveRecord::ConnectionAdapters::PoolConfig
  def self.discard_pools!(); end

  def self.disconnect_all!(); end
end

class ActiveRecord::ConnectionAdapters::PoolManager
  def each_pool_config(role=T.unsafe(nil), &block); end

  def get_pool_config(role, shard); end

  def pool_configs(role=T.unsafe(nil)); end

  def remove_pool_config(role, shard); end

  def remove_role(role); end

  def role_names(); end

  def set_pool_config(role, shard, pool_config); end

  def shard_names(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
  def add_exclusion_constraint(expression, options); end

  def add_unique_constraint(column_name, options); end

  def constraint_validations(); end

  def drop_exclusion_constraint(constraint_name); end

  def drop_unique_constraint(unique_constraint_name); end

  def exclusion_constraint_adds(); end

  def exclusion_constraint_drops(); end

  def unique_constraint_adds(); end

  def unique_constraint_drops(); end

  def validate_constraint(name); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column
  def array(); end

  def array?(); end

  def enum?(); end

  def fmod(*arg, **arg1, &arg2); end

  def identity?(); end

  def initialize(*arg, serial: T.unsafe(nil), identity: T.unsafe(nil), generated: T.unsafe(nil), **arg1); end

  def oid(*arg, **arg1, &arg2); end

  def serial?(); end

  def sql_type(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def primary_key(name, type=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def build_explain_clause(options=T.unsafe(nil)); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil), returning: T.unsafe(nil)); end

  def exec_restart_db_transaction(); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(*arg, **arg1, &arg2); end

  def explain(arel, binds=T.unsafe(nil), options=T.unsafe(nil)); end

  def high_precision_current_timestamp(); end

  def internal_exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil), async: T.unsafe(nil), allow_retry: T.unsafe(nil), materialize_transactions: T.unsafe(nil)); end

  def query(sql, name=T.unsafe(nil)); end

  def raw_execute(sql, name, async: T.unsafe(nil), allow_retry: T.unsafe(nil), materialize_transactions: T.unsafe(nil)); end

  def write_query?(sql); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExclusionConstraintDefinition
  def deferrable(); end

  def export_name_on_schema_dump?(); end

  def expression(); end

  def expression=(_); end

  def name(); end

  def options(); end

  def options=(_); end

  def table_name(); end

  def table_name=(_); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExclusionConstraintDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
  def pp(result); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
  def ==(o); end

  def eql?(o); end

  def identifier(); end

  def initialize(schema, identifier); end

  def parts(); end

  def quoted(); end

  def schema(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
  def delimiter(); end

  def force_equality?(value); end

  def initialize(subtype, delimiter=T.unsafe(nil)); end

  def limit(*arg, **arg1, &arg2); end

  def map(value, &block); end

  def precision(*arg, **arg1, &arg2); end

  def scale(*arg, **arg1, &arg2); end

  def subtype(); end

  def type(*arg, **arg1, &arg2); end

  def user_input_in_time_zone(*arg, **arg1, &arg2); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def encoder(); end

  def encoder=(_); end

  def values=(_); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
  def binary?(); end

  def hex?(); end

  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
  def real_type_unless_aliased(real_type); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
  def infinity(options=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
  def accessor(); end
  ERROR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
  def force_equality?(value); end

  def initialize(subtype, type=T.unsafe(nil)); end

  def subtype(); end

  def user_input_in_time_zone(*arg, **arg1, &arg2); end
  INFINITE_FLOAT_RANGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
  def initialize(type, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
  def initialize(store); end

  def query_conditions_for_array_types(); end

  def query_conditions_for_known_type_names(); end

  def query_conditions_for_known_type_types(); end

  def run(records); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
  ACCEPTABLE_UUID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
  def delim(); end

  def initialize(delim, subtype); end

  def subtype(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
  def initialize(value); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  def check_int_in_range(value); end

  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def escape_bytea(value); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_column_name(name); end

  def quote_default_expression(value, column); end

  def quote_schema_name(name); end

  def quote_string(s); end

  def quote_table_name(name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def type_cast(value); end

  def unescape_bytea(value); end
  QUOTED_COLUMN_NAMES = ::T.let(nil, ::T.untyped)
  QUOTED_TABLE_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::IntegerOutOf64BitRange
  def initialize(msg); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  def check_all_foreign_keys_valid!(); end

  def disable_referential_integrity(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
  def quoted_include_columns_for_index(*arg, **arg1, &arg2); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  def add_column(table_name, column_name, type, **options); end

  def add_exclusion_constraint(table_name, expression, **options); end

  def add_foreign_key(from_table, to_table, **options); end

  def add_index(table_name, column_name, **options); end

  def add_index_options(table_name, column_name, **options); end

  def add_unique_constraint(table_name, column_name=T.unsafe(nil), **options); end

  def build_change_column_default_definition(table_name, column_name, default_or_changes); end

  def build_change_column_definition(table_name, column_name, type, **options); end

  def build_create_index_definition(table_name, column_name, **options); end

  def change_column(table_name, column_name, type, **options); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table_comment(table_name, comment_or_changes); end

  def check_constraints(table_name); end

  def client_min_messages(); end

  def client_min_messages=(level); end

  def collation(); end

  def columns_for_distinct(columns, orders); end

  def create_database(name, options=T.unsafe(nil)); end

  def create_schema(schema_name); end

  def create_schema_dumper(options); end

  def ctype(); end

  def current_database(); end

  def current_schema(); end

  def default_sequence_name(table_name, pk=T.unsafe(nil)); end

  def drop_database(name); end

  def drop_schema(schema_name, **options); end

  def drop_table(table_name, **options); end

  def encoding(); end

  def exclusion_constraint_options(table_name, expression, options); end

  def exclusion_constraints(table_name); end

  def foreign_key_column_for(table_name, column_name); end

  def foreign_keys(table_name); end

  def foreign_table_exists?(table_name); end

  def foreign_tables(); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def pk_and_sequence_for(table); end

  def primary_keys(table_name); end

  def quoted_include_columns_for_index(column_names); end

  def recreate_database(name, options=T.unsafe(nil)); end

  def remove_exclusion_constraint(table_name, expression=T.unsafe(nil), **options); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end

  def remove_unique_constraint(table_name, column_name=T.unsafe(nil), **options); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name, **options); end

  def reset_pk_sequence!(table, pk=T.unsafe(nil), sequence=T.unsafe(nil)); end

  def schema_creation(); end

  def schema_exists?(name); end

  def schema_names(); end

  def schema_search_path(); end

  def schema_search_path=(schema_csv); end

  def serial_sequence(table, column); end

  def set_pk_sequence!(table, value); end

  def table_comment(table_name); end

  def table_options(table_name); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), array: T.unsafe(nil), enum_type: T.unsafe(nil), **arg); end

  def unique_constraint_options(table_name, column_name, options); end

  def unique_constraints(table_name); end

  def update_table_definition(table_name, base); end

  def validate_check_constraint(table_name, **options); end

  def validate_constraint(table_name, constraint_name); end

  def validate_foreign_key(from_table, to_table=T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def enum(*names, **options); end

  def exclusion_constraint(*args); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def remove_exclusion_constraint(*args); end

  def remove_unique_constraint(*args); end

  def serial(*names, **options); end

  def timestamptz(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def unique_constraint(*args); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def enum(*names, **options); end

  def exclusion_constraint(expression, **options); end

  def exclusion_constraints(); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def initialize(*arg, **arg1); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def new_exclusion_constraint_definition(expression, options); end

  def new_unique_constraint_definition(column_name, options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def timestamptz(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def unique_constraint(column_name, **options); end

  def unique_constraints(); end

  def unlogged(); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  def ==(other); end

  def eql?(other); end

  def fmod(); end

  def hash(); end

  def initialize(type_metadata, oid: T.unsafe(nil), fmod: T.unsafe(nil)); end

  def oid(); end

  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::UniqueConstraintDefinition
  def column(); end

  def column=(_); end

  def deferrable(); end

  def defined_for?(name: T.unsafe(nil), column: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def name(); end

  def options(); end

  def options=(_); end

  def table_name(); end

  def table_name=(_); end

  def using_index(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::UniqueConstraintDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  def extract_schema_qualified_name(string); end

  def unquote_identifier(identifier); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  def add_enum_value(type_name, value, options=T.unsafe(nil)); end

  def create_enum(name, values, **options); end

  def create_unlogged_tables(); end

  def create_unlogged_tables=(create_unlogged_tables); end

  def create_unlogged_tables?(); end

  def datetime_type(); end

  def datetime_type=(datetime_type); end

  def datetime_type?(); end

  def disable_extension(name, force: T.unsafe(nil)); end

  def drop_enum(name, values=T.unsafe(nil), **options); end

  def enum_types(); end

  def extension_available?(name); end

  def extension_enabled?(name); end

  def initialize(*arg, **arg1, &arg2); end

  def postgresql_version(); end

  def reload_type_map(); end

  def rename_enum(name, options=T.unsafe(nil)); end

  def rename_enum_value(type_name, options=T.unsafe(nil)); end

  def session_auth=(user); end

  def set_standard_conforming_strings(); end

  def supports_identity_columns?(); end

  def supports_insert_on_conflict?(); end

  def supports_pgcrypto_uuid?(); end

  def use_insert_returning?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  DEADLOCK_DETECTED = ::T.let(nil, ::T.untyped)
  DUPLICATE_DATABASE = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_VIOLATION = ::T.let(nil, ::T.untyped)
  LOCK_NOT_AVAILABLE = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  NOT_NULL_VIOLATION = ::T.let(nil, ::T.untyped)
  NUMERIC_VALUE_OUT_OF_RANGE = ::T.let(nil, ::T.untyped)
  QUERY_CANCELED = ::T.let(nil, ::T.untyped)
  SERIALIZATION_FAILURE = ::T.let(nil, ::T.untyped)
  UNIQUE_VIOLATION = ::T.let(nil, ::T.untyped)
  VALUE_LIMIT_VIOLATION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::MoneyDecoder
  def decode(value, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
  TYPE = ::T.let(nil, ::T.untyped)
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
  def initialize(connection, max); end

  def next_key(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  def self.create_unlogged_tables(); end

  def self.create_unlogged_tables=(value); end

  def self.create_unlogged_tables?(); end

  def self.datetime_type(); end

  def self.datetime_type=(value); end

  def self.datetime_type?(); end

  def self.native_database_types(); end

  def self.new_client(conn_params); end
end

ActiveRecord::ConnectionAdapters::PostgreSQLColumn = ActiveRecord::ConnectionAdapters::PostgreSQL::Column

ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::RealTransaction
  def commit(); end

  def restart(); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def add(table_name, connection); end

  def add_to(table); end

  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::RestartParentTransaction
  def commit(); end

  def initialize(connection, parent_transaction, **options); end

  def materialize!(*arg, **arg1, &arg2); end

  def materialized?(*arg, **arg1, &arg2); end

  def restart(*arg, **arg1, &arg2); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def commit(); end

  def initialize(connection, savepoint_name, parent_transaction, **options); end

  def restart(); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(connection, table_name); end

  def add_all(connection); end

  def cached?(table_name); end

  def clear_data_source_cache!(_connection, name); end

  def columns(connection, table_name); end

  def columns_hash(connection, table_name); end

  def columns_hash?(connection, table_name); end

  def data_source_exists?(connection, name); end

  def data_sources(*args, **arg, &block); end

  def database_version(connection); end

  def dump_to(filename); end

  def encode_with(coder); end

  def indexes(connection, table_name); end

  def init_with(coder); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(connection, table_name); end

  def schema_version(); end

  def size(); end

  def version(connection); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def self._load_from(filename); end

  def self.load_from(*args, **arg, &block); end

  def self.new(*args, **arg, &block); end
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  DEFAULT_DATETIME_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::SchemaReflection
  def add(connection, name); end

  def cached?(table_name); end

  def clear!(); end

  def clear_data_source_cache!(connection, name); end

  def columns(connection, table_name); end

  def columns_hash(connection, table_name); end

  def columns_hash?(connection, table_name); end

  def data_source_exists?(connection, name); end

  def data_sources(connection, name); end

  def database_version(connection); end

  def dump_to(connection, filename); end

  def indexes(connection, table_name); end

  def initialize(cache_path, cache=T.unsafe(nil)); end

  def load!(connection); end

  def primary_keys(connection, table_name); end

  def set_schema_cache(cache); end

  def size(connection); end

  def version(connection); end
end

class ActiveRecord::ConnectionAdapters::SchemaReflection
  def self.check_schema_cache_dump_version(); end

  def self.check_schema_cache_dump_version=(check_schema_cache_dump_version); end

  def self.use_schema_cache_dump(); end

  def self.use_schema_cache_dump=(use_schema_cache_dump); end
end

class ActiveRecord::ConnectionAdapters::StatementPool
  def [](key); end

  def []=(sql, stmt); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def initialize(statement_limit=T.unsafe(nil)); end

  def key?(key); end

  def length(); end

  def reset(); end
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::Table
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def blob(*names, **options); end

  def boolean(*names, **options); end

  def change_null(column_name, null, default=T.unsafe(nil)); end

  def check_constraint(*args, **options); end

  def check_constraint_exists?(*args, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def initialize(table_name, base); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def numeric(*names, **options); end

  def remove_check_constraint(*args, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  def as(); end

  def bigint(*names, **options); end

  def binary(*names, **options); end

  def blob(*names, **options); end

  def boolean(*names, **options); end

  def check_constraint(expression, **options); end

  def check_constraints(); end

  def comment(); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def foreign_key(to_table, **options); end

  def foreign_keys(); end

  def if_not_exists(); end

  def indexes(); end

  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **arg); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def new_check_constraint_definition(expression, options); end

  def new_column_definition(name, type, **options); end

  def new_foreign_key_definition(to_table, options); end

  def numeric(*names, **options); end

  def options(); end

  def primary_keys(name=T.unsafe(nil)); end

  def set_primary_key(table_name, id, primary_key, **options); end

  def string(*names, **options); end

  def temporary(); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record, ensure_finalize=T.unsafe(nil)); end

  def before_commit_records(); end

  def closed?(); end

  def commit_records(); end

  def connection(); end

  def dirty!(); end

  def dirty?(); end

  def full_rollback?(); end

  def incomplete!(); end

  def initialize(connection, isolation: T.unsafe(nil), joinable: T.unsafe(nil), run_commit_callbacks: T.unsafe(nil)); end

  def invalidate!(*arg, **arg1, &arg2); end

  def invalidated?(*arg, **arg1, &arg2); end

  def isolation_level(); end

  def joinable?(); end

  def materialize!(); end

  def materialized?(); end

  def open?(); end

  def records(); end

  def restartable?(); end

  def restore!(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end

  def written(); end

  def written=(written); end
end

class ActiveRecord::ConnectionAdapters::TransactionInstrumenter
  def finish(outcome); end

  def initialize(payload=T.unsafe(nil)); end

  def start(); end
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil), _lazy: T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def dirty_current_transaction(); end

  def disable_lazy_transactions!(); end

  def enable_lazy_transactions!(); end

  def initialize(connection); end

  def lazy_transactions_enabled?(); end

  def materialize_transactions(); end

  def open_transactions(); end

  def restorable?(); end

  def restore_transactions(); end

  def rollback_transaction(transaction=T.unsafe(nil)); end

  def within_new_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def add_child(state); end

  def commit!(); end

  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def full_commit!(); end

  def full_rollback!(); end

  def fully_committed?(); end

  def fully_completed?(); end

  def fully_rolledback?(); end

  def initialize(state=T.unsafe(nil)); end

  def invalidate!(); end

  def invalidated?(); end

  def nullify!(); end

  def rollback!(); end

  def rolledback?(); end
end

module ActiveRecord::ConnectionHandling
  def postgresql_adapter_class(); end

  def postgresql_connection(config); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::DestroyAssociationAsyncJob
  def perform(owner_model_name: T.unsafe(nil), owner_id: T.unsafe(nil), association_class: T.unsafe(nil), association_ids: T.unsafe(nil), association_primary_key_column: T.unsafe(nil), ensuring_owner_was_method: T.unsafe(nil)); end
end

class ActiveRecord::DestroyAssociationAsyncJob
end

class ActiveRecord::DisableJoinsAssociationRelation
  def initialize(klass, key, ids); end

  def key(); end

  def load(); end
end

class ActiveRecord::Encryption::AutoFilteredParameters
  def enable(); end

  def initialize(app); end
end

class ActiveRecord::Encryption::Cipher
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Cipher::Aes256Gcm
  def decrypt(encrypted_message); end

  def encrypt(clear_text); end

  def initialize(secret, deterministic: T.unsafe(nil)); end
  CIPHER_TYPE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Cipher::Aes256Gcm
  def self.iv_length(); end

  def self.key_length(); end
end

class ActiveRecord::Encryption::Context
  PROPERTIES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::DerivedSecretKeyProvider
  def initialize(passwords, key_generator: T.unsafe(nil)); end
end

class ActiveRecord::Encryption::DerivedSecretKeyProvider
end

class ActiveRecord::Encryption::DeterministicKeyProvider
  def initialize(password); end
end

class ActiveRecord::Encryption::DeterministicKeyProvider
end

module ActiveRecord::Encryption::EncryptableRecord
  ORIGINAL_ATTRIBUTE_PREFIX = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::EncryptedAttributeType
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(*arg, **arg1, &arg2); end

  def cast_type(); end

  def deterministic?(*arg, **arg1, &arg2); end

  def downcase?(*arg, **arg1, &arg2); end

  def encrypted?(value); end

  def fixed?(*arg, **arg1, &arg2); end

  def initialize(scheme:, cast_type: T.unsafe(nil), previous_type: T.unsafe(nil), default: T.unsafe(nil)); end

  def key_provider(*arg, **arg1, &arg2); end

  def previous_schemes(*arg, **arg1, &arg2); end

  def previous_types(); end

  def scheme(); end

  def support_unencrypted_data?(); end

  def with_context(*arg, **arg1, &arg2); end
end

class ActiveRecord::Encryption::EncryptedAttributeType
end

module ActiveRecord::Encryption::EncryptedFixtures
  def initialize(fixture, model_class); end
end

module ActiveRecord::Encryption::EncryptedFixtures
end

class ActiveRecord::Encryption::EncryptingOnlyEncryptor
end

class ActiveRecord::Encryption::EncryptingOnlyEncryptor
end

class ActiveRecord::Encryption::Encryptor
  DECRYPT_ERRORS = ::T.let(nil, ::T.untyped)
  ENCODING_ERRORS = ::T.let(nil, ::T.untyped)
  THRESHOLD_TO_JUSTIFY_COMPRESSION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::EnvelopeEncryptionKeyProvider
  def active_primary_key(); end

  def decryption_keys(encrypted_message); end

  def encryption_key(); end
end

class ActiveRecord::Encryption::EnvelopeEncryptionKeyProvider
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries
end

class ActiveRecord::Encryption::ExtendedDeterministicQueries::AdditionalValue
  def initialize(value, type); end

  def type(); end

  def value(); end
end

class ActiveRecord::Encryption::ExtendedDeterministicQueries::AdditionalValue
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries::ClassMethods
  def find_by(*args); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries::ClassMethods
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQuery
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQuery
  def self.process_arguments(owner, args, check_for_additional_values); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::ExtendedEncryptableType
  def serialize(data); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::ExtendedEncryptableType
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::RelationQueries
  def exists?(*args); end

  def scope_for_create(); end

  def where(*args); end
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries::RelationQueries
end

module ActiveRecord::Encryption::ExtendedDeterministicQueries
  def self.install_support(); end
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator::EncryptedUniquenessValidator
  def validate_each(record, attribute, value); end
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator::EncryptedUniquenessValidator
end

module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator
  def self.install_support(); end
end

class ActiveRecord::Encryption::Key
  def id(); end

  def initialize(secret); end

  def public_tags(); end

  def secret(); end
end

class ActiveRecord::Encryption::Key
  def self.derive_from(password); end
end

class ActiveRecord::Encryption::KeyProvider
  def decryption_keys(encrypted_message); end

  def encryption_key(); end

  def initialize(keys); end
end

class ActiveRecord::Encryption::KeyProvider
end

class ActiveRecord::Encryption::Message
  def ==(other_message); end

  def headers(); end

  def headers=(headers); end

  def initialize(payload: T.unsafe(nil), headers: T.unsafe(nil)); end

  def payload(); end

  def payload=(payload); end
end

class ActiveRecord::Encryption::Message
end

class ActiveRecord::Encryption::NullEncryptor
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypt(clean_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypted?(text); end
end

class ActiveRecord::Encryption::NullEncryptor
end

class ActiveRecord::Encryption::Properties
  def ==(arg); end

  def [](*arg, **arg1, &arg2); end

  def []=(key, value); end

  def add(other_properties); end

  def auth_tag(); end

  def auth_tag=(value); end

  def compressed(); end

  def compressed=(value); end

  def each(*arg, **arg1, &arg2); end

  def encoding(); end

  def encoding=(value); end

  def encrypted_data_key(); end

  def encrypted_data_key=(value); end

  def encrypted_data_key_id(); end

  def encrypted_data_key_id=(value); end

  def initialize(initial_properties=T.unsafe(nil)); end

  def iv(); end

  def iv=(value); end

  def key?(*arg, **arg1, &arg2); end

  def method_missing(method, *args, **arg, &block); end

  def to_h(); end

  def validate_value_type(value); end
  ALLOWED_VALUE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_PROPERTIES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Encryption::Properties
end

class ActiveRecord::Encryption::ReadOnlyNullEncryptor
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypt(clean_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  def encrypted?(text); end
end

class ActiveRecord::Encryption::ReadOnlyNullEncryptor
end

class ActiveRecord::Encryption::Scheme
  def compatible_with?(other_scheme); end

  def deterministic?(); end

  def downcase?(); end

  def fixed?(); end

  def ignore_case?(); end

  def initialize(key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), support_unencrypted_data: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous_schemes: T.unsafe(nil), **context_properties); end

  def key_provider(); end

  def merge(other_scheme); end

  def previous_schemes(); end

  def previous_schemes=(previous_schemes); end

  def support_unencrypted_data?(); end

  def to_h(); end

  def with_context(&block); end
end

class ActiveRecord::Encryption::Scheme
end

class ActiveRecord::ExplainSubscriber
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::FixtureSet
  def [](x); end

  def []=(k, v); end

  def all_loaded_fixtures(); end

  def all_loaded_fixtures=(val); end

  def config(); end

  def each(&block); end

  def fixtures(); end

  def ignored_fixtures(); end

  def initialize(_, name, class_name, path, config=T.unsafe(nil)); end

  def model_class(); end

  def name(); end

  def size(); end

  def table_name(); end

  def table_rows(); end
  MAX_ID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::FixtureSet::File
  include ::Enumerable
  def each(&block); end

  def ignored_fixtures(); end

  def initialize(file); end

  def model_class(); end
end

class ActiveRecord::FixtureSet::File
  def self.open(file); end
end

class ActiveRecord::FixtureSet::ModelMetadata
  def column_names(); end

  def column_type(column_name); end

  def has_column?(column_name); end

  def inheritance_column_name(); end

  def initialize(model_class); end

  def primary_key_name(); end

  def primary_key_type(); end

  def timestamp_column_names(); end
end

class ActiveRecord::FixtureSet::ModelMetadata
end

class ActiveRecord::FixtureSet::RenderContext
end

class ActiveRecord::FixtureSet::RenderContext
  def self.create_subclass(); end
end

class ActiveRecord::FixtureSet::TableRow
  def initialize(fixture, table_rows:, label:, now:); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy
  def lhs_key(); end

  def rhs_key(); end

  def timestamp_column_names(); end
end

class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy
end

class ActiveRecord::FixtureSet::TableRow::PrimaryKeyError
  def initialize(label, association, value); end
end

class ActiveRecord::FixtureSet::TableRow::PrimaryKeyError
end

class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
  def initialize(association); end

  def join_table(); end

  def name(); end

  def primary_key_type(); end
end

class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
end

class ActiveRecord::FixtureSet::TableRow
end

class ActiveRecord::FixtureSet::TableRows
  def initialize(table_name, model_class:, fixtures:); end

  def model_class(); end

  def model_metadata(); end

  def tables(); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet::TableRows
end

class ActiveRecord::FixtureSet
  extend ::GlobalID::FixtureSet
  def self.all_loaded_fixtures(); end

  def self.all_loaded_fixtures=(val); end

  def self.cache_fixtures(connection, fixtures_map); end

  def self.cache_for_connection(connection); end

  def self.cached_fixtures(connection, keys_to_fetch=T.unsafe(nil)); end

  def self.composite_identify(label, key); end

  def self.context_class(); end

  def self.create_fixtures(fixtures_directories, fixture_set_names, class_names=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.default_fixture_model_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.default_fixture_table_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.fixture_is_cached?(connection, table_name); end

  def self.identify(label, column_type=T.unsafe(nil)); end

  def self.instantiate_all_loaded_fixtures(object, load_instances=T.unsafe(nil)); end

  def self.instantiate_fixtures(object, fixture_set, load_instances=T.unsafe(nil)); end

  def self.reset_cache(); end
end

class ActiveRecord::FutureResult
  def cancel(); end

  def canceled?(); end

  def empty?(*arg, **arg1, &arg2); end

  def execute!(connection); end

  def execute_or_skip(); end

  def initialize(pool, *args, **kwargs); end

  def lock_wait(); end

  def method_missing(method, *args, **arg, &block); end

  def pending?(); end

  def result(); end

  def schedule!(session); end

  def then(&block); end

  def to_a(*arg, **arg1, &arg2); end
end

class ActiveRecord::FutureResult::Complete
  def canceled?(); end

  def empty?(*arg, **arg1, &arg2); end

  def initialize(result); end

  def pending?(); end

  def result(); end

  def then(&block); end

  def to_a(*arg, **arg1, &arg2); end
end

class ActiveRecord::FutureResult::EventBuffer
  def flush(); end

  def initialize(future_result, instrumenter); end

  def instrument(name, payload=T.unsafe(nil), &block); end
end

module ActiveRecord::Import
  ADAPTER_PATH = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Import::PostgreSQLAdapter
  def add_column_for_on_duplicate_key_update(column, options=T.unsafe(nil)); end

  def database_version(); end

  def duplicate_key_update_error?(exception); end

  def insert_many(sql, values, options=T.unsafe(nil), *args); end

  def next_value_for_sequence(sequence_name); end

  def post_sql_statements(table_name, options); end

  def returning_selections(options); end

  def split_ids_and_results(selections, options); end

  def sql_for_conflict_target(args=T.unsafe(nil)); end

  def sql_for_default_conflict_target(table_name, primary_key); end

  def sql_for_on_duplicate_key_ignore(table_name, *args); end

  def sql_for_on_duplicate_key_update(table_name, *args); end

  def sql_for_on_duplicate_key_update_as_array(table_name, model, locking_column, arr); end

  def sql_for_on_duplicate_key_update_as_hash(table_name, model, locking_column, hsh); end

  def supports_on_duplicate_key_update?(); end

  def supports_setting_primary_key_of_imported_objects?(); end
  MIN_VERSION_FOR_UPSERT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::InternalMetadata
  def [](key); end

  def []=(key, value); end

  def arel_table(); end

  def connection(); end

  def count(); end

  def create_table(); end

  def create_table_and_set_flags(environment, schema_sha1=T.unsafe(nil)); end

  def delete_all_entries(); end

  def drop_table(); end

  def enabled?(); end

  def initialize(connection); end

  def primary_key(); end

  def table_exists?(); end

  def table_name(); end

  def value_key(); end
end

class ActiveRecord::InternalMetadata::NullInternalMetadata
end

class ActiveRecord::InternalMetadata::NullInternalMetadata
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(coder); end
end

class ActiveRecord::Locking::LockingType
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(backtrace_cleaner); end

  def backtrace_cleaner?(); end

  def sql(event); end

  def strict_loading_violation(event); end
end

module ActiveRecord::Marshalling::Methods
  def marshal_dump(); end
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def reading_request?(request); end

  def update_context(response); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def save(response); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

class ActiveRecord::Middleware::ShardSelector
  def call(env); end

  def initialize(app, resolver, options=T.unsafe(nil)); end

  def options(); end

  def resolver(); end
end

class ActiveRecord::Middleware::ShardSelector
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, **arg, &block); end

  def add_check_constraint(*args, **arg, &block); end

  def add_column(*args, **arg, &block); end

  def add_enum_value(*args, **arg, &block); end

  def add_exclusion_constraint(*args, **arg, &block); end

  def add_foreign_key(*args, **arg, &block); end

  def add_index(*args, **arg, &block); end

  def add_reference(*args, **arg, &block); end

  def add_timestamps(*args, **arg, &block); end

  def add_unique_constraint(*args, **arg, &block); end

  def change_column(*args, **arg, &block); end

  def change_column_comment(*args, **arg, &block); end

  def change_column_default(*args, **arg, &block); end

  def change_column_null(*args, **arg, &block); end

  def change_table(table_name, **options); end

  def change_table_comment(*args, **arg, &block); end

  def commands(); end

  def commands=(commands); end

  def create_enum(*args, **arg, &block); end

  def create_join_table(*args, **arg, &block); end

  def create_table(*args, **arg, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, **arg, &block); end

  def drop_enum(*args, **arg, &block); end

  def drop_join_table(*args, **arg, &block); end

  def drop_table(*args, **arg, &block); end

  def enable_extension(*args, **arg, &block); end

  def execute(*args, **arg, &block); end

  def execute_block(*args, **arg, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, **arg, &block); end

  def remove_check_constraint(*args, **arg, &block); end

  def remove_column(*args, **arg, &block); end

  def remove_columns(*args, **arg, &block); end

  def remove_exclusion_constraint(*args, **arg, &block); end

  def remove_foreign_key(*args, **arg, &block); end

  def remove_index(*args, **arg, &block); end

  def remove_reference(*args, **arg, &block); end

  def remove_timestamps(*args, **arg, &block); end

  def remove_unique_constraint(*args, **arg, &block); end

  def rename_column(*args, **arg, &block); end

  def rename_enum(*args, **arg, &block); end

  def rename_enum_value(*args, **arg, &block); end

  def rename_index(*args, **arg, &block); end

  def rename_table(*args, **arg, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, **arg, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_check_constraint(args, &block); end

  def invert_add_column(args, &block); end

  def invert_add_exclusion_constraint(args, &block); end

  def invert_add_foreign_key(args, &block); end

  def invert_add_index(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_add_unique_constraint(args, &block); end

  def invert_create_enum(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_enum(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_check_constraint(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_exclusion_constraint(args, &block); end

  def invert_remove_foreign_key(args, &block); end

  def invert_remove_index(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end

  def invert_remove_unique_constraint(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def index_exists?(table_name, column_name, **options); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*arg, **options); end

  def references(*arg, **options); end

  def timestamps(**options); end
end

class ActiveRecord::Migration::Compatibility::V5_0
  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

class ActiveRecord::Migration::Compatibility::V5_2
  def add_timestamps(table_name, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end

  def invert_change_table_comment(args); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def column(name, type, index: T.unsafe(nil), **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V6_0::TableDefinition
  def belongs_to(*args, **options); end

  def column(name, type, index: T.unsafe(nil), **options); end

  def references(*args, **options); end
end

class ActiveRecord::Migration::Compatibility::V6_1::PostgreSQLCompat
  def self.compatible_timestamp_type(type, connection); end
end

module ActiveRecord::Migration::Compatibility::V6_1::TableDefinition
  def change(name, type, index: T.unsafe(nil), **options); end

  def column(name, type, index: T.unsafe(nil), **options); end

  def new_column_definition(name, type, **options); end
end

class ActiveRecord::Migration::Compatibility::V7_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_foreign_key(from_table, to_table, **options); end

  def add_index(table_name, column_name, **options); end

  def add_reference(table_name, ref_name, **options); end

  def change_column(table_name, column_name, type, **options); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def disable_extension(name, **options); end

  def rename_table(table_name, new_name, **options); end
end

module ActiveRecord::Migration::Compatibility::V7_0::TableDefinition
  def change(name, type, **options); end

  def column(name, type, **options); end

  def index(column_name, **options); end
end

ActiveRecord::Migration::Compatibility::V7_1 = ActiveRecord::Migration::Current

module ActiveRecord::Migration::Compatibility
  def self.find(version); end
end

module ActiveRecord::NestedAttributes
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class ActiveRecord::Point
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder
  def [](attr_name, value, operator=T.unsafe(nil)); end

  def build(attribute, value, operator=T.unsafe(nil)); end

  def build_bind_attribute(column_name, value); end

  def build_from_hash(attributes, &block); end

  def expand_from_hash(attributes, &block); end

  def initialize(table); end

  def register_handler(klass, handler); end

  def resolve_arel_attribute(table_name, column_name, &block); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  def initialize(associated_table, value); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  def initialize(associated_table, values); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def begin(); end

  def begin=(_); end

  def end(); end

  def end=(_); end

  def exclude_end?(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder
  def self.references(attributes); end
end

class ActiveRecord::Promise
  def class(); end

  def initialize(future_result, block); end

  def inspect(); end

  def is_a?(arg); end

  def pending?(); end

  def pretty_print(q); end

  def respond_to?(*arg); end

  def then(&block); end

  def value(); end
end

class ActiveRecord::Promise::Complete
  def initialize(value); end

  def then(); end
end

class ActiveRecord::Promise::Complete
end

class ActiveRecord::Promise
end

module ActiveRecord::QueryLogs
end

class ActiveRecord::QueryLogs::LegacyFormatter
  def format(pairs); end
end

class ActiveRecord::QueryLogs::LegacyFormatter
end

class ActiveRecord::QueryLogs::SQLCommenter
end

class ActiveRecord::QueryLogs::SQLCommenter
end

module ActiveRecord::QueryLogs
  def self.cache_query_log_tags(); end

  def self.cache_query_log_tags=(val); end

  def self.cached_comment(); end

  def self.cached_comment=(obj); end

  def self.call(sql, connection); end

  def self.clear_cache(); end

  def self.prepend_comment(); end

  def self.prepend_comment=(val); end

  def self.taggings(); end

  def self.taggings=(val); end

  def self.tags(); end

  def self.tags=(val); end

  def self.tags_formatter(); end

  def self.tags_formatter=(val); end

  def self.update_formatter(format); end
end

module ActiveRecord::QueryMethods
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Querying
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Railtie
  SQLITE3_PRODUCTION_WARN = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end

  def initialize(*arg, **arg1, &arg2); end
end

module ActiveRecord::Reflection
  extend ::ActiveStorage::Reflection::ReflectionExtension
end

class ActiveRecord::Relation
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::Merger
  NORMAL_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::WhereClause
  ARRAY_WITH_EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Result
  def [](idx); end

  def cancel(); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def column_types(); end

  def columns(); end

  def each(&block); end

  def empty?(); end

  def includes_column?(name); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(n=T.unsafe(nil)); end

  def length(); end

  def result(); end

  def rows(); end

  def to_a(); end

  def to_ary(); end
end

class ActiveRecord::Result
  def self.empty(async: T.unsafe(nil)); end
end

module ActiveRecord::RuntimeRegistry
  def async_sql_runtime(); end

  def async_sql_runtime=(runtime); end

  def reset(); end

  def sql_runtime(); end

  def sql_runtime=(runtime); end
end

module ActiveRecord::Schema::Definition
  def define(info, &block); end
end

module ActiveRecord::Schema::Definition::ClassMethods
  def define(info=T.unsafe(nil), &block); end
end

class ActiveRecord::SchemaMigration
  def arel_table(); end

  def connection(); end

  def count(); end

  def create_table(); end

  def create_version(version); end

  def delete_all_versions(); end

  def delete_version(version); end

  def drop_table(); end

  def initialize(connection); end

  def integer_versions(); end

  def normalize_migration_number(number); end

  def normalized_versions(); end

  def primary_key(); end

  def table_exists?(); end

  def table_name(); end

  def versions(); end
end

class ActiveRecord::SchemaMigration::NullSchemaMigration
end

class ActiveRecord::SchemaMigration::NullSchemaMigration
end

class ActiveRecord::SchemaMigration
end

module ActiveRecord::SecureToken
  MINIMUM_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::StatementCache
  def execute(params, connection, &block); end

  def initialize(query_builder, bind_map, klass); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bound_attributes); end
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQueryCollector
  def <<(str); end

  def add_bind(obj); end

  def add_binds(binds, proc_for_binds=T.unsafe(nil)); end

  def preparable(); end

  def preparable=(preparable); end

  def value(); end
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache
  def self.create(connection, callable=T.unsafe(nil), &block); end

  def self.partial_query(values); end

  def self.partial_query_collector(); end

  def self.query(sql); end

  def self.unsupported_value?(value); end
end

class ActiveRecord::TableMetadata
  def aggregated_with?(aggregation_name); end

  def arel_table(); end

  def associated_table(table_name); end

  def associated_with?(table_name); end

  def has_column?(column_name); end

  def initialize(klass, arel_table, reflection=T.unsafe(nil)); end

  def join_foreign_key(*arg, **arg1, &arg2); end

  def join_foreign_type(*arg, **arg1, &arg2); end

  def join_primary_key(*arg, **arg1, &arg2); end

  def join_primary_type(*arg, **arg1, &arg2); end

  def polymorphic_association?(); end

  def polymorphic_name_association(); end

  def predicate_builder(); end

  def primary_key(); end

  def reflect_on_aggregation(aggregation_name); end

  def through_association?(); end

  def type(column_name); end
end

module ActiveRecord::Tasks::DatabaseTasks
  def cache_dump_filename(db_config_name, schema_cache_path: T.unsafe(nil)); end

  def charset(configuration, *arguments); end

  def charset_current(env_name=T.unsafe(nil), db_name=T.unsafe(nil)); end

  def check_protected_environments!(environment=T.unsafe(nil)); end

  def check_schema_file(filename); end

  def check_target_version(); end

  def clear_schema_cache(filename); end

  def collation(configuration, *arguments); end

  def collation_current(env_name=T.unsafe(nil), db_name=T.unsafe(nil)); end

  def create(configuration, *arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil), name=T.unsafe(nil)); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_configs_with_versions(db_configs); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(configuration, *arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def dump_schema(db_config, format=T.unsafe(nil)); end

  def dump_schema_cache(conn, filename); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def for_each(databases); end

  def load_schema(db_config, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(version=T.unsafe(nil)); end

  def migrate_status(); end

  def migration_class(); end

  def migration_connection(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def name(); end

  def prepare_all(); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def raise_for_multi_db(environment=T.unsafe(nil), command:); end

  def reconstruct_from_schema(db_config, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_dump_path(db_config, format=T.unsafe(nil)); end

  def schema_up_to_date?(configuration, format=T.unsafe(nil), file=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def setup_initial_database_yaml(); end

  def structure_dump(configuration, *arguments); end

  def structure_load(configuration, *arguments); end

  def target_version(); end

  def truncate_all(environment=T.unsafe(nil)); end

  def with_temporary_connection(db_config, clobber: T.unsafe(nil)); end

  def with_temporary_connection_for_each(env: T.unsafe(nil), name: T.unsafe(nil), clobber: T.unsafe(nil), &block); end
end

module ActiveRecord::Tasks::DatabaseTasks
  def self.structure_dump_flags(); end

  def self.structure_dump_flags=(val); end

  def self.structure_load_flags(); end

  def self.structure_load_flags=(val); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def create(); end

  def drop(); end

  def initialize(db_config); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def self.using_database_configurations?(); end
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def collation(); end

  def create(connection_already_established=T.unsafe(nil)); end

  def drop(); end

  def initialize(db_config); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def self.using_database_configurations?(); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def create(); end

  def drop(); end

  def initialize(db_config, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def self.using_database_configurations?(); end
end

module ActiveRecord::TestDatabases
end

module ActiveRecord::TestDatabases
  def self.create_and_load_schema(i, env_name:); end
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def fixture_path(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

module ActiveRecord::TestFixtures::ClassMethods
  def fixture_path(); end

  def fixture_path=(path); end

  def fixtures(*fixture_set_names); end

  def set_fixture_class(class_names=T.unsafe(nil)); end

  def setup_fixture_accessors(fixture_set_names=T.unsafe(nil)); end

  def uses_transaction(*methods); end

  def uses_transaction?(method); end
end

module ActiveRecord::TestFixtures::ClassMethods
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Transactions
  ACTIONS = ::T.let(nil, ::T.untyped)
end

ActiveRecord::Type::ImmutableString = ActiveModel::Type::ImmutableString

class ActiveRecord::Type::Serialized
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Type::Time::Value
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::AnalyzeJob
  def perform(blob); end
end

class ActiveStorage::Analyzer::ImageAnalyzer::Vips
  ROTATIONS = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Attached
  def initialize(name, record); end

  def name(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::CreateMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record, attachables, pending_uploads: T.unsafe(nil)); end

  def name(); end

  def pending_uploads(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateOne
  def attachable(); end

  def attachment(); end

  def blob(); end

  def initialize(name, record, attachable); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::DeleteMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteOne
  def attachment(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DetachMany
  def attachments(); end

  def detach(); end

  def initialize(name, record, attachments); end

  def name(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::DetachMany
end

class ActiveStorage::Attached::Changes::DetachOne
  def attachment(); end

  def detach(); end

  def initialize(name, record, attachment); end

  def name(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::DetachOne
end

class ActiveStorage::Attached::Changes::PurgeMany
  def attachments(); end

  def initialize(name, record, attachments); end

  def name(); end

  def purge(); end

  def purge_later(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::PurgeMany
end

class ActiveStorage::Attached::Changes::PurgeOne
  def attachment(); end

  def initialize(name, record, attachment); end

  def name(); end

  def purge(); end

  def purge_later(); end

  def record(); end
end

class ActiveStorage::Attached::Changes::PurgeOne
end

class ActiveStorage::Attached::Many
  def method_missing(method, *args, **arg, &block); end
end

module ActiveStorage::Attached::Model
  def attachment_changes(); end

  def changed_for_autosave?(); end

  def reload(*arg); end
end

class ActiveStorage::Attached::One
  def method_missing(method, *args, **arg, &block); end
end

class ActiveStorage::Attachment
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_record(*args); end

  def preview(transformations); end

  def purge(); end

  def purge_later(); end

  def representation(transformations); end

  def signed_id(*arg, **arg1, &arg2); end

  def validate_associated_records_for_blob(*args); end

  def variant(transformations); end
end

module ActiveStorage::Attachment::GeneratedAssociationMethods
  def blob(); end

  def blob=(value); end

  def blob_changed?(); end

  def blob_previously_changed?(); end

  def build_blob(*args, &block); end

  def create_blob(*args, &block); end

  def create_blob!(*args, &block); end

  def record(); end

  def record=(value); end

  def record_changed?(); end

  def record_previously_changed?(); end

  def reload_blob(); end

  def reload_record(); end

  def reset_blob(); end

  def reset_record(); end
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveStorage::Attachment
  def self.with_all_variant_records(*args, **arg); end
end

class ActiveStorage::Blob
  def attachable_plain_text_representation(caption=T.unsafe(nil)); end

  def audio?(); end

  def autosave_associated_records_for_attachments(*args); end

  def autosave_associated_records_for_preview_image_attachment(*args); end

  def autosave_associated_records_for_preview_image_blob(*args); end

  def autosave_associated_records_for_variant_records(*args); end

  def compose(keys); end

  def custom_metadata(); end

  def custom_metadata=(metadata); end

  def download(&block); end

  def download_chunk(range); end

  def filename(); end

  def image?(); end

  def key(); end

  def mirror_later(); end

  def open(tmpdir: T.unsafe(nil), &block); end

  def original_key(); end

  def purge(); end

  def purge_later(); end

  def regenerate_key(); end

  def service(); end

  def service_headers_for_direct_upload(); end

  def service_url_for_direct_upload(expires_in: T.unsafe(nil)); end

  def services(); end

  def services=(services); end

  def services?(); end

  def signed_id(purpose: T.unsafe(nil), expires_in: T.unsafe(nil), expires_at: T.unsafe(nil)); end

  def text?(); end

  def unfurl(io, identify: T.unsafe(nil)); end

  def upload(io, identify: T.unsafe(nil)); end

  def upload_without_unfurling(io); end

  def url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil), filename: T.unsafe(nil), **options); end

  def validate_associated_records_for_attachments(*args); end

  def validate_associated_records_for_variant_records(*args); end

  def video?(); end
  MINIMUM_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::Blob::Analyzable
  def analyze(); end

  def analyze_later(); end

  def analyzed?(); end
end

module ActiveStorage::Blob::GeneratedAssociationMethods
  def attachment_ids(); end

  def attachment_ids=(ids); end

  def attachments(); end

  def attachments=(value); end

  def build_preview_image_attachment(*args, &block); end

  def build_preview_image_blob(*args, &block); end

  def create_preview_image_attachment(*args, &block); end

  def create_preview_image_attachment!(*args, &block); end

  def create_preview_image_blob(*args, &block); end

  def create_preview_image_blob!(*args, &block); end

  def preview_image(); end

  def preview_image=(attachable); end

  def preview_image_attachment(); end

  def preview_image_attachment=(value); end

  def preview_image_blob(); end

  def preview_image_blob=(value); end

  def reload_preview_image_attachment(); end

  def reload_preview_image_blob(); end

  def reset_preview_image_attachment(); end

  def reset_preview_image_blob(); end

  def variant_record_ids(); end

  def variant_record_ids=(ids); end

  def variant_records(); end

  def variant_records=(value); end
end

module ActiveStorage::Blob::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::Identifiable
  def identified?(); end

  def identify(); end

  def identify_without_saving(); end
end

module ActiveStorage::Blob::Representable
  def preprocessed(transformations); end

  def preview(transformations); end

  def previewable?(); end

  def representable?(); end

  def representation(transformations); end

  def variable?(); end
end

module ActiveStorage::Blob::Servable
  def content_type_for_serving(); end

  def forced_disposition_for_serving(); end
end

class ActiveStorage::Blob
  def self.build_after_unfurling(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.compose(blobs, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil)); end

  def self.create_after_unfurling!(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_and_upload!(io:, filename:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_before_direct_upload!(filename:, byte_size:, checksum:, key: T.unsafe(nil), content_type: T.unsafe(nil), metadata: T.unsafe(nil), service_name: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.find_signed(id, record: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def self.find_signed!(id, record: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def self.scope_for_strict_loading(); end

  def self.service(); end

  def self.service=(value); end

  def self.service?(); end

  def self.services(); end

  def self.services=(value); end

  def self.services?(); end

  def self.unattached(*args, **arg); end

  def self.with_attached_preview_image(*args, **arg); end
end

class ActiveStorage::BlobKey
  def attributes(); end

  def initialize(attributes); end
end

class ActiveStorage::Blobs::ProxyController
  def show(); end
end

class ActiveStorage::Blobs::RedirectController
  def show(); end
end

class ActiveStorage::Current
  def self.url_options(); end

  def self.url_options=(value); end
end

class ActiveStorage::DirectUploadsController
  def create(); end
end

class ActiveStorage::DiskController
  def show(); end

  def update(); end
end

class ActiveStorage::Filename
  def as_json(*arg); end

  def base(); end

  def extension(); end

  def extension_with_delimiter(); end

  def extension_without_delimiter(); end

  def initialize(filename); end

  def sanitized(); end

  def to_json(); end
end

class ActiveStorage::Filename
  def self.wrap(filename); end
end

class ActiveStorage::FixtureSet
  def file_fixture_path(); end

  def file_fixture_path?(); end

  def prepare(instance, **attributes); end
end

class ActiveStorage::FixtureSet
  def self.blob(filename:, **attributes); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end
end

class ActiveStorage::LogSubscriber
  def preview(event); end

  def service_delete(event); end

  def service_delete_prefixed(event); end

  def service_download(event); end

  def service_exist(event); end

  def service_mirror(event); end

  def service_streaming_download(event); end

  def service_upload(event); end

  def service_url(event); end
end

class ActiveStorage::MirrorJob
  def perform(key, checksum:); end
end

class ActiveStorage::NamedVariant
  def initialize(transformations); end

  def preprocessed(); end

  def preprocessed?(record); end

  def transformations(); end
end

class ActiveStorage::Preview
  def blob(); end

  def content_type(*arg, **arg1, &arg2); end

  def download(&block); end

  def filename(*arg, **arg1, &arg2); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def url(**options); end

  def variation(); end
end

class ActiveStorage::PurgeJob
  def perform(blob); end
end

module ActiveStorage::Record::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveStorage::Representations::ProxyController
  def show(); end
end

class ActiveStorage::Representations::RedirectController
  def show(); end
end

class ActiveStorage::Service::CloudinaryService
  def download(key, &block); end

  def headers_for_direct_upload(key, content_type:, checksum:, **arg); end

  def initialize(**options); end

  def public_id(key, filename=T.unsafe(nil), content_type=T.unsafe(nil)); end

  def upload(key, io, filename: T.unsafe(nil), checksum: T.unsafe(nil), **options); end

  def upload_options(); end

  def url(key, filename: T.unsafe(nil), content_type: T.unsafe(nil), **options); end

  def url_for_direct_upload(key, **options); end
end

module ActiveStorage::Service::CloudinaryService::Headers
  CONTENT_MD5 = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

module ActiveStorage::Streaming
  DEFAULT_BLOB_STREAMING_DISPOSITION = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::TransformJob
  def perform(blob, transformations); end
end

class ActiveStorage::Transformers::Transformer
  def initialize(transformations); end

  def transform(file, format:); end

  def transformations(); end
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Variant
  def blob(); end

  def content_type(*arg, **arg1, &arg2); end

  def destroy(); end

  def download(&block); end

  def filename(); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def service(*arg, **arg1, &arg2); end

  def url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil)); end

  def variation(); end
end

class ActiveStorage::VariantRecord
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_image_attachment(*args); end

  def autosave_associated_records_for_image_blob(*args); end
end

module ActiveStorage::VariantRecord::GeneratedAssociationMethods
  def blob(); end

  def blob=(value); end

  def blob_changed?(); end

  def blob_previously_changed?(); end

  def build_blob(*args, &block); end

  def build_image_attachment(*args, &block); end

  def build_image_blob(*args, &block); end

  def create_blob(*args, &block); end

  def create_blob!(*args, &block); end

  def create_image_attachment(*args, &block); end

  def create_image_attachment!(*args, &block); end

  def create_image_blob(*args, &block); end

  def create_image_blob!(*args, &block); end

  def image(); end

  def image=(attachable); end

  def image_attachment(); end

  def image_attachment=(value); end

  def image_blob(); end

  def image_blob=(value); end

  def reload_blob(); end

  def reload_image_attachment(); end

  def reload_image_blob(); end

  def reset_blob(); end

  def reset_image_attachment(); end

  def reset_image_blob(); end
end

module ActiveStorage::VariantRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveStorage::VariantRecord
  def self.with_attached_image(*args, **arg); end
end

class ActiveStorage::VariantWithRecord
  def blob(); end

  def content_type(*arg, **arg1, &arg2); end

  def destroy(); end

  def download(*arg, **arg1, &arg2); end

  def filename(); end

  def image(); end

  def initialize(blob, variation); end

  def key(*arg, **arg1, &arg2); end

  def processed(); end

  def service(*arg, **arg1, &arg2); end

  def url(*arg, **arg1, &arg2); end

  def variation(); end
end

class ActiveStorage::Variation
  def content_type(); end

  def default_to(defaults); end

  def digest(); end

  def format(); end

  def initialize(transformations); end

  def key(); end

  def transform(file, &block); end

  def transformations(); end
end

class ActiveStorage::Variation
  def self.decode(key); end

  def self.encode(transformations); end

  def self.wrap(variator); end
end

class ActiveStorageValidations::AspectRatioValidator
  ASPECT_RATIO_REGEX = ::T.let(nil, ::T.untyped)
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
  ERROR_TYPES = ::T.let(nil, ::T.untyped)
  NAMED_ASPECT_RATIOS = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::AttachedValidator
  ERROR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::ContentTypeValidator
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
  ERROR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::DimensionValidator
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
  ERROR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::LimitValidator
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
  ERROR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::Metadata
  DEFAULT_IMAGE_PROCESSOR = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::ProcessableImageValidator
  ERROR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveStorageValidations::SizeValidator
  AVAILABLE_CHECKS = ::T.let(nil, ::T.untyped)
  ERROR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::BacktraceCleaner
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
  OPTION_ALIASES = ::T.let(nil, ::T.untyped)
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Coder
  COMPRESSED_FLAG = ::T.let(nil, ::T.untyped)
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  OBJECT_DUMP_TYPE = ::T.let(nil, ::T.untyped)
  PACKED_EXPIRES_AT_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_TYPE_TEMPLATE = ::T.let(nil, ::T.untyped)
  PACKED_VERSION_INDEX = ::T.let(nil, ::T.untyped)
  PACKED_VERSION_LENGTH_TEMPLATE = ::T.let(nil, ::T.untyped)
  SIGNATURE = ::T.let(nil, ::T.untyped)
  STRING_DESERIALIZERS = ::T.let(nil, ::T.untyped)
  STRING_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
  def cache_path(); end

  def initialize(cache_path, **options); end
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

module ActiveSupport::Cache::MemoryStore::DupCoder
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::RedisCacheStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  def initialize(error_handler: T.unsafe(nil), **redis_options); end

  def max_key_bytesize(); end

  def redis(); end

  def stats(); end
  DEFAULT_ERROR_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_REDIS_OPTIONS = ::T.let(nil, ::T.untyped)
  MAX_KEY_BYTESIZE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::RedisCacheStore
  def self.build_redis(redis: T.unsafe(nil), url: T.unsafe(nil), **redis_options); end

  def self.supports_cache_versioning?(); end
end

module ActiveSupport::Cache::SerializerWithFallback
  SERIALIZERS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal61WithFallback
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  MARK_COMPRESSED = ::T.let(nil, ::T.untyped)
  MARK_UNCOMPRESSED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def with_local_cache(&block); end
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator
  def define_cached_method(name, namespace:, as: T.unsafe(nil), &block); end

  def execute(); end

  def initialize(owner, path, line); end
end

class ActiveSupport::CodeGenerator::MethodSet
  def apply(owner, path, line); end

  def define_cached_method(name, as: T.unsafe(nil)); end

  def initialize(namespace); end
  METHOD_CACHES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator
  def self.batch(owner, path, line); end
end

class ActiveSupport::Concurrency::ThreadLoadInterlockAwareMonitor
  include ::ActiveSupport::Concurrency::LoadInterlockAwareMonitorMixin
end

class ActiveSupport::CurrentAttributes
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
  INVALID_ATTRIBUTE_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CurrentAttributes
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.after_reset(*methods, &block); end

  def self.attribute(*names); end

  def self.before_reset(*methods, &block); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*arg, **arg1, &arg2); end

  def self.reset_all(); end

  def self.resets(*methods, &block); end

  def self.set(*arg, **arg1, &arg2); end
end

class ActiveSupport::Deprecation
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::Reporting
  LIB_DIR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
  VARIABLE_PARTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EncryptedFile
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnvironmentInquirer
  DEFAULT_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
  LOCAL_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ErrorReporter
  DEFAULT_SOURCE = ::T.let(nil, ::T.untyped)
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::Core
  def changed(modified, added, removed); end

  def common_path(paths); end

  def directories_to_watch(); end

  def files(); end

  def finalizer(); end

  def initialize(files, dirs); end

  def normalize_dirs!(); end

  def restart(); end

  def restart?(); end

  def start(); end

  def stop(); end

  def thread_safely(); end

  def updated(); end

  def watching?(file); end
end

module ActiveSupport::ExecutionContext
end

module ActiveSupport::ExecutionContext
  def self.[]=(key, value); end

  def self.after_change(&block); end

  def self.clear(); end

  def self.set(**options); end

  def self.to_h(); end
end

class ActiveSupport::ExecutionWrapper
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete(); end

  def complete!(); end

  def run(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active?(); end

  def self.active_key(); end

  def self.error_reporter(); end

  def self.perform(); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(reset: T.unsafe(nil)); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(source: T.unsafe(nil)); end
end

module ActiveSupport::Executor::TestHelper
  def run(*arg, **arg1, &arg2); end
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

module ActiveSupport::ForkTracker::CoreExt
  def fork(*arg, **arg1, &arg2); end
end

module ActiveSupport::ForkTracker::ModernCoreExt
  def _fork(); end
end

module ActiveSupport::ForkTracker
  def self.after_fork(&block); end

  def self.after_fork_callback(); end

  def self.check!(); end

  def self.hook!(); end

  def self.unregister(callback); end
end

class ActiveSupport::Gzip::Stream
  def initialize(*arg); end
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

class ActiveSupport::HashWithIndifferentAccess
  NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Inflector
  ALLOWED_ENCODINGS_FOR_TRANSLITERATE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::IsolatedExecutionState
  def self.[](key); end

  def self.[]=(key, value); end

  def self.clear(); end

  def self.context(); end

  def self.delete(key); end

  def self.isolation_level(); end

  def self.isolation_level=(level); end

  def self.key?(key); end

  def self.scope(); end

  def self.share_with(other); end

  def self.unique_id(); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(val); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def event_levels=(event_levels); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def silenced?(event); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  LEVEL_CHECKS = ::T.let(nil, ::T.untyped)
  MODES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator
  AUTH_TAG_LENGTH = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptors
end

class ActiveSupport::MessageEncryptors
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator
  SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_LENGTH = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Messages::Metadata
  ENVELOPE_SERIALIZERS = ::T.let(nil, ::T.untyped)
  TIMESTAMP_SERIALIZERS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Messages::SerializerWithFallback
  SERIALIZERS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Messages::SerializerWithFallback::JsonWithFallback
  JSON_START_WITH = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Messages::SerializerWithFallback::MarshalWithFallback
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(namespace); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(validate_float); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(value); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(value); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

module ActiveSupport::RangeWithFormat
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(check); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(executor); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(value); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(value); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end

  def self.wrap(**kwargs); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::RubyFeatures
  CLASS_SUBCLASSES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SecureCompareRotator
  include ::ActiveSupport::SecurityUtils
  def initialize(value, on_rotation: T.unsafe(nil)); end

  def rotate(previous_value); end

  def secure_compare!(other_value, on_rotation: T.unsafe(nil)); end
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator
end

class ActiveSupport::Subscriber
  def call(event); end

  def patterns(); end

  def publish_event(event); end
end

class ActiveSupport::SyntaxErrorProxy
  def backtrace(); end

  def backtrace_locations(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SyntaxErrorProxy::BacktraceLocation
  def label(); end

  def spot(_); end
end

class ActiveSupport::SyntaxErrorProxy::BacktraceLocationProxy
  def initialize(loc, ex); end

  def spot(_); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def dom_class(*arg, **arg1, &arg2); end

  def dom_id(*arg, **arg1, &arg2); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

class ActiveSupport::TestCase
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil), threshold: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end

  def assert_raise(*exp, match: T.unsafe(nil), &block); end

  def assert_raises(*exp, match: T.unsafe(nil), &block); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::ConstantStubbing
  def stub_const(mod, constant, new_value); end
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::ErrorReporterAssertions
  def assert_error_reported(error_class=T.unsafe(nil), &block); end

  def assert_no_error_reported(&block); end
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::Isolation
  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation
  def self.forking_env?(); end

  def self.included(klass); end
end

class ActiveSupport::Testing::Parallelization
  def <<(work); end

  def after_fork_hooks(); end

  def initialize(worker_count); end

  def run_cleanup_hooks(); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class ActiveSupport::Testing::Parallelization::Server
  def <<(o); end

  def active_workers?(); end

  def interrupt(); end

  def pop(); end

  def record(reporter, result); end

  def shutdown(); end

  def start_worker(worker_id); end

  def stop_worker(worker_id); end
end

class ActiveSupport::Testing::Parallelization::Worker
  def after_fork(); end

  def initialize(number, url); end

  def perform_job(job); end

  def run_cleanup(); end

  def safe_record(reporter, result); end

  def start(); end

  def work_from_queue(); end
end

class ActiveSupport::Testing::Parallelization
  def self.after_fork_hook(&blk); end

  def self.after_fork_hooks(); end

  def self.run_cleanup_hook(&blk); end

  def self.run_cleanup_hooks(); end
end

class ActiveSupport::Testing::ParallelizeExecutor
  def <<(work); end

  def initialize(size:, with:, threshold: T.unsafe(nil)); end

  def parallelize_with(); end

  def shutdown(); end

  def size(); end

  def start(); end

  def threshold(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def stubbed?(); end

  def stubbing(object, method_name); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(with_usec: T.unsafe(nil), &block); end

  def travel(duration, with_usec: T.unsafe(nil), &block); end

  def travel_back(); end

  def travel_to(date_or_time, with_usec: T.unsafe(nil)); end

  def unfreeze_time(); end
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  PRECISIONS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*arg, **arg1, &arg2); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini_REXML
  def parse(data); end
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

module Addressable::IDNA
  def self._deprecated_unicode_normalize_kc(value); end

  def self.to_ascii(input); end

  def self.to_unicode(input); end

  def self.unicode_normalize_kc(*args, **arg, &block); end
end

class Addressable::Template
  def ==(template); end

  def eql?(template); end

  def expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def extract(uri, processor=T.unsafe(nil)); end

  def initialize(pattern); end

  def keys(); end

  def match(uri, processor=T.unsafe(nil)); end

  def named_captures(); end

  def names(); end

  def partial_expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def pattern(); end

  def source(); end

  def to_regexp(); end

  def variable_defaults(); end

  def variables(); end
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::Template::MatchData
  def [](key, len=T.unsafe(nil)); end

  def captures(); end

  def initialize(uri, template, mapping); end

  def keys(); end

  def mapping(); end

  def names(); end

  def post_match(); end

  def pre_match(); end

  def string(); end

  def template(); end

  def to_a(); end

  def uri(); end

  def values(); end

  def values_at(*indexes); end

  def variables(); end
end

class Addressable::URI
  def +(uri); end

  def ==(uri); end

  def ===(uri); end

  def absolute?(); end

  def authority(); end

  def authority=(new_authority); end

  def basename(); end

  def default_port(); end

  def defer_validation(); end

  def display_uri(); end

  def domain(); end

  def empty?(); end

  def encode_with(coder); end

  def eql?(uri); end

  def extname(); end

  def force_utf8_encoding_if_needed(str); end

  def fragment(); end

  def fragment=(new_fragment); end

  def host(); end

  def host=(new_host); end

  def hostname(); end

  def hostname=(new_hostname); end

  def inferred_port(); end

  def init_with(coder); end

  def initialize(options=T.unsafe(nil)); end

  def ip_based?(); end

  def join(uri); end

  def join!(uri); end

  def merge(hash); end

  def merge!(uri); end

  def normalize(); end

  def normalize!(); end

  def normalized_authority(); end

  def normalized_fragment(); end

  def normalized_host(); end

  def normalized_password(); end

  def normalized_path(); end

  def normalized_port(); end

  def normalized_query(*flags); end

  def normalized_scheme(); end

  def normalized_site(); end

  def normalized_user(); end

  def normalized_userinfo(); end

  def omit(*components); end

  def omit!(*components); end

  def origin(); end

  def origin=(new_origin); end

  def password(); end

  def password=(new_password); end

  def path(); end

  def path=(new_path); end

  def port(); end

  def port=(new_port); end

  def query(); end

  def query=(new_query); end

  def query_values(return_type=T.unsafe(nil)); end

  def query_values=(new_query_values); end

  def relative?(); end

  def remove_composite_values(); end

  def replace_self(uri); end

  def request_uri(); end

  def request_uri=(new_request_uri); end

  def route_from(uri); end

  def route_to(uri); end

  def scheme(); end

  def scheme=(new_scheme); end

  def site(); end

  def site=(new_site); end

  def split_path(path); end

  def tld(); end

  def tld=(new_tld); end

  def to_hash(); end

  def to_str(); end

  def user(); end

  def user=(new_user); end

  def userinfo(); end

  def userinfo=(new_userinfo); end

  def validate(); end
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESERVED_AND_UNRESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClassesRegexps
  AUTHORITY = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESERVED_AND_UNRESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::NormalizeCharacterClasses
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

class Addressable::URI
  def self.convert_path(path); end

  def self.encode(uri, return_type=T.unsafe(nil)); end

  def self.encode_component(component, character_class=T.unsafe(nil), upcase_encoded=T.unsafe(nil)); end

  def self.escape(uri, return_type=T.unsafe(nil)); end

  def self.escape_component(component, character_class=T.unsafe(nil), upcase_encoded=T.unsafe(nil)); end

  def self.form_encode(form_values, sort=T.unsafe(nil)); end

  def self.form_unencode(encoded_value); end

  def self.heuristic_parse(uri, hints=T.unsafe(nil)); end

  def self.ip_based_schemes(); end

  def self.join(*uris); end

  def self.normalize_component(component, character_class=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.normalize_path(path); end

  def self.normalized_encode(uri, return_type=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.port_mapping(); end

  def self.unencode(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unencode_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Agenda
  include ::Agenda::GeneratedAttributeMethods
  include ::Agenda::GeneratedAssociationMethods
  def autosave_associated_records_for_agenda_items(*args); end

  def autosave_associated_records_for_user(*args); end

  def validate_associated_records_for_agenda_items(*args); end
end

module Agenda::GeneratedAssociationMethods
  def agenda_item_ids(); end

  def agenda_item_ids=(ids); end

  def agenda_items(); end

  def agenda_items=(value); end

  def agenda_items_attributes=(attributes); end

  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Agenda::GeneratedAssociationMethods
end

module Agenda::GeneratedAttributeMethods
end

module Agenda::GeneratedAttributeMethods
  extend ::Mutex_m
end

class AgendaItem
  include ::AgendaItem::GeneratedAttributeMethods
  include ::AgendaItem::GeneratedAssociationMethods
  include ::ActiveRecord::Acts::List::InstanceMethods
  include ::ActiveRecord::Acts::List::NoUpdate
  def acts_as_list_class(); end

  def acts_as_list_top(); end

  def add_new_at(); end

  def autosave_associated_records_for_agenda(*args); end

  def autosave_associated_records_for_rich_text_details(*args); end

  def connection(&block); end

  def destroyed_via_scope?(); end

  def details(); end

  def details=(body); end

  def details?(); end

  def position=(position); end

  def position_changed(); end

  def position_column(); end

  def scope_changed?(); end

  def scope_name(); end

  def touch_record_sql(); end

  def validate_associated_records_for_rich_text_details(*args); end
end

module AgendaItem::GeneratedAssociationMethods
  def agenda(); end

  def agenda=(value); end

  def agenda_changed?(); end

  def agenda_previously_changed?(); end

  def build_agenda(*args, &block); end

  def build_rich_text_details(*args, &block); end

  def create_agenda(*args, &block); end

  def create_agenda!(*args, &block); end

  def create_rich_text_details(*args, &block); end

  def create_rich_text_details!(*args, &block); end

  def reload_agenda(); end

  def reload_rich_text_details(); end

  def reset_agenda(); end

  def reset_rich_text_details(); end

  def rich_text_details(); end

  def rich_text_details=(value); end
end

module AgendaItem::GeneratedAssociationMethods
end

module AgendaItem::GeneratedAttributeMethods
end

module AgendaItem::GeneratedAttributeMethods
  extend ::Mutex_m
end

class AgendaItem
  extend ::ActiveRecord::Acts::List::NoUpdate::ClassMethods
  def self.acts_as_list_top(); end

  def self.decrement_all(); end

  def self.decrement_sequentially(); end

  def self.in_list(*args, **arg); end

  def self.increment_all(); end

  def self.increment_sequentially(); end

  def self.quoted_position_column(); end

  def self.quoted_position_column_with_table_name(); end

  def self.touch_record_sql(); end

  def self.update_all_with_touch(updates); end

  def self.with_rich_text_details(*args, **arg); end

  def self.with_rich_text_details_and_embeds(*args, **arg); end
end

module Airbrussh
  VERSION = ::T.let(nil, ::T.untyped)
end

module Airbrussh::Colors
  ANSI_CODES = ::T.let(nil, ::T.untyped)
end

module Airbrussh::Colors
  def self.blue(string); end

  def self.gray(string); end

  def self.green(string); end

  def self.red(string); end

  def self.yellow(string); end
end

class Airbrussh::CommandFormatter
  def exit_message(); end

  def format_output(line); end

  def initialize(command, position); end

  def start_message(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Airbrussh::Configuration
  def apply_options(options); end

  def banner(); end

  def banner=(banner); end

  def banner_message(); end

  def color(); end

  def color=(color); end

  def command_output(); end

  def command_output=(command_output); end

  def context(); end

  def context=(context); end

  def formatters(io); end

  def log_file(); end

  def log_file=(log_file); end

  def monkey_patch_rake(); end

  def monkey_patch_rake=(monkey_patch_rake); end

  def show_command_output?(sym); end

  def task_prefix(); end

  def task_prefix=(task_prefix); end

  def truncate(); end

  def truncate=(truncate); end
end

class Airbrussh::Console
  def <<(string); end

  def config(); end

  def console_width(); end

  def initialize(output, config=T.unsafe(nil)); end

  def output(); end

  def print_line(obj=T.unsafe(nil)); end

  def strip_ascii_color(string); end

  def truncate_to_console_width(string); end

  def write(string); end
end

class Airbrussh::ConsoleFormatter
  def config(); end

  def context(); end

  def current_task_name(*args, **arg, &block); end

  def initialize(io, config=T.unsafe(nil)); end

  def log_command_data(command, stream_type, string); end

  def register_new_command(*args, **arg, &block); end

  def write(obj); end

  def write_banner(); end
end

class Airbrussh::DelegatingFormatter
  def <<(command_or_log_message); end

  def debug(*args); end

  def error(*args); end

  def fatal(*args); end

  def formatters(); end

  def info(*args); end

  def initialize(formatters); end

  def log(*args); end

  def log_command_data(*args); end

  def log_command_exit(*args); end

  def log_command_start(*args); end

  def warn(*args); end

  def write(command_or_log_message); end
  DUP_AND_FORWARD_METHODS = ::T.let(nil, ::T.untyped)
  FORWARD_METHODS = ::T.let(nil, ::T.untyped)
end

class Airbrussh::Formatter
  def initialize(io, options_or_config_object=T.unsafe(nil)); end
end

class Airbrussh::LogFileFormatter
  def initialize(path, formatter_class=T.unsafe(nil)); end

  def path(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Airbrussh::Rake::Context
  def current_task_name(); end

  def initialize(config=T.unsafe(nil)); end

  def position(command); end

  def register_new_command(command); end
end

module Airbrussh::Rake::Context::Patch
  def execute(args=T.unsafe(nil)); end
end

class Airbrussh::Rake::Context
  def self.current_task_name(); end

  def self.current_task_name=(current_task_name); end

  def self.install_monkey_patch(); end
end

module Airbrussh
  def self.configuration(options=T.unsafe(nil)); end

  def self.configure(); end
end

module AmazingPrint::ActionView
  def ap(object, options=T.unsafe(nil)); end

  def ap_debug(object, options=T.unsafe(nil)); end
end

class AmazingPrint::ExtLoader
  EXT_LOAD_ATTEMPT_LIMIT = ::T.let(nil, ::T.untyped)
end

class AmazingPrint::Formatter
  CORE_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class AmazingPrint::Formatters::BaseFormatter
  DEFAULT_LIMIT_SIZE = ::T.let(nil, ::T.untyped)
  INDENT_CACHE = ::T.let(nil, ::T.untyped)
end

class AmazingPrint::Inspector
  AP = ::T.let(nil, ::T.untyped)
end

class Anniversary
  include ::Anniversary::GeneratedAttributeMethods
  include ::Anniversary::GeneratedAssociationMethods
  def marriage_age(); end

  def marriage_today?(); end
end

module Anniversary::GeneratedAssociationMethods
end

module Anniversary::GeneratedAssociationMethods
end

module Anniversary::GeneratedAttributeMethods
end

module Anniversary::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Anniversary
  def self.find_marriages_for(*args, **arg); end

  def self.marriage_today(*args, **arg); end
end

module AnnotateModels::FilePatterns
  ACTIVEADMIN_DIR = ::T.let(nil, ::T.untyped)
  BLUEPRINTS_SPEC_DIR = ::T.let(nil, ::T.untyped)
  BLUEPRINTS_TEST_DIR = ::T.let(nil, ::T.untyped)
  CONTROLLER_DIR = ::T.let(nil, ::T.untyped)
  CONTROLLER_SPEC_DIR = ::T.let(nil, ::T.untyped)
  CONTROLLER_TEST_DIR = ::T.let(nil, ::T.untyped)
  EXEMPLARS_SPEC_DIR = ::T.let(nil, ::T.untyped)
  EXEMPLARS_TEST_DIR = ::T.let(nil, ::T.untyped)
  FABRICATORS_SPEC_DIR = ::T.let(nil, ::T.untyped)
  FABRICATORS_TEST_DIR = ::T.let(nil, ::T.untyped)
  FACTORY_BOT_SPEC_DIR = ::T.let(nil, ::T.untyped)
  FACTORY_BOT_TEST_DIR = ::T.let(nil, ::T.untyped)
  FIXTURE_SPEC_DIR = ::T.let(nil, ::T.untyped)
  FIXTURE_TEST_DIR = ::T.let(nil, ::T.untyped)
  HELPER_DIR = ::T.let(nil, ::T.untyped)
  MODEL_TEST_DIR = ::T.let(nil, ::T.untyped)
  REQUEST_SPEC_DIR = ::T.let(nil, ::T.untyped)
  ROUTING_SPEC_DIR = ::T.let(nil, ::T.untyped)
  SERIALIZERS_DIR = ::T.let(nil, ::T.untyped)
  SERIALIZERS_SPEC_DIR = ::T.let(nil, ::T.untyped)
  SERIALIZERS_TEST_DIR = ::T.let(nil, ::T.untyped)
  SPEC_MODEL_DIR = ::T.let(nil, ::T.untyped)
  UNIT_TEST_DIR = ::T.let(nil, ::T.untyped)
end

module AnnotateModels::FilePatterns
  def self.generate(root_directory, pattern_type, options); end
end

module AnnotateModels
  def self.skip_subdirectory_model_load(); end

  def self.skip_subdirectory_model_load=(skip_subdirectory_model_load); end
end

class AnnotateRoutes::HeaderGenerator
  def generate(); end

  def initialize(options, routes_map); end
  HEADER_ROW = ::T.let(nil, ::T.untyped)
  PREFIX = ::T.let(nil, ::T.untyped)
  PREFIX_MD = ::T.let(nil, ::T.untyped)
end

class AnnotateRoutes::HeaderGenerator
  def self.generate(options=T.unsafe(nil)); end
end

module ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::DeviseI18n::ViewHelpers
  include ::ApplicationHelper
  include ::AnniversariesHelper
  include ::BirthdaysHelper
  include ::CheckoutHelper
  include ::MembersHelper
  include ::ParticipantsHelper
  include ::RoomsHelper
  include ::SubmitStoriesHelper
  include ::TodoItemsHelper
  include ::DeviseHelper
end

module ApplicationController::HelperMethods
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAttributeMethods
  include ::ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAttributeMethods
end

module ApplicationRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

Arel::Attribute = Arel::Attributes::Attribute

class Arel::SelectManager
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class ArgumentError
  include ::ErrorHighlight::CoreExt
end

class Array
  def deconstruct(); end

  def place(*values); end

  def to_h(); end
end

class Array
  def self.new(*arg); end

  def self.try_convert(arg); end
end

module Aws
  CORE_GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::ClientSideMonitoring::RequestMetrics
  FIELD_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::EC2Metadata
  METADATA_TOKEN_PATH = ::T.let(nil, ::T.untyped)
end

class Aws::ECSCredentials
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::EndpointCache
  MAX_ENTRIES = ::T.let(nil, ::T.untyped)
  MAX_THREADS = ::T.let(nil, ::T.untyped)
end

class Aws::EndpointCache::Endpoint
  CACHE_PERIOD = ::T.let(nil, ::T.untyped)
end

class Aws::EventStream::Encoder
  MAX_HEADERS_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_PAYLOAD_LENGTH = ::T.let(nil, ::T.untyped)
  OVERHEAD_LENGTH = ::T.let(nil, ::T.untyped)
end

class Aws::InstanceProfileCredentials
  METADATA_PATH_BASE = ::T.let(nil, ::T.untyped)
  METADATA_TOKEN_PATH = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

Aws::Json::ENGINE = Aws::Json::JSONEngine

class Aws::Json::Handler
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

module Aws::Json::OjEngine
  DUMP_OPTIONS = ::T.let(nil, ::T.untyped)
  LOAD_OPTIONS = ::T.let(nil, ::T.untyped)
  PARSE_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::Log::ParamFilter
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::Log::ParamFormatter
  MAX_STRING_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::ParamValidator
  EXPECTED_GOT = ::T.let(nil, ::T.untyped)
end

class Aws::Partitions::EndpointProvider
  STS_LEGACY_REGIONS = ::T.let(nil, ::T.untyped)
end

module Aws::Partitions
  extend ::Enumerable
end

class Aws::Plugins::HttpChecksum::Handler
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ClientRateLimiter
  BETA = ::T.let(nil, ::T.untyped)
  MIN_CAPACITY = ::T.let(nil, ::T.untyped)
  MIN_FILL_RATE = ::T.let(nil, ::T.untyped)
  SCALE_CONSTANT = ::T.let(nil, ::T.untyped)
  SMOOTH = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ClockSkew
  CLOCK_SKEW_THRESHOLD = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::ErrorInspector
  CHECKSUM_ERRORS = ::T.let(nil, ::T.untyped)
  CLOCK_SKEW_ERRORS = ::T.let(nil, ::T.untyped)
  EXPIRED_CREDS = ::T.let(nil, ::T.untyped)
  NETWORKING_ERRORS = ::T.let(nil, ::T.untyped)
  THROTTLING_ERRORS = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::Retries::RetryQuota
  INITIAL_RETRY_TOKENS = ::T.let(nil, ::T.untyped)
  NO_RETRY_INCREMENT = ::T.let(nil, ::T.untyped)
  RETRY_COST = ::T.let(nil, ::T.untyped)
  TIMEOUT_RETRY_COST = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RetryErrors
  DEFAULT_BACKOFF = ::T.let(nil, ::T.untyped)
  EQUAL_JITTER = ::T.let(nil, ::T.untyped)
  FULL_JITTER = ::T.let(nil, ::T.untyped)
  JITTERS = ::T.let(nil, ::T.untyped)
  NO_JITTER = ::T.let(nil, ::T.untyped)
end

class Aws::Plugins::RetryErrors::Handler
  MAX_BACKOFF = ::T.let(nil, ::T.untyped)
end

class Aws::Query::Handler
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  METADATA_REF = ::T.let(nil, ::T.untyped)
end

module Aws::SSO
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

module Aws::SSO::ClientApi
  API = ::T.let(nil, ::T.untyped)
  AccessKeyType = ::T.let(nil, ::T.untyped)
  AccessTokenType = ::T.let(nil, ::T.untyped)
  AccountIdType = ::T.let(nil, ::T.untyped)
  AccountInfo = ::T.let(nil, ::T.untyped)
  AccountListType = ::T.let(nil, ::T.untyped)
  AccountNameType = ::T.let(nil, ::T.untyped)
  EmailAddressType = ::T.let(nil, ::T.untyped)
  ErrorDescription = ::T.let(nil, ::T.untyped)
  ExpirationTimestampType = ::T.let(nil, ::T.untyped)
  GetRoleCredentialsRequest = ::T.let(nil, ::T.untyped)
  GetRoleCredentialsResponse = ::T.let(nil, ::T.untyped)
  InvalidRequestException = ::T.let(nil, ::T.untyped)
  ListAccountRolesRequest = ::T.let(nil, ::T.untyped)
  ListAccountRolesResponse = ::T.let(nil, ::T.untyped)
  ListAccountsRequest = ::T.let(nil, ::T.untyped)
  ListAccountsResponse = ::T.let(nil, ::T.untyped)
  LogoutRequest = ::T.let(nil, ::T.untyped)
  MaxResultType = ::T.let(nil, ::T.untyped)
  NextTokenType = ::T.let(nil, ::T.untyped)
  ResourceNotFoundException = ::T.let(nil, ::T.untyped)
  RoleCredentials = ::T.let(nil, ::T.untyped)
  RoleInfo = ::T.let(nil, ::T.untyped)
  RoleListType = ::T.let(nil, ::T.untyped)
  RoleNameType = ::T.let(nil, ::T.untyped)
  SecretAccessKeyType = ::T.let(nil, ::T.untyped)
  SessionTokenType = ::T.let(nil, ::T.untyped)
  TooManyRequestsException = ::T.let(nil, ::T.untyped)
  UnauthorizedException = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::AccountInfo
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::GetRoleCredentialsRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::GetRoleCredentialsResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::InvalidRequestException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::ListAccountRolesRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::ListAccountRolesResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::ListAccountsRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::ListAccountsResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::LogoutRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::ResourceNotFoundException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::RoleCredentials
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::RoleInfo
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::TooManyRequestsException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSO::Types::UnauthorizedException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SSOCredentials
  SSO_LOGIN_GUIDANCE = ::T.let(nil, ::T.untyped)
  SSO_REQUIRED_OPTS = ::T.let(nil, ::T.untyped)
end

module Aws::STS
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

module Aws::STS::ClientApi
  API = ::T.let(nil, ::T.untyped)
  AssumeRoleRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleResponse = ::T.let(nil, ::T.untyped)
  AssumeRoleWithSAMLRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleWithSAMLResponse = ::T.let(nil, ::T.untyped)
  AssumeRoleWithWebIdentityRequest = ::T.let(nil, ::T.untyped)
  AssumeRoleWithWebIdentityResponse = ::T.let(nil, ::T.untyped)
  AssumedRoleUser = ::T.let(nil, ::T.untyped)
  Audience = ::T.let(nil, ::T.untyped)
  Credentials = ::T.let(nil, ::T.untyped)
  DecodeAuthorizationMessageRequest = ::T.let(nil, ::T.untyped)
  DecodeAuthorizationMessageResponse = ::T.let(nil, ::T.untyped)
  ExpiredTokenException = ::T.let(nil, ::T.untyped)
  FederatedUser = ::T.let(nil, ::T.untyped)
  GetAccessKeyInfoRequest = ::T.let(nil, ::T.untyped)
  GetAccessKeyInfoResponse = ::T.let(nil, ::T.untyped)
  GetCallerIdentityRequest = ::T.let(nil, ::T.untyped)
  GetCallerIdentityResponse = ::T.let(nil, ::T.untyped)
  GetFederationTokenRequest = ::T.let(nil, ::T.untyped)
  GetFederationTokenResponse = ::T.let(nil, ::T.untyped)
  GetSessionTokenRequest = ::T.let(nil, ::T.untyped)
  GetSessionTokenResponse = ::T.let(nil, ::T.untyped)
  IDPCommunicationErrorException = ::T.let(nil, ::T.untyped)
  IDPRejectedClaimException = ::T.let(nil, ::T.untyped)
  InvalidAuthorizationMessageException = ::T.let(nil, ::T.untyped)
  InvalidIdentityTokenException = ::T.let(nil, ::T.untyped)
  Issuer = ::T.let(nil, ::T.untyped)
  MalformedPolicyDocumentException = ::T.let(nil, ::T.untyped)
  NameQualifier = ::T.let(nil, ::T.untyped)
  PackedPolicyTooLargeException = ::T.let(nil, ::T.untyped)
  PolicyDescriptorType = ::T.let(nil, ::T.untyped)
  RegionDisabledException = ::T.let(nil, ::T.untyped)
  SAMLAssertionType = ::T.let(nil, ::T.untyped)
  Subject = ::T.let(nil, ::T.untyped)
  SubjectType = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleWithSAMLRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleWithSAMLResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleWithWebIdentityRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumeRoleWithWebIdentityResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::AssumedRoleUser
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::Credentials
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::DecodeAuthorizationMessageRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::DecodeAuthorizationMessageResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::ExpiredTokenException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::FederatedUser
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetAccessKeyInfoRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetAccessKeyInfoResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetCallerIdentityResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetFederationTokenRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetFederationTokenResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetSessionTokenRequest
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::GetSessionTokenResponse
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::IDPCommunicationErrorException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::IDPRejectedClaimException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::InvalidAuthorizationMessageException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::InvalidIdentityTokenException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::MalformedPolicyDocumentException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::PackedPolicyTooLargeException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::PolicyDescriptorType
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::RegionDisabledException
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::STS::Types::Tag
  SENSITIVE = ::T.let(nil, ::T.untyped)
end

class Aws::SharedConfig
  SSO_PROFILE_KEYS = ::T.let(nil, ::T.untyped)
end

class Aws::SharedCredentials
  KEY_MAP = ::T.let(nil, ::T.untyped)
end

module Aws::Sigv4
  VERSION = ::T.let(nil, ::T.untyped)
end

class Aws::Xml::Parser
  FRAME_CLASSES = ::T.let(nil, ::T.untyped)
end

class BCrypt::Engine
  DEFAULT_COST = ::T.let(nil, ::T.untyped)
  MAX_COST = ::T.let(nil, ::T.untyped)
  MAX_SALT_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_SECRET_BYTESIZE = ::T.let(nil, ::T.untyped)
  MIN_COST = ::T.let(nil, ::T.untyped)
end

module Backport
  VERSION = ::T.let(nil, ::T.untyped)
end

class Backport::Adapter
  def close(); end

  def closed?(); end

  def closing(); end

  def initialize(output, remote=T.unsafe(nil)); end

  def opening(); end

  def receiving(data); end

  def remote(); end

  def write(data); end

  def write_line(data); end
end

class Backport::Adapter
end

class Backport::Client
  include ::Observable
  def adapter(); end

  def initialize(input, output, adapter, remote=T.unsafe(nil)); end

  def run(); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Backport::Client
end

class Backport::Machine
  def prepare(server); end

  def run(); end

  def servers(); end

  def stop(); end

  def stopped?(); end

  def update(server); end
end

class Backport::Machine
end

module Backport::Server
end

class Backport::Server::Base
  include ::Observable
  def start(); end

  def started?(); end

  def starting(); end

  def stop(); end

  def stopped?(); end

  def stopping(); end

  def tick(); end
end

class Backport::Server::Base
end

module Backport::Server::Connectable
  def clients(); end

  def starting(); end

  def stopping(); end
end

module Backport::Server::Connectable
end

class Backport::Server::Interval
  def initialize(period, &block); end
end

class Backport::Server::Interval
end

class Backport::Server::Stdio
  include ::Backport::Server::Connectable
  def initialize(input: T.unsafe(nil), output: T.unsafe(nil), adapter: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Stdio
end

class Backport::Server::Tcpip
  include ::Backport::Server::Connectable
  def accept(); end

  def initialize(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil), socket_class: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Tcpip
end

module Backport::Server
end

module Backport
  def self.logger(); end

  def self.prepare_interval(period, &block); end

  def self.prepare_stdio_server(adapter: T.unsafe(nil)); end

  def self.prepare_tcp_server(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil)); end

  def self.run(&block); end

  def self.stop(); end
end

module Base64
  VERSION = ::T.let(nil, ::T.untyped)
end

class BasicObject
  def __binding__(); end

  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

module Benchmark
  VERSION = ::T.let(nil, ::T.untyped)
end

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end

  def to_h(); end
end

module BetterErrors
  VERSION = ::T.let(nil, ::T.untyped)
end

class BetterErrors::CodeFormatter
  def context(); end

  def context_lines(); end

  def filename(); end

  def initialize(filename, line, context=T.unsafe(nil)); end

  def line(); end

  def line_range(); end

  def output(); end
end

class BetterErrors::CodeFormatter::HTML
  def formatted_lines(); end

  def formatted_nums(); end

  def highlighted_lines(); end

  def rouge_lexer(); end

  def source_unavailable(); end
end

class BetterErrors::CodeFormatter::Text
  def formatted_lines(); end

  def source_unavailable(); end
end

class BetterErrors::Editor
  def initialize(url_proc); end

  def scheme(); end

  def url(raw_path, line); end
  KNOWN_EDITORS = ::T.let(nil, ::T.untyped)
end

class BetterErrors::Editor
  def self.default_editor(); end

  def self.editor_from_command(editor_command); end

  def self.editor_from_environment_editor(); end

  def self.editor_from_environment_formatting_string(); end

  def self.editor_from_symbol(symbol); end

  def self.for_formatting_string(formatting_string); end

  def self.for_proc(url_proc); end
end

class BetterErrors::ErrorPage
  def action_dispatch_action_endpoint(); end

  def active_support_actions(); end

  def application_frames(); end

  def backtrace_frames(); end

  def do_eval(opts); end

  def do_variables(opts); end

  def env(); end

  def exception(); end

  def exception_hint(); end

  def exception_message(); end

  def exception_type(); end

  def first_frame(); end

  def id(); end

  def initialize(exception, env); end

  def render_main(csrf_token, csp_nonce); end

  def render_text(); end

  def repls(); end
end

class BetterErrors::ErrorPage::VariableInfo
  def editor_url(); end

  def editor_url=(_); end

  def frame(); end

  def frame=(_); end

  def rack_session(); end

  def rack_session=(_); end

  def rails_params(); end

  def rails_params=(_); end

  def start_time(); end

  def start_time=(_); end
end

class BetterErrors::ErrorPage::VariableInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class BetterErrors::ErrorPage
  def self.html_formatted_code_block(frame); end

  def self.inspect_value(obj); end

  def self.render_template(template_name, locals); end

  def self.template(template_name); end

  def self.template_path(template_name); end

  def self.text_formatted_code_block(frame); end
end

module BetterErrors::ErrorPageStyle
  def self.compiled_css(for_deployment=T.unsafe(nil)); end

  def self.style_tag(csp_nonce); end
end

module BetterErrors::ExceptionExtension
  def __better_errors_bindings_stack(); end

  def set_backtrace(*arg); end
end

class BetterErrors::ExceptionHint
  def hint(); end

  def initialize(exception); end
end

class BetterErrors::InspectableValue
  def initialize(value); end

  def to_html(); end
end

class BetterErrors::Middleware
  def call(env); end

  def initialize(app, handler=T.unsafe(nil)); end
  ALLOWED_IPS = ::T.let(nil, ::T.untyped)
  CSRF_TOKEN_COOKIE_NAME = ::T.let(nil, ::T.untyped)
end

class BetterErrors::Middleware
  def self.allow_ip!(addr); end
end

module BetterErrors::REPL
  PROVIDERS = ::T.let(nil, ::T.untyped)
end

module BetterErrors::REPL
  def self.detect(); end

  def self.provider(); end

  def self.provider=(prov); end

  def self.test_provider(provider); end
end

class BetterErrors::Railtie
  def app(); end

  def insert_middleware(); end

  def use_better_errors?(); end
end

class BetterErrors::RaisedException
  def backtrace(); end

  def exception(); end

  def hint(); end

  def initialize(exception); end

  def message(); end

  def type(); end
end

class BetterErrors::StackFrame
  def application?(); end

  def application_path(); end

  def class_name(); end

  def context(); end

  def filename(); end

  def frame_binding(); end

  def gem?(); end

  def gem_path(); end

  def initialize(filename, line, name, frame_binding=T.unsafe(nil)); end

  def line(); end

  def local_variable(name); end

  def method_name(); end

  def name(); end

  def pretty_path(); end

  def visible_instance_variables(); end
end

class BetterErrors::StackFrame
  def self.from_exception(exception); end
end

module BetterErrors
  def self.application_root(); end

  def self.application_root=(application_root); end

  def self.binding_of_caller_available(); end

  def self.binding_of_caller_available=(binding_of_caller_available); end

  def self.binding_of_caller_available?(); end

  def self.default_editor(); end

  def self.editor(); end

  def self.editor=(editor); end

  def self.ignored_classes(); end

  def self.ignored_classes=(ignored_classes); end

  def self.ignored_instance_variables(); end

  def self.ignored_instance_variables=(ignored_instance_variables); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.maximum_variable_inspect_size(); end

  def self.maximum_variable_inspect_size=(maximum_variable_inspect_size); end

  def self.use_pry!(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  VERSION = ::T.let(nil, ::T.untyped)
end

Bindex = Skiptrace

class Binding
  def b(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end

  def break(pre: T.unsafe(nil), do: T.unsafe(nil), up_level: T.unsafe(nil)); end

  def clone(); end

  def console(); end

  def irb(show_code: T.unsafe(nil)); end
end

module BindingOfCaller
  VERSION = ::T.let(nil, ::T.untyped)
end

module BindingOfCaller::BindingExtensions
  def callers(); end

  def frame_count(); end

  def frame_description(); end

  def frame_type(); end

  def of_caller(n); end
end

class Book
  include ::Book::GeneratedAttributeMethods
  include ::Book::GeneratedAssociationMethods
end

module Book::GeneratedAssociationMethods
end

module Book::GeneratedAssociationMethods
end

module Book::GeneratedAttributeMethods
end

module Book::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Bootsnap
  VERSION = ::T.let(nil, ::T.untyped)
end

module Bootsnap::CompileCache
  UNCOMPILABLE = ::T.let(nil, ::T.untyped)
end

module Bootsnap::CompileCache::YAML
  SUPPORTED_INTERNAL_ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Bootsnap::ExplicitRequire
  ARCHDIR = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  RUBYLIBDIR = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache
  CACHED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  DLEXT2 = ::T.let(nil, ::T.untyped)
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DOT_RB = ::T.let(nil, ::T.untyped)
  DOT_SO = ::T.let(nil, ::T.untyped)
  FALLBACK_SCAN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Cache
  AGE_THRESHOLD = ::T.let(nil, ::T.untyped)
  BUILTIN_FEATURES = ::T.let(nil, ::T.untyped)
  TRUFFLERUBY_LIB_DIR_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Path
  RUBY_LIBDIR = ::T.let(nil, ::T.untyped)
  RUBY_SITEDIR = ::T.let(nil, ::T.untyped)
  STABLE = ::T.let(nil, ::T.untyped)
  VOLATILE = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache::PathScanner
  ALTERNATIVE_NATIVE_EXTENSIONS_PATTERN = ::T.let(nil, ::T.untyped)
  BUNDLE_PATH = ::T.let(nil, ::T.untyped)
  NORMALIZE_NATIVE_EXTENSIONS = ::T.let(nil, ::T.untyped)
  REQUIRABLE_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Store
  CURRENT_VERSION = ::T.let(nil, ::T.untyped)
  VERSION_KEY = ::T.let(nil, ::T.untyped)
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

module Bundler::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Bundler::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Bundler::Checksum
  def ==(other); end

  def algo(); end

  def digest(); end

  def eql?(other); end

  def formatted_sources(); end

  def initialize(algo, digest, source); end

  def match?(other); end

  def merge!(other); end

  def removable?(); end

  def removal_instructions(); end

  def same_source?(other); end

  def sources(); end

  def to_lock(); end
  ALGO_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Bundler::Checksum::Source
  def ==(other); end

  def initialize(type, location); end

  def location(); end

  def removable?(); end

  def removal(); end

  def type(); end
end

class Bundler::Checksum::Source
end

class Bundler::Checksum::Store
  def merge!(other); end

  def register(spec, checksum); end

  def replace(spec, checksum); end

  def store(); end

  def to_lock(spec); end
end

class Bundler::Checksum::Store
end

class Bundler::Checksum
  def self.from_api(digest, source_uri, algo=T.unsafe(nil)); end

  def self.from_gem(io, pathname, algo=T.unsafe(nil)); end

  def self.from_gem_package(gem_package, algo=T.unsafe(nil)); end

  def self.from_lock(lock_checksum, lockfile_location); end

  def self.to_hexdigest(digest, algo=T.unsafe(nil)); end
end

class Bundler::ChecksumMismatchError
  def initialize(lock_name, existing, checksum); end

  def mismatch_resolution_instructions(); end
end

class Bundler::ChecksumMismatchError
end

class Bundler::ConnectionPool
  def auto_reload_after_fork(); end

  def available(); end

  def checkin(force: T.unsafe(nil)); end

  def checkout(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def reload(&block); end

  def shutdown(&block); end

  def size(); end

  def then(options=T.unsafe(nil)); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def empty?(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def shutdown(reload: T.unsafe(nil), &block); end
end

class Bundler::ConnectionPool::TimedStack
end

class Bundler::ConnectionPool
  def self.after_fork(); end

  def self.wrap(options, &block); end
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_32?(); end

  def jruby_33?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_32?(); end

  def maglev_33?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_31?(); end

  def mingw_32?(); end

  def mingw_33?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_31?(); end

  def mri_32?(); end

  def mri_33?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_31?(); end

  def mswin64_32?(); end

  def mswin64_33?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_31?(); end

  def mswin_32?(); end

  def mswin_33?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_31?(); end

  def on_32?(); end

  def on_33?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_32?(); end

  def rbx_33?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_31?(); end

  def ruby_32?(); end

  def ruby_33?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_32?(); end

  def truffleruby_33?(); end

  def truffleruby_3?(); end

  def windows?(); end

  def windows_18?(); end

  def windows_19?(); end

  def windows_1?(); end

  def windows_20?(); end

  def windows_21?(); end

  def windows_22?(); end

  def windows_23?(); end

  def windows_24?(); end

  def windows_25?(); end

  def windows_26?(); end

  def windows_27?(); end

  def windows_2?(); end

  def windows_30?(); end

  def windows_31?(); end

  def windows_32?(); end

  def windows_33?(); end

  def windows_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_31?(); end

  def x64_mingw_32?(); end

  def x64_mingw_33?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def bundler_version_to_lock(); end

  def current_locked_dependencies(); end

  def deleted_deps(); end

  def dependencies_for(groups); end

  def filter_relevant(dependencies); end

  def locked_checksums(); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def new_deps(); end

  def no_resolve_needed?(); end

  def requested_dependencies(); end

  def resolution_mode=(options); end

  def resolve_only_locally!(); end

  def setup_sources_for_resolve(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def gemspec_dev_dep?(); end

  def git(); end

  def github(); end

  def path(); end

  def ref(); end
  ALL_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::DirectoryRemovalError
  def initialize(orig_exception, msg); end

  def status_code(); end
end

class Bundler::DirectoryRemovalError
end

class Bundler::Dsl
  def check_primary_source_safety(); end

  def gemfile(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
  GITLAB_MERGE_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::FetchMetadata
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

module Bundler::FetchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::FetchMetadata
end

class Bundler::Fetcher
  def api_fetcher?(); end

  def fetch_spec(spec); end

  def gem_remote_fetcher(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationForbiddenError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationForbiddenError
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def gem_remote_fetcher(); end

  def initialize(downloader, remote, display_uri, gem_remote_fetcher); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Bundler::ForcePlatform
end

module Bundler::ForcePlatform
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_checksum(built_gem_path=T.unsafe(nil)); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.force_ruby_platform(specs); end

  def self.generic_local_platform_is_ruby?(); end

  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end

  def self.sort_best_platform_match(matching, platform); end
end

class Bundler::GemVersionPromoter
  def filter_versions(package, specs); end

  def level(); end

  def level=(value); end

  def major?(); end

  def minor?(); end

  def pre(); end

  def pre=(pre); end

  def pre?(); end

  def sort_versions(package, specs); end

  def strict(); end

  def strict=(strict); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
  def add(spec); end

  def duplicates(); end

  def merge!(other); end

  def subset?(other); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InsecureInstallPathError
  def initialize(path); end

  def status_code(); end
end

class Bundler::InsecureInstallPathError
end

class Bundler::Installer
  def definition(); end
end

class Bundler::LazySpecification
  include ::Bundler::ForcePlatform
  def dependencies=(dependencies); end

  def eql?(other); end

  def force_ruby_platform(); end

  def force_ruby_platform!(); end

  def force_ruby_platform=(force_ruby_platform); end

  def lock_name(); end

  def materialize_for_installation(); end

  def name_tuple(); end

  def required_ruby_version(); end

  def required_ruby_version=(required_ruby_version); end

  def required_rubygems_version(); end

  def required_rubygems_version=(required_rubygems_version); end

  def runtime_dependencies(); end
end

class Bundler::LazySpecification
  def self.from_spec(s); end
end

class Bundler::LockfileParser
  def checksums(); end

  def may_include_redundant_platform_specific_gems?(); end
  CHECKSUMS = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser::Position
  def advance!(string); end

  def column(); end

  def initialize(line, column); end

  def line(); end
end

class Bundler::LockfileParser::Position
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::MatchMetadata
  def matches_current_metadata?(); end

  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::MatchMetadata
end

module Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

module Bundler::MatchRemoteMetadata
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def checksum_store(); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_in_plugin_root?(name); end

  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Path
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Path
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.from_lock(locked_opts); end

  def self.list(); end

  def self.loaded?(plugin); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::PubGrub::Incompatibility
  def cause(); end

  def conflict?(); end

  def eql?(other); end

  def external_incompatibilities(); end

  def failure?(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil)); end

  def terms(); end
end

class Bundler::PubGrub::Incompatibility
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
  def runtime_dependencies(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def all_versions_for(package); end

  def bundler_pinned_to_current_version?(); end

  def default_bundler_source(); end

  def find_names_to_relax(incompatibility); end

  def incompatibilities_for(package, version); end

  def no_versions_incompatibility_for(package, unsatisfied_term); end

  def parse_dependency(package, dependency); end

  def raise_not_found!(package); end

  def setup_solver(); end

  def solve_versions(root:, logger:); end

  def source_for(name); end

  def versions_for(package, range=T.unsafe(nil)); end
end

class Bundler::Resolver::Base
  def [](name); end

  def base_requirements(); end

  def delete(specs); end

  def get_package(name); end

  def include_prereleases(names); end

  def initialize(source_requirements, dependencies, base, platforms, options); end

  def packages(); end

  def requirements(); end

  def source_requirements(); end

  def unlock_names(names); end
end

class Bundler::Resolver::Base
end

class Bundler::Resolver::Candidate
  include ::Comparable
  def ==(other); end

  def dependencies(); end

  def eql?(other); end

  def generic!(); end

  def initialize(version, specs: T.unsafe(nil)); end

  def platform_specific!(); end

  def prerelease?(); end

  def segments(); end

  def sort_obj(); end

  def to_specs(package); end

  def version(); end
end

class Bundler::Resolver::Candidate
end

class Bundler::Resolver::Incompatibility
  def extended_explanation(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil), extended_explanation: T.unsafe(nil)); end
end

class Bundler::Resolver::Incompatibility
end

class Bundler::Resolver::Package
  def ==(other); end

  def consider_prereleases!(); end

  def current_platform?(); end

  def dependency(); end

  def force_ruby_platform?(); end

  def ignores_prereleases?(); end

  def initialize(name, platforms, locked_specs:, unlock:, prerelease: T.unsafe(nil), dependency: T.unsafe(nil)); end

  def locked_version(); end

  def meta?(); end

  def name(); end

  def platforms(); end

  def prerelease_specified?(); end

  def root?(); end

  def top_level?(); end

  def unlock?(); end
end

class Bundler::Resolver::Package
end

class Bundler::Resolver::Root
  def initialize(name); end
end

class Bundler::Resolver::Root
end

class Bundler::Resolver::SpecGroup
  def dependencies(); end

  def empty?(); end

  def sorted_spec_names(); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def normalize_ruby_file(filename); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def all_specs(); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

module Bundler::SafeMarshal
  ALLOWED_CLASSES = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  PROC = ::T.let(nil, ::T.untyped)
end

module Bundler::SafeMarshal
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  REMEMBERED_KEYS = ::T.let(nil, ::T.untyped)
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end

  def self.key_to_s(key); end
end

module Bundler::SharedHelpers
  def bundle_bin_path(); end

  def checksum_for_file(path, digest); end

  def relative_gemfile_path(); end

  def relative_lockfile_path(); end

  def relative_path_to(destination, from: T.unsafe(nil)); end
end

class Bundler::SolveFailure
  def status_code(); end
end

class Bundler::SolveFailure
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def checksum_store(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def current_branch(); end

  def glob(); end

  def local?(); end

  def to_gemfile(); end

  def uri_with_specifiers(specifiers); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def dependency_api_available?(); end

  def fetch_gem_if_possible(spec, previous_spec=T.unsafe(nil)); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def package_path(cache_path, spec); end

  def remote_fetchers(); end

  def remote_names(); end

  def to_gemfile(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def -(other); end

  def add_extra_platforms!(platforms); end

  def complete_platforms!(platforms); end

  def delete(specs); end

  def delete_by_name(name); end

  def incomplete_for_platform?(deps, platform); end

  def incomplete_specs(); end

  def missing_specs(); end

  def names(); end

  def validate_deps(s); end
end

class Bundler::StubSpecification
  def checksum(); end

  def extensions(); end

  def full_gem_path=(path); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def content(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def replacement_present?(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def enum_to_s(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def print_default(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*arg); end

  def attr_reader(*arg); end

  def attr_writer(*arg); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def built_option_names(target, opt=T.unsafe(nil), &block); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_at_least_one(*args, &block); end

  def class_at_least_one_option_names(); end

  def class_exclusive(*args, &block); end

  def class_exclusive_option_names(); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def command_scope_member(name, options=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def register_options_relation_for(target, relation, *args, &block); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, wrap_long_description, usage, options=T.unsafe(nil), options_relation=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def slice(*keys); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def aliases_for_usage(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_at_least_one!(); end

  def check_exclusive!(); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil), relations=T.unsafe(nil)); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(block_given); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_error(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *arg); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::ColumnPrinter
  def initialize(stdout, options=T.unsafe(nil)); end

  def options(); end

  def print(array); end

  def stdout(); end
end

class Bundler::Thor::Shell::ColumnPrinter
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

class Bundler::Thor::Shell::TablePrinter
  BORDER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::TablePrinter
end

module Bundler::Thor::Shell::Terminal
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Shell::Terminal
  def self.terminal_width(); end

  def self.unix?(); end
end

class Bundler::Thor::Shell::WrappedPrinter
  def print(message); end
end

class Bundler::Thor::Shell::WrappedPrinter
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.at_least_one(*args, &block); end

  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.exclusive(*args, &block); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.sort_commands!(list); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def confirm?(); end

  def debug(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def error?(); end

  def info(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def info?(); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def warn?(); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def confirm?(); end

  def error?(); end

  def info?(); end

  def warn?(); end
end

module Bundler::URINormalizer
end

module Bundler::URINormalizer
  def self.normalize_suffix(uri, trailing_slash: T.unsafe(nil)); end
end

module Bundler
  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.create_bundle_path(); end

  def self.gem_version(); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.safe_load_marshal(data); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module Byebug
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BreakCommand
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(arg, arg1, arg2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CatchCommand
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, **arg, &block); end

  def context(); end

  def errmsg(*args, **arg, &block); end

  def frame(); end

  def help(*args, **arg, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, **arg, &block); end

  def pr(*args, **arg, &block); end

  def prc(*args, **arg, &block); end

  def print(*args, **arg, &block); end

  def processor(); end

  def prv(*args, **arg, &block); end

  def puts(*args, **arg, &block); end
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandProcessor
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, **arg, &block); end

  def confirm(*args, **arg, &block); end

  def context(); end

  def errmsg(*args, **arg, &block); end

  def frame(*args, **arg, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, **arg, &block); end

  def prc(*args, **arg, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, **arg, &block); end

  def puts(*args, **arg, &block); end

  def repl(); end
end

class Byebug::ConditionCommand
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, **arg, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*arg); end

  def frame_class(*arg); end

  def frame_file(*arg); end

  def frame_line(*arg); end

  def frame_method(*arg); end

  def frame_self(*arg); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, **arg, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*arg); end

  def step_out(*arg); end

  def step_over(*arg); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::DebugCommand
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
  def self.inherited(); end
end

class Byebug::DeleteCommand
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::FrameCommand
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ToggleHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::VarHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::HistoryCommand
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::ListCommand
  def amend_final(*args, **arg, &block); end

  def execute(); end

  def max_line(*args, **arg, &block); end

  def size(*args, **arg, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end

  def without_readline_completion(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::MethodCommand
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PryProcessor
  def at_breakpoint(breakpoint); end

  def at_return(_return_value); end

  def bold(*args, **arg, &block); end

  def output(*args, **arg, &block); end

  def perform(action, options=T.unsafe(nil)); end

  def pry(); end

  def pry=(pry); end

  def run(&_block); end
end

class Byebug::PryProcessor
  def self.start(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RestartCommand
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end

  def readline(*arg); end
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::SetCommand
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SkipCommand
  def auto_run(); end

  def execute(); end

  def initialize_attributes(); end

  def keep_execution(); end

  def reset_attributes(); end
end

class Byebug::SkipCommand
  def self.description(); end

  def self.file_line(); end

  def self.file_line=(file_line); end

  def self.file_path(); end

  def self.file_path=(file_path); end

  def self.previous_autolist(); end

  def self.regexp(); end

  def self.restore_autolist(); end

  def self.setup_autolist(value); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StepCommand
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, **arg, &block); end
end

module Byebug::Subcommands::ClassMethods
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands
  def self.included(command); end
end

class Byebug::ThreadCommand::CurrentCommand
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::AllCommand
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Byebug
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

class CGI
  VERSION = ::T.let(nil, ::T.untyped)
end

class CGI::Cookie
  DOMAIN_VALUE_RE = ::T.let(nil, ::T.untyped)
  PATH_VALUE_RE = ::T.let(nil, ::T.untyped)
  TOKEN_RE = ::T.let(nil, ::T.untyped)
end

module CGI::Escape
  def escapeURIComponent(arg); end

  def escape_uri_component(arg); end

  def unescapeURIComponent(*arg); end

  def unescape_uri_component(*arg); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module CGI::Util
  def escapeURIComponent(arg); end

  def escape_uri_component(arg); end

  def unescapeURIComponent(*arg); end

  def unescape_uri_component(*arg); end
end

class CSV
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::Parser
  SCANNER_TEST = ::T.let(nil, ::T.untyped)
  STRING_SCANNER_SCAN_ACCEPT_STRING = ::T.let(nil, ::T.untyped)
end

module Capybara
  VERSION = ::T.let(nil, ::T.untyped)
end

class Capybara::Config
  def allow_gumbo(); end

  def allow_gumbo=(val); end

  def always_include_port(*args, **arg, &block); end

  def always_include_port=(*args, **arg, &block); end

  def app(); end

  def app=(app); end

  def app_host(*args, **arg, &block); end

  def app_host=(*args, **arg, &block); end

  def asset_host(*args, **arg, &block); end

  def asset_host=(*args, **arg, &block); end

  def automatic_label_click(*args, **arg, &block); end

  def automatic_label_click=(*args, **arg, &block); end

  def automatic_reload(*args, **arg, &block); end

  def automatic_reload=(*args, **arg, &block); end

  def default_driver(); end

  def default_driver=(default_driver); end

  def default_host(*args, **arg, &block); end

  def default_host=(*args, **arg, &block); end

  def default_max_wait_time(*args, **arg, &block); end

  def default_max_wait_time=(*args, **arg, &block); end

  def default_normalize_ws(*args, **arg, &block); end

  def default_normalize_ws=(*args, **arg, &block); end

  def default_retry_interval(*args, **arg, &block); end

  def default_retry_interval=(*args, **arg, &block); end

  def default_selector(*args, **arg, &block); end

  def default_selector=(*args, **arg, &block); end

  def default_set_options(*args, **arg, &block); end

  def default_set_options=(*args, **arg, &block); end

  def deprecate(method, alternate_method, once: T.unsafe(nil)); end

  def disable_animation(*args, **arg, &block); end

  def disable_animation=(*args, **arg, &block); end

  def enable_aria_label(*args, **arg, &block); end

  def enable_aria_label=(*args, **arg, &block); end

  def enable_aria_role(*args, **arg, &block); end

  def enable_aria_role=(*args, **arg, &block); end

  def exact(*args, **arg, &block); end

  def exact=(*args, **arg, &block); end

  def exact_text(*args, **arg, &block); end

  def exact_text=(*args, **arg, &block); end

  def ignore_hidden_elements(*args, **arg, &block); end

  def ignore_hidden_elements=(*args, **arg, &block); end

  def javascript_driver(); end

  def javascript_driver=(javascript_driver); end

  def match(*args, **arg, &block); end

  def match=(*args, **arg, &block); end

  def predicates_wait(*args, **arg, &block); end

  def predicates_wait=(*args, **arg, &block); end

  def raise_server_errors(*args, **arg, &block); end

  def raise_server_errors=(*args, **arg, &block); end

  def reuse_server(); end

  def reuse_server=(reuse_server); end

  def run_server(*args, **arg, &block); end

  def run_server=(*args, **arg, &block); end

  def save_path(*args, **arg, &block); end

  def save_path=(*args, **arg, &block); end

  def server(); end

  def server=(name); end

  def server_errors(*args, **arg, &block); end

  def server_errors=(*args, **arg, &block); end

  def server_host(*args, **arg, &block); end

  def server_host=(*args, **arg, &block); end

  def server_port(*args, **arg, &block); end

  def server_port=(*args, **arg, &block); end

  def session_options(); end

  def test_id(*args, **arg, &block); end

  def test_id=(*args, **arg, &block); end

  def threadsafe(); end

  def threadsafe=(bool); end

  def use_html5_parsing(); end

  def use_html5_parsing=(use_html5_parsing); end

  def visible_text_only(*args, **arg, &block); end

  def visible_text_only=(*args, **arg, &block); end

  def w3c_click_offset(*args, **arg, &block); end

  def w3c_click_offset=(*args, **arg, &block); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::DSL
  def accept_alert(*arg, **arg1, &arg2); end

  def accept_confirm(*arg, **arg1, &arg2); end

  def accept_prompt(*arg, **arg1, &arg2); end

  def all(*arg, **arg1, &arg2); end

  def assert_all_of_selectors(*arg, **arg1, &arg2); end

  def assert_any_of_selectors(*arg, **arg1, &arg2); end

  def assert_current_path(*arg, **arg1, &arg2); end

  def assert_no_current_path(*arg, **arg1, &arg2); end

  def assert_no_selector(*arg, **arg1, &arg2); end

  def assert_no_text(*arg, **arg1, &arg2); end

  def assert_no_title(*arg, **arg1, &arg2); end

  def assert_none_of_selectors(*arg, **arg1, &arg2); end

  def assert_selector(*arg, **arg1, &arg2); end

  def assert_text(*arg, **arg1, &arg2); end

  def assert_title(*arg, **arg1, &arg2); end

  def attach_file(*arg, **arg1, &arg2); end

  def body(*arg, **arg1, &arg2); end

  def check(*arg, **arg1, &arg2); end

  def choose(*arg, **arg1, &arg2); end

  def click(*arg, **arg1, &arg2); end

  def click_button(*arg, **arg1, &arg2); end

  def click_link(*arg, **arg1, &arg2); end

  def click_link_or_button(*arg, **arg1, &arg2); end

  def click_on(*arg, **arg1, &arg2); end

  def current_host(*arg, **arg1, &arg2); end

  def current_path(*arg, **arg1, &arg2); end

  def current_scope(*arg, **arg1, &arg2); end

  def current_url(*arg, **arg1, &arg2); end

  def current_window(*arg, **arg1, &arg2); end

  def dismiss_confirm(*arg, **arg1, &arg2); end

  def dismiss_prompt(*arg, **arg1, &arg2); end

  def double_click(*arg, **arg1, &arg2); end

  def evaluate_async_script(*arg, **arg1, &arg2); end

  def evaluate_script(*arg, **arg1, &arg2); end

  def execute_script(*arg, **arg1, &arg2); end

  def fill_in(*arg, **arg1, &arg2); end

  def find(*arg, **arg1, &arg2); end

  def find_all(*arg, **arg1, &arg2); end

  def find_button(*arg, **arg1, &arg2); end

  def find_by_id(*arg, **arg1, &arg2); end

  def find_field(*arg, **arg1, &arg2); end

  def find_link(*arg, **arg1, &arg2); end

  def first(*arg, **arg1, &arg2); end

  def go_back(*arg, **arg1, &arg2); end

  def go_forward(*arg, **arg1, &arg2); end

  def has_button?(*arg, **arg1, &arg2); end

  def has_checked_field?(*arg, **arg1, &arg2); end

  def has_content?(*arg, **arg1, &arg2); end

  def has_css?(*arg, **arg1, &arg2); end

  def has_current_path?(*arg, **arg1, &arg2); end

  def has_element?(*arg, **arg1, &arg2); end

  def has_field?(*arg, **arg1, &arg2); end

  def has_link?(*arg, **arg1, &arg2); end

  def has_no_button?(*arg, **arg1, &arg2); end

  def has_no_checked_field?(*arg, **arg1, &arg2); end

  def has_no_content?(*arg, **arg1, &arg2); end

  def has_no_css?(*arg, **arg1, &arg2); end

  def has_no_current_path?(*arg, **arg1, &arg2); end

  def has_no_element?(*arg, **arg1, &arg2); end

  def has_no_field?(*arg, **arg1, &arg2); end

  def has_no_link?(*arg, **arg1, &arg2); end

  def has_no_select?(*arg, **arg1, &arg2); end

  def has_no_selector?(*arg, **arg1, &arg2); end

  def has_no_table?(*arg, **arg1, &arg2); end

  def has_no_text?(*arg, **arg1, &arg2); end

  def has_no_title?(*arg, **arg1, &arg2); end

  def has_no_unchecked_field?(*arg, **arg1, &arg2); end

  def has_no_xpath?(*arg, **arg1, &arg2); end

  def has_select?(*arg, **arg1, &arg2); end

  def has_selector?(*arg, **arg1, &arg2); end

  def has_table?(*arg, **arg1, &arg2); end

  def has_text?(*arg, **arg1, &arg2); end

  def has_title?(*arg, **arg1, &arg2); end

  def has_unchecked_field?(*arg, **arg1, &arg2); end

  def has_xpath?(*arg, **arg1, &arg2); end

  def html(*arg, **arg1, &arg2); end

  def open_new_window(*arg, **arg1, &arg2); end

  def page(); end

  def query(*arg, **arg1, &arg2); end

  def refresh(*arg, **arg1, &arg2); end

  def refute_selector(*arg, **arg1, &arg2); end

  def reset_session!(*arg, **arg1, &arg2); end

  def response_headers(*arg, **arg1, &arg2); end

  def right_click(*arg, **arg1, &arg2); end

  def save_and_open_page(*arg, **arg1, &arg2); end

  def save_and_open_screenshot(*arg, **arg1, &arg2); end

  def save_page(*arg, **arg1, &arg2); end

  def save_screenshot(*arg, **arg1, &arg2); end

  def scroll_by(*arg, **arg1, &arg2); end

  def scroll_to(*arg, **arg1, &arg2); end

  def select(*arg, **arg1, &arg2); end

  def send_keys(*arg, **arg1, &arg2); end

  def source(*arg, **arg1, &arg2); end

  def status_code(*arg, **arg1, &arg2); end

  def switch_to_frame(*arg, **arg1, &arg2); end

  def switch_to_window(*arg, **arg1, &arg2); end

  def text(*arg, **arg1, &arg2); end

  def title(*arg, **arg1, &arg2); end

  def uncheck(*arg, **arg1, &arg2); end

  def unselect(*arg, **arg1, &arg2); end

  def using_session(name_or_session, &block); end

  def using_wait_time(seconds, &block); end

  def visit(*arg, **arg1, &arg2); end

  def window_opened_by(*arg, **arg1, &arg2); end

  def windows(*arg, **arg1, &arg2); end

  def within(*arg, **arg1, &arg2); end

  def within_element(*arg, **arg1, &arg2); end

  def within_fieldset(*arg, **arg1, &arg2); end

  def within_frame(*arg, **arg1, &arg2); end

  def within_table(*arg, **arg1, &arg2); end

  def within_window(*arg, **arg1, &arg2); end
end

module Capybara::DSL
  def self.extended(base); end

  def self.included(base); end
end

class Capybara::Driver::Base
  def accept_modal(type, **options, &blk); end

  def active_element(); end

  def close_window(handle); end

  def current_url(); end

  def current_window_handle(); end

  def dismiss_modal(type, **options, &blk); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def find_css(query, **options); end

  def find_xpath(query, **options); end

  def frame_title(); end

  def frame_url(); end

  def fullscreen_window(handle); end

  def go_back(); end

  def go_forward(); end

  def html(); end

  def invalid_element_errors(); end

  def maximize_window(handle); end

  def needs_server?(); end

  def no_such_window_error(); end

  def open_new_window(); end

  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def response_headers(); end

  def save_screenshot(path, **options); end

  def send_keys(*arg); end

  def session=(session); end

  def session_options(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(handle); end

  def visit(path); end

  def wait?(); end

  def window_handles(); end

  def window_size(handle); end
end

class Capybara::Driver::Node
  def ==(other); end

  def [](name); end

  def all_text(); end

  def checked?(); end

  def click(keys=T.unsafe(nil), **options); end

  def disabled?(); end

  def double_click(keys=T.unsafe(nil), **options); end

  def drag_to(element, **options); end

  def driver(); end

  def drop(*args); end

  def hover(); end

  def initial_cache(); end

  def initialize(driver, native, initial_cache=T.unsafe(nil)); end

  def multiple?(); end

  def native(); end

  def obscured?(); end

  def path(); end

  def readonly?(); end

  def rect(); end

  def right_click(keys=T.unsafe(nil), **options); end

  def scroll_by(x, y); end

  def scroll_to(element, alignment, position=T.unsafe(nil)); end

  def select_option(); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def shadow_root(); end

  def style(styles); end

  def tag_name(); end

  def trigger(event); end

  def unselect_option(); end

  def value(); end

  def visible?(); end

  def visible_text(); end
end

class Capybara::Helpers::Timer
  def expired?(); end

  def initialize(expire_in); end

  def stalled?(); end
end

module Capybara::Helpers
  def self.declension(singular, plural, count); end

  def self.filter_backtrace(trace); end

  def self.inject_asset_host(html, host: T.unsafe(nil)); end

  def self.monotonic_time(); end

  def self.normalize_whitespace(text); end

  def self.timer(expire_in:); end

  def self.to_regexp(text, exact: T.unsafe(nil), all_whitespace: T.unsafe(nil), options: T.unsafe(nil)); end

  def self.warn(message, uplevel: T.unsafe(nil)); end
end

module Capybara::Minitest
end

module Capybara::Minitest::Assertions
  def assert_all_of_selectors(*args, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, &optional_filter_block); end

  def assert_button(*args, &optional_filter_block); end

  def assert_checked_field(*args, &optional_filter_block); end

  def assert_content(*args, **kwargs, &optional_filter_block); end

  def assert_css(*args, &optional_filter_block); end

  def assert_current_path(*args, **kwargs, &optional_filter_block); end

  def assert_element(*args, &optional_filter_block); end

  def assert_field(*args, &optional_filter_block); end

  def assert_link(*args, &optional_filter_block); end

  def assert_matches_css(*args, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(*args, &optional_filter_block); end

  def assert_matches_xpath(*args, &optional_filter_block); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_button(*args, &optional_filter_block); end

  def assert_no_checked_field(*args, &optional_filter_block); end

  def assert_no_content(*args, **kwargs, &optional_filter_block); end

  def assert_no_css(*args, &optional_filter_block); end

  def assert_no_current_path(*args, **kwargs, &optional_filter_block); end

  def assert_no_element(*args, &optional_filter_block); end

  def assert_no_field(*args, &optional_filter_block); end

  def assert_no_link(*args, &optional_filter_block); end

  def assert_no_select(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_table(*args, &optional_filter_block); end

  def assert_no_text(*args, **kwargs, &optional_filter_block); end

  def assert_no_title(*args, **kwargs, &optional_filter_block); end

  def assert_no_unchecked_field(*args, &optional_filter_block); end

  def assert_no_xpath(*args, &optional_filter_block); end

  def assert_none_of_selectors(*args, &optional_filter_block); end

  def assert_not_matches_css(*args, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_not_matches_xpath(*args, &optional_filter_block); end

  def assert_select(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_table(*args, &optional_filter_block); end

  def assert_text(*args, **kwargs, &optional_filter_block); end

  def assert_title(*args, **kwargs, &optional_filter_block); end

  def assert_unchecked_field(*args, &optional_filter_block); end

  def assert_xpath(*args, &optional_filter_block); end

  def refute_ancestor(*args, &optional_filter_block); end

  def refute_button(*args, &optional_filter_block); end

  def refute_checked_field(*args, &optional_filter_block); end

  def refute_content(*args, **kwargs, &optional_filter_block); end

  def refute_css(*args, &optional_filter_block); end

  def refute_current_path(*args, **kwargs, &optional_filter_block); end

  def refute_element(*args, &optional_filter_block); end

  def refute_field(*args, &optional_filter_block); end

  def refute_link(*args, &optional_filter_block); end

  def refute_matches_css(*args, &optional_filter_block); end

  def refute_matches_selector(*args, &optional_filter_block); end

  def refute_matches_xpath(*args, &optional_filter_block); end

  def refute_select(*args, &optional_filter_block); end

  def refute_selector(*args, &optional_filter_block); end

  def refute_sibling(*args, &optional_filter_block); end

  def refute_table(*args, &optional_filter_block); end

  def refute_text(*args, **kwargs, &optional_filter_block); end

  def refute_title(*args, **kwargs, &optional_filter_block); end

  def refute_unchecked_field(*args, &optional_filter_block); end

  def refute_xpath(*args, &optional_filter_block); end
end

module Capybara::Minitest::Assertions
end

module Capybara::Minitest
end

module Capybara::Node::Actions
  def attach_file(locator=T.unsafe(nil), paths, make_visible: T.unsafe(nil), **options); end

  def check(locator=T.unsafe(nil), **options); end

  def choose(locator=T.unsafe(nil), **options); end

  def click_button(locator=T.unsafe(nil), **options); end

  def click_link(locator=T.unsafe(nil), **options); end

  def click_link_or_button(locator=T.unsafe(nil), **options); end

  def click_on(locator=T.unsafe(nil), **options); end

  def fill_in(locator=T.unsafe(nil), with:, currently_with: T.unsafe(nil), fill_options: T.unsafe(nil), **find_options); end

  def select(value=T.unsafe(nil), from: T.unsafe(nil), **options); end

  def uncheck(locator=T.unsafe(nil), **options); end

  def unselect(value=T.unsafe(nil), from: T.unsafe(nil), **options); end
  CAPTURE_FILE_ELEMENT_SCRIPT = ::T.let(nil, ::T.untyped)
  DATALIST_OPTIONS_SCRIPT = ::T.let(nil, ::T.untyped)
  RESET_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
  UPDATE_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Base
  def base(); end

  def catch_error?(error, errors=T.unsafe(nil)); end

  def driver(); end

  def find_css(css, **options); end

  def find_xpath(xpath, **options); end

  def initialize(session, base); end

  def query_scope(); end

  def reload(); end

  def session(); end

  def session_options(); end

  def synchronize(seconds=T.unsafe(nil), errors: T.unsafe(nil)); end

  def to_capybara_node(); end
end

class Capybara::Node::Document
  def evaluate_script(*args); end

  def execute_script(*args); end

  def scroll_to(*args, quirks: T.unsafe(nil), **options); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end
end

module Capybara::Node::DocumentMatchers
  def assert_no_title(title, **options); end

  def assert_title(title, **options); end

  def has_no_title?(title, **options); end

  def has_title?(title, **options); end
end

class Capybara::Node::Element
  def [](attribute); end

  def allow_reload!(idx=T.unsafe(nil)); end

  def checked?(); end

  def click(*keys, **options); end

  def disabled?(); end

  def double_click(*keys, **options); end

  def drag_to(node, **options); end

  def drop(*args); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def flash(); end

  def hover(); end

  def initial_cache(); end

  def initialize(session, base, query_scope, query); end

  def multiple?(); end

  def native(); end

  def obscured?(); end

  def path(); end

  def readonly?(); end

  def rect(); end

  def right_click(*keys, **options); end

  def scroll_to(pos_or_el_or_x, y=T.unsafe(nil), align: T.unsafe(nil), offset: T.unsafe(nil)); end

  def select_option(wait: T.unsafe(nil)); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def shadow_root(); end

  def style(*styles); end

  def tag_name(); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def trigger(event); end

  def unselect_option(wait: T.unsafe(nil)); end

  def value(); end

  def visible?(); end
  STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

module Capybara::Node::Finders
  def all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  def ancestor(*args, **options, &optional_filter_block); end

  def find(*args, **options, &optional_filter_block); end

  def find_all(*args, allow_reload: T.unsafe(nil), **options, &optional_filter_block); end

  def find_button(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_by_id(id, **options, &optional_filter_block); end

  def find_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_link(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def first(*args, **options, &optional_filter_block); end

  def sibling(*args, **options, &optional_filter_block); end
end

module Capybara::Node::Matchers
  def ==(other); end

  def assert_all_of_selectors(*args, **options, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, wait: T.unsafe(nil), **options, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(styles=T.unsafe(nil), **options); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_text(type_or_text, *args, **opts); end

  def assert_none_of_selectors(*args, **options, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_style(styles=T.unsafe(nil), **options); end

  def assert_text(type_or_text, *args, **opts); end

  def has_ancestor?(*args, **options, &optional_filter_block); end

  def has_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_content?(*args, **options); end

  def has_css?(path, **options, &optional_filter_block); end

  def has_element?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_ancestor?(*args, **options, &optional_filter_block); end

  def has_no_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_content?(*args, **options); end

  def has_no_css?(path, **options, &optional_filter_block); end

  def has_no_element?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_selector?(*args, **options, &optional_filter_block); end

  def has_no_sibling?(*args, **options, &optional_filter_block); end

  def has_no_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_text?(*args, **options); end

  def has_no_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_xpath?(path, **options, &optional_filter_block); end

  def has_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_selector?(*args, **options, &optional_filter_block); end

  def has_sibling?(*args, **options, &optional_filter_block); end

  def has_style?(styles=T.unsafe(nil), **options); end

  def has_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_text?(*args, **options); end

  def has_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_xpath?(path, **options, &optional_filter_block); end

  def matches_css?(css, **options, &optional_filter_block); end

  def matches_selector?(*args, **options, &optional_filter_block); end

  def matches_style?(styles=T.unsafe(nil), **options); end

  def matches_xpath?(xpath, **options, &optional_filter_block); end

  def not_matches_css?(css, **options, &optional_filter_block); end

  def not_matches_selector?(*args, **options, &optional_filter_block); end

  def not_matches_xpath?(xpath, **options, &optional_filter_block); end
end

class Capybara::Node::Simple
  def [](name); end

  def allow_reload!(*arg); end

  def checked?(); end

  def disabled?(); end

  def find_css(css, **_options); end

  def find_xpath(xpath, **_options); end

  def initial_cache(); end

  def initialize(native); end

  def multiple?(); end

  def native(); end

  def path(); end

  def readonly?(); end

  def selected?(); end

  def session_options(); end

  def synchronize(_seconds=T.unsafe(nil)); end

  def tag_name(); end

  def text(_type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end

  def value(); end

  def visible?(check_ancestors=T.unsafe(nil)); end
  VISIBILITY_XPATH = ::T.let(nil, ::T.untyped)
end

module Capybara::Node::WhitespaceNormalizer
  def normalize_spacing(text); end

  def normalize_visible_spacing(text); end
  BREAKING_SPACES = ::T.let(nil, ::T.untyped)
  EMPTY_LINES = ::T.let(nil, ::T.untyped)
  LEADING_SPACES = ::T.let(nil, ::T.untyped)
  LEFT_TO_RIGHT_MARK = ::T.let(nil, ::T.untyped)
  LINE_SEPERATOR = ::T.let(nil, ::T.untyped)
  NON_BREAKING_SPACE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_SEPERATOR = ::T.let(nil, ::T.untyped)
  REMOVED_CHARACTERS = ::T.let(nil, ::T.untyped)
  RIGHT_TO_LEFT_MARK = ::T.let(nil, ::T.untyped)
  SQUEEZED_SPACES = ::T.let(nil, ::T.untyped)
  TRAILING_SPACES = ::T.let(nil, ::T.untyped)
  ZERO_WIDTH_SPACE = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::ActiveElementQuery
  def initialize(**options); end

  def resolve_for(session); end
end

class Capybara::Queries::AncestorQuery
  def description(applied=T.unsafe(nil)); end
end

class Capybara::Queries::BaseQuery
  def expects_none?(); end

  def failure_message(); end

  def initialize(options); end

  def matches_count?(count); end

  def negative_failure_message(); end

  def options(); end

  def session_options(); end

  def session_options=(session_options); end

  def wait(); end
  COUNT_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::BaseQuery
  def self.wait(options, default=T.unsafe(nil)); end
end

class Capybara::Queries::CurrentPathQuery
  def initialize(expected_path, **options, &optional_filter_block); end

  def resolves_for?(session); end
end

class Capybara::Queries::SelectorQuery
  def applied_description(); end

  def css(); end

  def description(only_applied=T.unsafe(nil)); end

  def exact?(); end

  def expression(); end

  def initialize(*args, session_options:, enable_aria_label: T.unsafe(nil), enable_aria_role: T.unsafe(nil), test_id: T.unsafe(nil), selector_format: T.unsafe(nil), order: T.unsafe(nil), **options, &filter_block); end

  def label(); end

  def locator(); end

  def match(); end

  def matches_filters?(node, node_filter_errors=T.unsafe(nil)); end

  def name(); end

  def resolve_for(node, exact=T.unsafe(nil)); end

  def selector(); end

  def supports_exact?(); end

  def visible(); end

  def xpath(exact=T.unsafe(nil)); end
  SPATIAL_KEYS = ::T.let(nil, ::T.untyped)
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_MATCH = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::SiblingQuery
  def description(applied=T.unsafe(nil)); end
end

class Capybara::Queries::StyleQuery
  def initialize(expected_styles, session_options:, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::TextQuery
  def description(); end

  def initialize(type=T.unsafe(nil), expected_text, session_options:, **options); end

  def resolve_for(node); end
end

class Capybara::Queries::TitleQuery
  def initialize(expected_title, **options); end

  def resolves_for?(node); end
end

class Capybara::RackTest::Browser
  def app(); end

  def base_href(); end

  def base_relative_uri_for(uri); end

  def build_rack_mock_session(); end

  def build_uri(path); end

  def current_host(); end

  def current_host=(current_host); end

  def current_url(); end

  def dom(); end

  def driver(); end

  def find(format, selector); end

  def follow(method, path, **attributes); end

  def html(); end

  def initialize(driver); end

  def last_request(); end

  def last_response(); end

  def options(); end

  def process(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def process_and_follow_redirects(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def refresh(); end

  def request_path(); end

  def reset_cache!(); end

  def reset_host!(); end

  def safe_last_request(); end

  def submit(method, path, attributes, content_type: T.unsafe(nil)); end

  def title(); end

  def visit(path, **attributes); end
end

class Capybara::RackTest::CSSHandlers
  include ::DEBUGGER__::TrapInterceptor
  def disabled(list); end

  def enabled(list); end
end

class Capybara::RackTest::Driver
  def app(); end

  def browser(); end

  def delete(*arg, **arg1, &arg2); end

  def dom(); end

  def find_css(selector); end

  def find_xpath(selector); end

  def follow(method, path, **attributes); end

  def follow_redirects?(); end

  def get(*arg, **arg1, &arg2); end

  def header(key, value); end

  def initialize(app, **options); end

  def options(); end

  def post(*arg, **arg1, &arg2); end

  def put(*arg, **arg1, &arg2); end

  def redirect_limit(); end

  def request(); end

  def response(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Form
  def multipart?(); end

  def params(button); end

  def submit(button); end
end

class Capybara::RackTest::Form::NilUploadedFile
  def append_to(_); end

  def initialize(); end

  def read(); end

  def set_encoding(_); end

  def size(); end
end

class Capybara::RackTest::Form::ParamsHash
  def to_params_hash(); end
end

class Capybara::RackTest::Node
  def [](*arg, **arg1, &arg2); end

  def all_text(*arg, **arg1, &arg2); end

  def checkbox?(); end

  def checkbox_or_radio?(field=T.unsafe(nil)); end

  def checked?(*arg, **arg1, &arg2); end

  def click(*arg, **arg1, &arg2); end

  def disabled?(*arg, **arg1, &arg2); end

  def displayed_text(check_ancestor: T.unsafe(nil)); end

  def find_css(*arg, **arg1, &arg2); end

  def find_xpath(*arg, **arg1, &arg2); end

  def input_field?(); end

  def path(*arg, **arg1, &arg2); end

  def radio?(); end

  def range?(); end

  def readonly?(*arg, **arg1, &arg2); end

  def select_option(*arg, **arg1, &arg2); end

  def selected?(*arg, **arg1, &arg2); end

  def set(*arg, **arg1, &arg2); end

  def style(*arg, **arg1, &arg2); end

  def tag_name(*arg, **arg1, &arg2); end

  def text_or_password?(); end

  def textarea?(); end

  def unselect_option(*arg, **arg1, &arg2); end

  def value(*arg, **arg1, &arg2); end

  def visible?(*arg, **arg1, &arg2); end

  def visible_text(*arg, **arg1, &arg2); end
  BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  DISABLED_BY_FIELDSET_XPATH = ::T.let(nil, ::T.untyped)
  OPTION_OWNER_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::ReadOnlySessionConfig
  def always_include_port=(_); end

  def app_host=(_); end

  def asset_host=(_); end

  def automatic_label_click=(_); end

  def automatic_reload=(_); end

  def default_host=(_); end

  def default_max_wait_time=(_); end

  def default_normalize_ws=(_); end

  def default_retry_interval=(_); end

  def default_selector=(_); end

  def default_set_options=(_); end

  def disable_animation=(_); end

  def enable_aria_label=(_); end

  def enable_aria_role=(_); end

  def exact=(_); end

  def exact_text=(_); end

  def ignore_hidden_elements=(_); end

  def match=(_); end

  def predicates_wait=(_); end

  def raise_server_errors=(_); end

  def run_server=(_); end

  def save_path=(_); end

  def server_errors=(_); end

  def server_host=(_); end

  def server_port=(_); end

  def test_id=(_); end

  def visible_text_only=(_); end

  def w3c_click_offset=(_); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::RegistrationContainer
  def [](name); end

  def []=(name, value); end

  def method_missing(method_name, *arg, **arg1, &arg2); end

  def names(); end
end

class Capybara::Result
  def [](*args); end

  def allow_reload!(); end

  def at(*args); end

  def compare_count(); end

  def each(&block); end

  def empty?(); end

  def failure_message(); end

  def index(*arg); end

  def initialize(elements, query); end

  def inspect(*args, **arg, &block); end

  def last(*args, **arg, &block); end

  def length(*args, **arg, &block); end

  def matches_count?(); end

  def negative_failure_message(); end

  def sample(*args, **arg, &block); end

  def size(*args, **arg, &block); end

  def to_ary(*args, **arg, &block); end

  def unfiltered_size(); end

  def values_at(*args, **arg, &block); end
end

class Capybara::Selector
  def add_error(error_msg); end

  def builder(expr=T.unsafe(nil)); end

  def call(locator, **options); end

  def current_format(); end

  def enable_aria_label(); end

  def enable_aria_role(); end

  def errors(); end

  def expression_for(name, locator, config: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def format(); end

  def initialize(definition, config:, format:); end

  def test_id(); end

  def with_filter_errors(errors); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS
  ESCAPE = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS::Splitter
  def split(css); end
end

class Capybara::Selector::CSS
  def self.escape(str); end

  def self.escape_char(char); end

  def self.split(css); end
end

class Capybara::Selector::CSSBuilder
  def add_attribute_conditions(**attributes); end

  def expression(); end

  def initialize(expression); end
end

class Capybara::Selector::Definition
  def css(*allowed_filters, &block); end

  def custom_filters(); end

  def default_format(); end

  def default_visibility(fallback=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe(*args, **arg, &block); end

  def describe_all_expression_filters(**opts); end

  def describe_expression_filters(&block); end

  def describe_node_filters(&block); end

  def description(*args, **arg, &block); end

  def expression_filter(*args, **arg, &block); end

  def expression_filters(); end

  def expressions(); end

  def filter(*args, **arg, &block); end

  def filter_set(name, filters_to_use=T.unsafe(nil)); end

  def initialize(name, locator_type: T.unsafe(nil), raw_locator: T.unsafe(nil), supports_exact: T.unsafe(nil), &block); end

  def label(label=T.unsafe(nil)); end

  def locator_filter(*types, **options, &block); end

  def locator_types(); end

  def match(&block); end

  def match?(locator); end

  def name(); end

  def node_filter(*args, **arg, &block); end

  def node_filters(); end

  def raw_locator?(); end

  def supports_exact?(); end

  def visible(default_visibility=T.unsafe(nil), &block); end

  def xpath(*allowed_filters, &block); end
end

class Capybara::Selector::FilterSet
  def describe(what=T.unsafe(nil), &block); end

  def description(node_filters: T.unsafe(nil), expression_filters: T.unsafe(nil), **options); end

  def descriptions(); end

  def expression_filter(name, *types, **options, &block); end

  def expression_filter_descriptions(); end

  def expression_filters(); end

  def filter(names, *types, **options, &block); end

  def import(name, filters=T.unsafe(nil)); end

  def initialize(name, &block); end

  def node_filter(names, *types, **options, &block); end

  def node_filter_descriptions(); end

  def node_filters(); end

  def undeclared_descriptions(); end
end

class Capybara::Selector::FilterSet
  def self.[](name); end

  def self.add(name, &block); end

  def self.all(); end

  def self.remove(name); end
end

class Capybara::Selector::Filters::Base
  def boolean?(); end

  def default(); end

  def default?(); end

  def format(); end

  def handles_option?(option_name); end

  def initialize(name, matcher, block, **options); end

  def matcher?(); end

  def skip?(value); end
end

class Capybara::Selector::Filters::ExpressionFilter
  def apply_filter(expr, name, value, selector); end
end

class Capybara::Selector::Filters::IdentityExpressionFilter
  def apply_filter(expr, _name, _value, _ctx); end

  def initialize(name); end
end

class Capybara::Selector::Filters::LocatorFilter
  def initialize(block, **options); end

  def matches?(node, value, context=T.unsafe(nil), exact:); end
end

class Capybara::Selector::Filters::NodeFilter
  def matches?(node, name, value, context=T.unsafe(nil)); end
end

class Capybara::Selector::RegexpDisassembler
  def alternated_substrings(); end

  def initialize(regexp); end

  def substrings(); end
end

class Capybara::Selector::XPathBuilder
  def add_attribute_conditions(**conditions); end

  def expression(); end

  def initialize(expression); end
end

class Capybara::Selector
  def self.[](name); end

  def self.add(name, **options, &block); end

  def self.all(); end

  def self.for(locator); end

  def self.remove(name); end

  def self.update(name, &block); end
end

module Capybara::Selenium::ChromeLogs
  def available_log_types(); end

  def commands(command); end

  def log(type); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  LOG_MSG = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::ChromeNode
  def click(*arg, **arg1); end

  def drop(*args); end

  def set_text(value, clear: T.unsafe(nil), **_unused); end
end

class Capybara::Selenium::Driver
  def accept_modal(_type, **options); end

  def app(); end

  def browser(); end

  def dismiss_modal(_type, **options); end

  def frame_obscured_at?(x:, y:); end

  def initialize(app, **options); end

  def open_new_window(kind=T.unsafe(nil)); end

  def options(); end

  def quit(); end

  def send_keys(*args); end

  def title(); end
  CAPS_VERSION = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  SPECIAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Driver::ChromeDriver
  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::ChromeDriver
  def self.extended(base); end
end

module Capybara::Selenium::Driver::EdgeDriver
  def download_path=(path); end

  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::EdgeDriver
  def self.extended(base); end
end

module Capybara::Selenium::Driver::FirefoxDriver
  def self.extended(driver); end
end

module Capybara::Selenium::Driver::InternetExplorerDriver
  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::SafariDriver
  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::W3CFirefoxDriver
  def self.extended(driver); end

  def self.pause_broken?(sel_driver); end
end

class Capybara::Selenium::Driver
  def self.load_selenium(); end

  def self.register_specialization(browser_name, specialization); end

  def self.selenium_webdriver_version(); end

  def self.specializations(); end
end

class Capybara::Selenium::EdgeNode
  def click(*arg, **arg1); end

  def drop(*args); end

  def set_text(value, clear: T.unsafe(nil), **_unused); end
end

module Capybara::Selenium::Find
  def find_css(selector, uses_visibility: T.unsafe(nil), texts: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end

  def find_xpath(selector, uses_visibility: T.unsafe(nil), styles: T.unsafe(nil), position: T.unsafe(nil), **_options); end
end

class Capybara::Selenium::FirefoxNode
  def drop(*args); end

  def focused?(); end
end

class Capybara::Selenium::Node
  def content_editable?(); end

  def drag_to(element, drop_modifiers: T.unsafe(nil), **arg); end

  def drop(*_); end

  def obscured?(x: T.unsafe(nil), y: T.unsafe(nil)); end

  def scroll_if_needed(); end

  def scroll_to_center(); end
  GET_XPATH_SCRIPT = ::T.let(nil, ::T.untyped)
  OBSCURED_OR_OFFSET_SCRIPT = ::T.let(nil, ::T.untyped)
  RAPID_APPEND_TEXT = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::FileInputClickEmulation
  def click(keys=T.unsafe(nil), **options); end
end

module Capybara::Selenium::Node::Html5Drag
  def drag_to(element, html5: T.unsafe(nil), delay: T.unsafe(nil), drop_modifiers: T.unsafe(nil)); end
  ATTACH_FILE = ::T.let(nil, ::T.untyped)
  DROP_FILE = ::T.let(nil, ::T.untyped)
  DROP_STRING = ::T.let(nil, ::T.untyped)
  HTML5_DRAG_DROP_SCRIPT = ::T.let(nil, ::T.untyped)
  LEGACY_DRAG_CHECK = ::T.let(nil, ::T.untyped)
  MOUSEDOWN_TRACKER = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::Node::ModifierKeysStack
  def include?(key); end

  def pop(); end

  def press(key); end

  def push(); end
end

class Capybara::Selenium::SafariNode
  def set_text(value, clear: T.unsafe(nil), **_unused); end
  MODIFIER_KEYS = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Scroll
  def scroll_by(x, y); end

  def scroll_to(element, location, position=T.unsafe(nil)); end
  SCROLL_POSITIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::Server
  def app(); end

  def base_url(); end

  def boot(); end

  def error(); end

  def host(); end

  def initialize(app, *deprecated_options, port: T.unsafe(nil), host: T.unsafe(nil), reportable_errors: T.unsafe(nil), extra_middleware: T.unsafe(nil)); end

  def port(); end

  def reset_error!(); end

  def responsive?(); end

  def using_ssl?(); end

  def wait_for_pending_requests(); end
end

class Capybara::Server::AnimationDisabler
  def call(env); end

  def initialize(app); end
  DISABLE_CSS_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
  DISABLE_JS_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::AnimationDisabler
  def self.selector_for(css_or_bool); end
end

class Capybara::Server::Checker
  def initialize(host, port); end

  def request(&block); end

  def ssl?(); end
  TRY_HTTPS_ERRORS = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::Middleware
  def call(env); end

  def clear_error(); end

  def error(); end

  def initialize(app, server_errors, extra_middleware=T.unsafe(nil)); end

  def pending_requests(); end

  def pending_requests?(); end
end

class Capybara::Server::Middleware::Counter
  def decrement(uri); end

  def increment(uri); end

  def positive?(); end

  def value(); end
end

class Capybara::Server
  def self.ports(); end
end

class Capybara::Session
  def accept_alert(text=T.unsafe(nil), **options, &blk); end

  def accept_confirm(text=T.unsafe(nil), **options, &blk); end

  def accept_prompt(text=T.unsafe(nil), **options, &blk); end

  def active_element(); end

  def all(*arg, **arg1, &arg2); end

  def app(); end

  def assert_all_of_selectors(*arg, **arg1, &arg2); end

  def assert_any_of_selectors(*arg, **arg1, &arg2); end

  def assert_no_selector(*arg, **arg1, &arg2); end

  def assert_no_text(*arg, **arg1, &arg2); end

  def assert_no_title(*arg, **arg1, &arg2); end

  def assert_none_of_selectors(*arg, **arg1, &arg2); end

  def assert_selector(*arg, **arg1, &arg2); end

  def assert_text(*arg, **arg1, &arg2); end

  def assert_title(*arg, **arg1, &arg2); end

  def attach_file(*arg, **arg1, &arg2); end

  def body(); end

  def check(*arg, **arg1, &arg2); end

  def choose(*arg, **arg1, &arg2); end

  def cleanup!(); end

  def click(*arg, **arg1, &arg2); end

  def click_button(*arg, **arg1, &arg2); end

  def click_link(*arg, **arg1, &arg2); end

  def click_link_or_button(*arg, **arg1, &arg2); end

  def click_on(*arg, **arg1, &arg2); end

  def config(); end

  def configure(); end

  def current_host(); end

  def current_path(); end

  def current_scope(); end

  def current_url(); end

  def current_window(); end

  def dismiss_confirm(text=T.unsafe(nil), **options, &blk); end

  def dismiss_prompt(text=T.unsafe(nil), **options, &blk); end

  def document(); end

  def double_click(*arg, **arg1, &arg2); end

  def driver(); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def fill_in(*arg, **arg1, &arg2); end

  def find(*arg, **arg1, &arg2); end

  def find_all(*arg, **arg1, &arg2); end

  def find_button(*arg, **arg1, &arg2); end

  def find_by_id(*arg, **arg1, &arg2); end

  def find_field(*arg, **arg1, &arg2); end

  def find_link(*arg, **arg1, &arg2); end

  def first(*arg, **arg1, &arg2); end

  def go_back(); end

  def go_forward(); end

  def has_button?(*arg, **arg1, &arg2); end

  def has_checked_field?(*arg, **arg1, &arg2); end

  def has_content?(*arg, **arg1, &arg2); end

  def has_css?(*arg, **arg1, &arg2); end

  def has_element?(*arg, **arg1, &arg2); end

  def has_field?(*arg, **arg1, &arg2); end

  def has_link?(*arg, **arg1, &arg2); end

  def has_no_button?(*arg, **arg1, &arg2); end

  def has_no_checked_field?(*arg, **arg1, &arg2); end

  def has_no_content?(*arg, **arg1, &arg2); end

  def has_no_css?(*arg, **arg1, &arg2); end

  def has_no_element?(*arg, **arg1, &arg2); end

  def has_no_field?(*arg, **arg1, &arg2); end

  def has_no_link?(*arg, **arg1, &arg2); end

  def has_no_select?(*arg, **arg1, &arg2); end

  def has_no_selector?(*arg, **arg1, &arg2); end

  def has_no_table?(*arg, **arg1, &arg2); end

  def has_no_text?(*arg, **arg1, &arg2); end

  def has_no_title?(*arg, **arg1, &arg2); end

  def has_no_unchecked_field?(*arg, **arg1, &arg2); end

  def has_no_xpath?(*arg, **arg1, &arg2); end

  def has_select?(*arg, **arg1, &arg2); end

  def has_selector?(*arg, **arg1, &arg2); end

  def has_table?(*arg, **arg1, &arg2); end

  def has_text?(*arg, **arg1, &arg2); end

  def has_title?(*arg, **arg1, &arg2); end

  def has_unchecked_field?(*arg, **arg1, &arg2); end

  def has_xpath?(*arg, **arg1, &arg2); end

  def html(); end

  def initialize(mode, app=T.unsafe(nil)); end

  def mode(); end

  def open_new_window(kind=T.unsafe(nil)); end

  def query(*arg, **arg1, &arg2); end

  def quit(); end

  def raise_server_error!(); end

  def refresh(); end

  def refute_selector(*arg, **arg1, &arg2); end

  def reset!(); end

  def reset_session!(); end

  def response_headers(); end

  def right_click(*arg, **arg1, &arg2); end

  def save_and_open_page(path=T.unsafe(nil)); end

  def save_and_open_screenshot(path=T.unsafe(nil), **options); end

  def save_page(path=T.unsafe(nil)); end

  def save_screenshot(path=T.unsafe(nil), **options); end

  def scroll_by(*arg, **arg1, &arg2); end

  def scroll_to(*arg, **arg1, &arg2); end

  def select(*arg, **arg1, &arg2); end

  def send_keys(*arg, **arg1, &arg2); end

  def server(); end

  def server_url(); end

  def source(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(window=T.unsafe(nil), **options, &window_locator); end

  def synchronized(); end

  def synchronized=(synchronized); end

  def text(*arg, **arg1, &arg2); end

  def title(*arg, **arg1, &arg2); end

  def uncheck(*arg, **arg1, &arg2); end

  def unselect(*arg, **arg1, &arg2); end

  def using_wait_time(seconds, &block); end

  def visit(visit_uri); end

  def window_opened_by(**options); end

  def windows(); end

  def within(*args, **kw_args); end

  def within_element(*args, **kw_args); end

  def within_fieldset(locator, &block); end

  def within_frame(*args, **kw_args); end

  def within_table(locator, &block); end

  def within_window(window_or_proc); end
  DOCUMENT_METHODS = ::T.let(nil, ::T.untyped)
  DSL_METHODS = ::T.let(nil, ::T.untyped)
  MODAL_METHODS = ::T.let(nil, ::T.untyped)
  NODE_METHODS = ::T.let(nil, ::T.untyped)
  SESSION_METHODS = ::T.let(nil, ::T.untyped)
end

class Capybara::Session
  def self.instance_created?(); end
end

class Capybara::SessionConfig
  def always_include_port(); end

  def always_include_port=(always_include_port); end

  def app_host(); end

  def app_host=(url); end

  def asset_host(); end

  def asset_host=(asset_host); end

  def automatic_label_click(); end

  def automatic_label_click=(automatic_label_click); end

  def automatic_reload(); end

  def automatic_reload=(automatic_reload); end

  def default_host(); end

  def default_host=(url); end

  def default_max_wait_time(); end

  def default_max_wait_time=(default_max_wait_time); end

  def default_normalize_ws(); end

  def default_normalize_ws=(default_normalize_ws); end

  def default_retry_interval(); end

  def default_retry_interval=(default_retry_interval); end

  def default_selector(); end

  def default_selector=(default_selector); end

  def default_set_options(); end

  def default_set_options=(default_set_options); end

  def disable_animation(); end

  def disable_animation=(disable_animation); end

  def enable_aria_label(); end

  def enable_aria_label=(enable_aria_label); end

  def enable_aria_role(); end

  def enable_aria_role=(enable_aria_role); end

  def exact(); end

  def exact=(exact); end

  def exact_text(); end

  def exact_text=(exact_text); end

  def ignore_hidden_elements(); end

  def ignore_hidden_elements=(ignore_hidden_elements); end

  def match(); end

  def match=(match); end

  def predicates_wait(); end

  def predicates_wait=(predicates_wait); end

  def raise_server_errors(); end

  def raise_server_errors=(raise_server_errors); end

  def run_server(); end

  def run_server=(run_server); end

  def save_path(); end

  def save_path=(save_path); end

  def server_errors(); end

  def server_errors=(errors); end

  def server_host(); end

  def server_host=(server_host); end

  def server_port(); end

  def server_port=(server_port); end

  def test_id(); end

  def test_id=(id); end

  def visible_text_only(); end

  def visible_text_only=(visible_text_only); end

  def w3c_click_offset(); end

  def w3c_click_offset=(w3c_click_offset); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::SessionMatchers
  def assert_current_path(path, **options, &optional_filter_block); end

  def assert_no_current_path(path, **options, &optional_filter_block); end

  def has_current_path?(path, **options, &optional_filter_block); end

  def has_no_current_path?(path, **options, &optional_filter_block); end
end

class Capybara::Window
  def ==(other); end

  def close(); end

  def closed?(); end

  def current?(); end

  def eql?(other); end

  def exists?(); end

  def fullscreen(); end

  def handle(); end

  def initialize(session, handle); end

  def maximize(); end

  def resize_to(width, height); end

  def session(); end

  def size(); end
end

module Capybara
  extend ::Capybara::DSL
  def self.HTML(html); end

  def self.add_selector(name, **options, &block); end

  def self.allow_gumbo(*args, **arg, &block); end

  def self.allow_gumbo=(*args, **arg, &block); end

  def self.always_include_port(*args, **arg, &block); end

  def self.always_include_port=(*args, **arg, &block); end

  def self.app(*args, **arg, &block); end

  def self.app=(*args, **arg, &block); end

  def self.app_host(*args, **arg, &block); end

  def self.app_host=(*args, **arg, &block); end

  def self.asset_host(*args, **arg, &block); end

  def self.asset_host=(*args, **arg, &block); end

  def self.automatic_label_click(*args, **arg, &block); end

  def self.automatic_label_click=(*args, **arg, &block); end

  def self.automatic_reload(*args, **arg, &block); end

  def self.automatic_reload=(*args, **arg, &block); end

  def self.configure(); end

  def self.current_driver(); end

  def self.current_driver=(name); end

  def self.current_session(); end

  def self.default_driver(*args, **arg, &block); end

  def self.default_driver=(*args, **arg, &block); end

  def self.default_host(*args, **arg, &block); end

  def self.default_host=(*args, **arg, &block); end

  def self.default_max_wait_time(*args, **arg, &block); end

  def self.default_max_wait_time=(*args, **arg, &block); end

  def self.default_normalize_ws(*args, **arg, &block); end

  def self.default_normalize_ws=(*args, **arg, &block); end

  def self.default_retry_interval(*args, **arg, &block); end

  def self.default_retry_interval=(*args, **arg, &block); end

  def self.default_selector(*args, **arg, &block); end

  def self.default_selector=(*args, **arg, &block); end

  def self.default_set_options(*args, **arg, &block); end

  def self.default_set_options=(*args, **arg, &block); end

  def self.disable_animation(*args, **arg, &block); end

  def self.disable_animation=(*args, **arg, &block); end

  def self.drivers(); end

  def self.enable_aria_label(*args, **arg, &block); end

  def self.enable_aria_label=(*args, **arg, &block); end

  def self.enable_aria_role(*args, **arg, &block); end

  def self.enable_aria_role=(*args, **arg, &block); end

  def self.exact(*args, **arg, &block); end

  def self.exact=(*args, **arg, &block); end

  def self.exact_text(*args, **arg, &block); end

  def self.exact_text=(*args, **arg, &block); end

  def self.ignore_hidden_elements(*args, **arg, &block); end

  def self.ignore_hidden_elements=(*args, **arg, &block); end

  def self.javascript_driver(*args, **arg, &block); end

  def self.javascript_driver=(*args, **arg, &block); end

  def self.match(*args, **arg, &block); end

  def self.match=(*args, **arg, &block); end

  def self.mode(); end

  def self.modify_selector(name, &block); end

  def self.predicates_wait(*args, **arg, &block); end

  def self.predicates_wait=(*args, **arg, &block); end

  def self.raise_server_errors(*args, **arg, &block); end

  def self.raise_server_errors=(*args, **arg, &block); end

  def self.register_driver(name, &block); end

  def self.register_server(name, &block); end

  def self.reset!(); end

  def self.reset_sessions!(); end

  def self.reuse_server(*args, **arg, &block); end

  def self.reuse_server=(*args, **arg, &block); end

  def self.run_default_server(app, port); end

  def self.run_server(*args, **arg, &block); end

  def self.run_server=(*args, **arg, &block); end

  def self.save_path(*args, **arg, &block); end

  def self.save_path=(*args, **arg, &block); end

  def self.server(*args, **arg, &block); end

  def self.server=(*args, **arg, &block); end

  def self.server_errors(*args, **arg, &block); end

  def self.server_errors=(*args, **arg, &block); end

  def self.server_host(*args, **arg, &block); end

  def self.server_host=(*args, **arg, &block); end

  def self.server_port(*args, **arg, &block); end

  def self.server_port=(*args, **arg, &block); end

  def self.servers(); end

  def self.session_name(); end

  def self.session_name=(name); end

  def self.session_options(); end

  def self.string(html); end

  def self.test_id(*args, **arg, &block); end

  def self.test_id=(*args, **arg, &block); end

  def self.threadsafe(*args, **arg, &block); end

  def self.threadsafe=(*args, **arg, &block); end

  def self.use_default_driver(); end

  def self.use_html5_parsing(*args, **arg, &block); end

  def self.use_html5_parsing=(*args, **arg, &block); end

  def self.using_driver(driver); end

  def self.using_wait_time(seconds); end

  def self.visible_text_only(*args, **arg, &block); end

  def self.visible_text_only=(*args, **arg, &block); end

  def self.w3c_click_offset(*args, **arg, &block); end

  def self.w3c_click_offset=(*args, **arg, &block); end
end

module CaseTransform
  VERSION = ::T.let(nil, ::T.untyped)
end

module CaseTransform
  def self.camel(value); end

  def self.camel_cache(); end

  def self.camel_lower(value); end

  def self.camel_lower_cache(); end

  def self.dash(value); end

  def self.dash_cache(); end

  def self.unaltered(value); end

  def self.underscore(value); end

  def self.underscore_cache(); end
end

class Class
  include ::ActiveSupport::DescendantsTracker::ReloadedClassesFiltering
  def any_instance(); end

  def json_creatable?(); end
end

module Cloudinary
  FORMAT_ALIASES = ::T.let(nil, ::T.untyped)
  SHARED_CDN = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Cloudinary::AccountApi
end

Cloudinary::AccountApi::AlreadyExists = Cloudinary::BaseApi::AlreadyExists

Cloudinary::AccountApi::AuthorizationRequired = Cloudinary::BaseApi::AuthorizationRequired

Cloudinary::AccountApi::BadRequest = Cloudinary::BaseApi::BadRequest

Cloudinary::AccountApi::Error = Cloudinary::BaseApi::Error

Cloudinary::AccountApi::GeneralError = Cloudinary::BaseApi::GeneralError

Cloudinary::AccountApi::NotAllowed = Cloudinary::BaseApi::NotAllowed

Cloudinary::AccountApi::NotFound = Cloudinary::BaseApi::NotFound

Cloudinary::AccountApi::RateLimited = Cloudinary::BaseApi::RateLimited

Cloudinary::AccountApi::Response = Cloudinary::BaseApi::Response

class Cloudinary::AccountApi
  extend ::Cloudinary::BaseApi
  def self.access_keys(sub_account_id, options=T.unsafe(nil)); end

  def self.add_user_to_group(group_id, user_id, options=T.unsafe(nil)); end

  def self.create_sub_account(name, cloud_name=T.unsafe(nil), custom_attributes=T.unsafe(nil), enabled=T.unsafe(nil), base_account=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.create_user(name, email, role, sub_account_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.create_user_group(name, options=T.unsafe(nil)); end

  def self.delete_sub_account(sub_account_id, options=T.unsafe(nil)); end

  def self.delete_user(user_id, options=T.unsafe(nil)); end

  def self.delete_user_group(group_id, options=T.unsafe(nil)); end

  def self.generate_access_key(sub_account_id, name=T.unsafe(nil), enabled=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.remove_user_from_group(group_id, user_id, options=T.unsafe(nil)); end

  def self.sub_account(sub_account_id, options=T.unsafe(nil)); end

  def self.sub_accounts(enabled=T.unsafe(nil), ids=T.unsafe(nil), prefix=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.update_access_key(sub_account_id, api_key, name=T.unsafe(nil), enabled=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.update_sub_account(sub_account_id, name=T.unsafe(nil), cloud_name=T.unsafe(nil), custom_attributes=T.unsafe(nil), enabled=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.update_user(user_id, name=T.unsafe(nil), email=T.unsafe(nil), role=T.unsafe(nil), sub_account_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.update_user_group(group_id, name, options=T.unsafe(nil)); end

  def self.user(user_id, options=T.unsafe(nil)); end

  def self.user_group(group_id, options=T.unsafe(nil)); end

  def self.user_group_users(group_id, options=T.unsafe(nil)); end

  def self.user_groups(options=T.unsafe(nil)); end

  def self.users(pending=T.unsafe(nil), user_ids=T.unsafe(nil), prefix=T.unsafe(nil), sub_account_id=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Cloudinary::AccountConfig
  include ::Cloudinary::BaseConfig
  def load_config_from_env(); end
  ENV_URL = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
end

module Cloudinary::AccountConfig
end

module Cloudinary::Analytics
  def encode_version(version); end

  def get_key(binary_value); end

  def initialize_char_codes(); end

  def int_to_padded_bin(integer, pad_num); end

  def product(product); end

  def sdk_analytics_query_param(); end

  def sdk_analytics_signature(); end

  def sdk_code(sdk_code); end

  def sdk_version(sdk_version); end

  def tech_version(tech_version); end
  ALGO_VERSION = ::T.let(nil, ::T.untyped)
  BINARY_PAD_SIZE = ::T.let(nil, ::T.untyped)
  CHARS = ::T.let(nil, ::T.untyped)
  QUERY_KEY = ::T.let(nil, ::T.untyped)
  SDK_CODE = ::T.let(nil, ::T.untyped)
end

module Cloudinary::Analytics
  extend ::Cloudinary::Analytics
end

class Cloudinary::Api
  LIST_RESOURCES_PARAMS = ::T.let(nil, ::T.untyped)
  RESOURCES_PARAMS = ::T.let(nil, ::T.untyped)
end

Cloudinary::Api::AlreadyExists = Cloudinary::BaseApi::AlreadyExists

Cloudinary::Api::AuthorizationRequired = Cloudinary::BaseApi::AuthorizationRequired

Cloudinary::Api::BadRequest = Cloudinary::BaseApi::BadRequest

Cloudinary::Api::Error = Cloudinary::BaseApi::Error

Cloudinary::Api::GeneralError = Cloudinary::BaseApi::GeneralError

Cloudinary::Api::NotAllowed = Cloudinary::BaseApi::NotAllowed

Cloudinary::Api::NotFound = Cloudinary::BaseApi::NotFound

Cloudinary::Api::RateLimited = Cloudinary::BaseApi::RateLimited

Cloudinary::Api::Response = Cloudinary::BaseApi::Response

class Cloudinary::Api
  extend ::Cloudinary::BaseApi
  def self.add_metadata_field(field, options=T.unsafe(nil)); end

  def self.add_metadata_rule(rule, options=T.unsafe(nil)); end

  def self.add_related_assets(public_id, assets_to_relate, options=T.unsafe(nil)); end

  def self.add_related_assets_by_asset_ids(asset_id, assets_to_relate, options=T.unsafe(nil)); end

  def self.analyze(input_type, analysis_type, options=T.unsafe(nil)); end

  def self.call_api(method, uri, params, options); end

  def self.call_metadata_api(method, uri, params, options); end

  def self.call_metadata_rules_api(method, uri, params, options); end

  def self.create_folder(folder_name, options=T.unsafe(nil)); end

  def self.create_streaming_profile(name, options=T.unsafe(nil)); end

  def self.create_transformation(name, definition, options=T.unsafe(nil)); end

  def self.create_upload_mapping(name, options=T.unsafe(nil)); end

  def self.create_upload_preset(options=T.unsafe(nil)); end

  def self.delete_all_resources(options=T.unsafe(nil)); end

  def self.delete_datasource_entries(field_external_id, entries_external_id, options=T.unsafe(nil)); end

  def self.delete_derived_by_transformation(public_ids, transformations, options=T.unsafe(nil)); end

  def self.delete_derived_resources(derived_resource_ids, options=T.unsafe(nil)); end

  def self.delete_folder(path, options=T.unsafe(nil)); end

  def self.delete_metadata_field(field_external_id, options=T.unsafe(nil)); end

  def self.delete_metadata_rule(external_id, options=T.unsafe(nil)); end

  def self.delete_related_assets(public_id, assets_to_unrelate, options=T.unsafe(nil)); end

  def self.delete_related_assets_by_asset_ids(asset_id, assets_to_unrelate, options=T.unsafe(nil)); end

  def self.delete_resource_params(options, params=T.unsafe(nil)); end

  def self.delete_resources(public_ids, options=T.unsafe(nil)); end

  def self.delete_resources_by_prefix(prefix, options=T.unsafe(nil)); end

  def self.delete_resources_by_tag(tag, options=T.unsafe(nil)); end

  def self.delete_streaming_profile(name, options=T.unsafe(nil)); end

  def self.delete_transformation(transformation, options=T.unsafe(nil)); end

  def self.delete_upload_mapping(name, options=T.unsafe(nil)); end

  def self.delete_upload_preset(name, options=T.unsafe(nil)); end

  def self.get_breakpoints(public_id, options); end

  def self.get_streaming_profile(name, options=T.unsafe(nil)); end

  def self.list_metadata_fields(options=T.unsafe(nil)); end

  def self.list_metadata_rules(options=T.unsafe(nil)); end

  def self.list_resources_params(options, params=T.unsafe(nil)); end

  def self.list_streaming_profiles(); end

  def self.metadata_field_by_field_id(field_external_id, options=T.unsafe(nil)); end

  def self.only(hash, *keys); end

  def self.parse_json_response(response); end

  def self.ping(options=T.unsafe(nil)); end

  def self.prepare_resource_details_params(options); end

  def self.publish_by_ids(publicIds, options=T.unsafe(nil)); end

  def self.publish_by_prefix(prefix, options=T.unsafe(nil)); end

  def self.publish_by_tag(tag, options=T.unsafe(nil)); end

  def self.publish_resources(options=T.unsafe(nil)); end

  def self.reorder_metadata_field_datasource(field_external_id, order_by, direction=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.reorder_metadata_fields(order_by, direction=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.resource(public_id, options=T.unsafe(nil)); end

  def self.resource_by_asset_id(asset_id, options=T.unsafe(nil)); end

  def self.resource_types(options=T.unsafe(nil)); end

  def self.resources(options=T.unsafe(nil)); end

  def self.resources_by_asset_folder(asset_folder, options=T.unsafe(nil)); end

  def self.resources_by_asset_ids(asset_ids, options=T.unsafe(nil)); end

  def self.resources_by_context(key, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.resources_by_ids(public_ids, options=T.unsafe(nil)); end

  def self.resources_by_moderation(kind, status, options=T.unsafe(nil)); end

  def self.resources_by_tag(tag, options=T.unsafe(nil)); end

  def self.resources_params(options, params=T.unsafe(nil)); end

  def self.restore(public_ids, options=T.unsafe(nil)); end

  def self.restore_metadata_field_datasource(field_external_id, entries_external_ids, options=T.unsafe(nil)); end

  def self.root_folders(options=T.unsafe(nil)); end

  def self.subfolders(of_folder_path, options=T.unsafe(nil)); end

  def self.tags(options=T.unsafe(nil)); end

  def self.transformation(transformation, options=T.unsafe(nil)); end

  def self.transformation_string(transformation); end

  def self.transformations(options=T.unsafe(nil)); end

  def self.update(public_id, options=T.unsafe(nil)); end

  def self.update_metadata_field(field_external_id, field, options=T.unsafe(nil)); end

  def self.update_metadata_field_datasource(field_external_id, entries_external_id, options=T.unsafe(nil)); end

  def self.update_metadata_rule(external_id, rule, options=T.unsafe(nil)); end

  def self.update_resources_access_mode(access_mode, by_key, value, options=T.unsafe(nil)); end

  def self.update_resources_access_mode_by_ids(access_mode, public_ids, options=T.unsafe(nil)); end

  def self.update_resources_access_mode_by_prefix(access_mode, prefix, options=T.unsafe(nil)); end

  def self.update_resources_access_mode_by_tag(access_mode, tag, options=T.unsafe(nil)); end

  def self.update_streaming_profile(name, options=T.unsafe(nil)); end

  def self.update_transformation(transformation, updates, options=T.unsafe(nil)); end

  def self.update_upload_mapping(name, options=T.unsafe(nil)); end

  def self.update_upload_preset(name, options=T.unsafe(nil)); end

  def self.upload_mapping(name=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.upload_mappings(options=T.unsafe(nil)); end

  def self.upload_preset(name, options=T.unsafe(nil)); end

  def self.upload_presets(options=T.unsafe(nil)); end

  def self.usage(options=T.unsafe(nil)); end

  def self.visual_search(options=T.unsafe(nil)); end
end

module Cloudinary::BaseApi
  def call_json_api(method, api_url, payload, timeout, headers, proxy=T.unsafe(nil), user=T.unsafe(nil), password=T.unsafe(nil)); end
end

class Cloudinary::BaseApi::AlreadyExists
end

class Cloudinary::BaseApi::AlreadyExists
end

class Cloudinary::BaseApi::AuthorizationRequired
end

class Cloudinary::BaseApi::AuthorizationRequired
end

class Cloudinary::BaseApi::BadRequest
end

class Cloudinary::BaseApi::BadRequest
end

class Cloudinary::BaseApi::Error
end

class Cloudinary::BaseApi::Error
end

class Cloudinary::BaseApi::GeneralError
end

class Cloudinary::BaseApi::GeneralError
end

class Cloudinary::BaseApi::NotAllowed
end

class Cloudinary::BaseApi::NotAllowed
end

class Cloudinary::BaseApi::NotFound
end

class Cloudinary::BaseApi::NotFound
end

class Cloudinary::BaseApi::RateLimited
end

class Cloudinary::BaseApi::RateLimited
end

class Cloudinary::BaseApi::Response
  def initialize(response=T.unsafe(nil)); end

  def rate_limit_allowed(); end

  def rate_limit_remaining(); end

  def rate_limit_reset_at(); end
end

class Cloudinary::BaseApi::Response
end

module Cloudinary::BaseApi
  def self.extended(base); end
end

module Cloudinary::BaseConfig
  def load_config_from_env(); end

  def load_from_url(url); end

  def update(new_config=T.unsafe(nil)); end
end

class Cloudinary::Blob
  def content_type(); end

  def initialize(data, options=T.unsafe(nil)); end

  def original_filename(); end

  def path(); end
end

class Cloudinary::Blob
end

module Cloudinary::Config
  def load_config_from_env(); end
  ENV_URL = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
end

class Cloudinary::Downloader
end

class Cloudinary::Downloader
  def self.download(source, options=T.unsafe(nil)); end
end

class Cloudinary::PreloadedFile
  def filename(); end

  def format(); end

  def identifier(); end

  def initialize(file_info); end

  def public_id(); end

  def resource_type(); end

  def signature(); end

  def type(); end

  def valid?(); end

  def version(); end
  PRELOADED_CLOUDINARY_PATH = ::T.let(nil, ::T.untyped)
end

class Cloudinary::PreloadedFile
  def self.split_format(identifier); end
end

class Cloudinary::Search
  def aggregate(value); end

  def endpoint(endpoint); end

  def execute(options=T.unsafe(nil)); end

  def expression(value); end

  def fields(value); end

  def max_results(value); end

  def next_cursor(value); end

  def sort_by(field_name, dir=T.unsafe(nil)); end

  def to_h(); end

  def to_url(ttl=T.unsafe(nil), next_cursor=T.unsafe(nil), options=T.unsafe(nil)); end

  def ttl(ttl); end

  def with_field(value); end
  AGGREGATE = ::T.let(nil, ::T.untyped)
  ENDPOINT = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  KEYS_WITH_UNIQUE_VALUES = ::T.let(nil, ::T.untyped)
  SORT_BY = ::T.let(nil, ::T.untyped)
  TTL = ::T.let(nil, ::T.untyped)
  WITH_FIELD = ::T.let(nil, ::T.untyped)
end

class Cloudinary::Search
  def self.method_missing(method_name, *arguments); end
end

class Cloudinary::SearchFolders
  ENDPOINT = ::T.let(nil, ::T.untyped)
end

class Cloudinary::SearchFolders
end

class Cloudinary::Static
  DEFAULT_IMAGE_DIRS = ::T.let(nil, ::T.untyped)
  DEFAULT_IMAGE_EXTENSION_MASK = ::T.let(nil, ::T.untyped)
  IGNORE_FILES = ::T.let(nil, ::T.untyped)
  METADATA_FILE = ::T.let(nil, ::T.untyped)
  METADATA_TRASH_FILE = ::T.let(nil, ::T.untyped)
end

class Cloudinary::Static
  def self.public_id_and_resource_type_from_path(path); end

  def self.sync(options=T.unsafe(nil)); end
end

class Cloudinary::Uploader
  SLIDESHOW_PARAMS = ::T.let(nil, ::T.untyped)
  TEXT_PARAMS = ::T.let(nil, ::T.untyped)
end

class Cloudinary::Uploader
  def self.add_context(context, public_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.add_tag(tag, public_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.build_custom_headers(headers); end

  def self.build_upload_params(options, as_bool=T.unsafe(nil)); end

  def self.cache_results(result); end

  def self.call_api(action, options); end

  def self.call_context_api(context, command, public_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.call_tags_api(tag, command, public_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.create_archive(options=T.unsafe(nil), target_format=T.unsafe(nil)); end

  def self.create_slideshow(options=T.unsafe(nil)); end

  def self.create_zip(options=T.unsafe(nil)); end

  def self.destroy(public_id, options=T.unsafe(nil)); end

  def self.exists?(public_id, options=T.unsafe(nil)); end

  def self.explicit(public_id, options=T.unsafe(nil)); end

  def self.explode(public_id, options=T.unsafe(nil)); end

  def self.generate_sprite(tag, options=T.unsafe(nil)); end

  def self.multi(tag, options=T.unsafe(nil)); end

  def self.remove_all_context(public_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.remove_all_tags(public_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.remove_tag(tag, public_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.rename(from_public_id, to_public_id, options=T.unsafe(nil)); end

  def self.replace_tag(tag, public_ids=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.text(text, options=T.unsafe(nil)); end

  def self.unsigned_upload(file, upload_preset, options=T.unsafe(nil)); end

  def self.update_metadata(metadata, public_ids, options=T.unsafe(nil)); end

  def self.upload(file, options=T.unsafe(nil)); end

  def self.upload_large(file, public_id_or_options=T.unsafe(nil), old_options=T.unsafe(nil)); end

  def self.upload_large_part(file, options=T.unsafe(nil)); end
end

class Cloudinary::Utils
  ALGORITHM_SIGNATURE = ::T.let(nil, ::T.untyped)
  ALGO_SHA1 = ::T.let(nil, ::T.untyped)
  ALGO_SHA256 = ::T.let(nil, ::T.untyped)
  AUDIO_FORMATS = ::T.let(nil, ::T.untyped)
  CONDITIONAL_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION = ::T.let(nil, ::T.untyped)
  EXP_REGEXP = ::T.let(nil, ::T.untyped)
  EXP_REPLACEMENT = ::T.let(nil, ::T.untyped)
  IMAGE_FORMATS = ::T.let(nil, ::T.untyped)
  LAYER_KEYWORD_PARAMS = ::T.let(nil, ::T.untyped)
  LONG_URL_SIGNATURE_LENGTH = ::T.let(nil, ::T.untyped)
  MODE_DOWNLOAD = ::T.let(nil, ::T.untyped)
  PREDEFINED_VARS = ::T.let(nil, ::T.untyped)
  REMOTE_URL_REGEX = ::T.let(nil, ::T.untyped)
  SHORT_URL_SIGNATURE_LENGTH = ::T.let(nil, ::T.untyped)
  SIMPLE_TRANSFORMATION_PARAMS = ::T.let(nil, ::T.untyped)
  TRANSFORMATION_PARAMS = ::T.let(nil, ::T.untyped)
  UPLOAD_PREFIX = ::T.let(nil, ::T.untyped)
  URL_KEYS = ::T.let(nil, ::T.untyped)
  VIDEO_FORMATS = ::T.let(nil, ::T.untyped)
end

class Cloudinary::Utils
  def self.api_sign_request(params_to_sign, api_secret, signature_algorithm=T.unsafe(nil)); end

  def self.api_string_to_sign(params_to_sign); end

  def self.archive_params(options=T.unsafe(nil)); end

  def self.as_bool(value); end

  def self.as_safe_bool(value); end

  def self.asset_file_name(path); end

  def self.base_api_url(path, options=T.unsafe(nil)); end

  def self.build_array(array); end

  def self.build_distribution_domain(options=T.unsafe(nil)); end

  def self.build_eager(eager); end

  def self.build_multi_and_sprite_params(tag_or_options, options); end

  def self.chain_transformation(options, *transformation); end

  def self.cloudinary_api_url(action=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.cloudinary_url(source, options=T.unsafe(nil)); end

  def self.config_option_consume(options, option_name, default_value=T.unsafe(nil)); end

  def self.config_option_fetch(options, option_name, default_value=T.unsafe(nil)); end

  def self.deep_symbolize_keys(object); end

  def self.download_archive_url(options=T.unsafe(nil)); end

  def self.download_backedup_asset(asset_id, version_id, options=T.unsafe(nil)); end

  def self.download_folder(folder_path, options=T.unsafe(nil)); end

  def self.download_generated_sprite(tag, options=T.unsafe(nil)); end

  def self.download_multi(tag, options=T.unsafe(nil)); end

  def self.download_zip_url(options=T.unsafe(nil)); end

  def self.encode_context(hash); end

  def self.encode_double_array(array); end

  def self.encode_hash(hash); end

  def self.extract_config_params(options); end

  def self.extract_transformation_params(options); end

  def self.finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten); end

  def self.finalize_source(source, format, url_suffix); end

  def self.flat_hash_to_query_params(hash); end

  def self.generate_auth_token(options); end

  def self.generate_responsive_breakpoints_string(breakpoints); end

  def self.generate_transformation_string(options=T.unsafe(nil), allow_implicit_crop_mode=T.unsafe(nil)); end

  def self.handle_file_param(file, options=T.unsafe(nil)); end

  def self.hash(input, signature_algorithm=T.unsafe(nil), hash_method=T.unsafe(nil)); end

  def self.hash_query_params(hash); end

  def self.is_remote?(url); end

  def self.json_array_param(data); end

  def self.json_decode(str); end

  def self.normalize_expression(expression); end

  def self.patch_fetch_format(options=T.unsafe(nil)); end

  def self.private_download_url(public_id, format, options=T.unsafe(nil)); end

  def self.process_custom_function(param); end

  def self.process_custom_pre_function(param); end

  def self.process_if(if_value); end

  def self.random_public_id(); end

  def self.resource_type_for_format(format); end

  def self.safe_blank?(value); end

  def self.sign_request(params, options=T.unsafe(nil)); end

  def self.signed_preloaded_image(result); end

  def self.smart_escape(string, unsafe=T.unsafe(nil)); end

  def self.smart_unescape(string); end

  def self.supported_format?(format, formats); end

  def self.supported_image_format?(format); end

  def self.symbolize_keys(h); end

  def self.symbolize_keys!(h); end

  def self.text_style(layer); end

  def self.to_usage_api_date_format(date); end

  def self.unsigned_download_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution); end

  def self.verify_api_response_signature(public_id, version, signature, signature_algorithm=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.verify_notification_signature(body, timestamp, signature, valid_for=T.unsafe(nil), signature_algorithm=T.unsafe(nil), options=T.unsafe(nil)); end
end

module CloudinaryHelper
  CLOUDINARY_JS_CONFIG_PARAMS = ::T.let(nil, ::T.untyped)
  CL_BLANK = ::T.let(nil, ::T.untyped)
  DEFAULT_POSTER_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_SOURCES = ::T.let(nil, ::T.untyped)
  DEFAULT_SOURCE_TYPES = ::T.let(nil, ::T.untyped)
  DEFAULT_VIDEO_OPTIONS = ::T.let(nil, ::T.untyped)
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*arg, **arg1); end
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::HTML
  def break_lines(text, style); end

  def check_group_nesting(name, kind); end

  def check_options!(options); end

  def close_span(); end

  def css(); end

  def css_class_for_kinds(kinds); end

  def make_span_for_kinds(method, hint); end

  def style_for_kinds(kinds); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def get_style_for_css_classes(css_classes); end

  def initialize(style=T.unsafe(nil)); end

  def stylesheet(); end
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def self.load_stylesheet(style=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Numbering
  def self.number!(output, mode=T.unsafe(nil), options=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Output
  def apply_title!(title); end

  def css(); end

  def css=(css); end

  def stylesheet(in_tag=T.unsafe(nil)); end

  def wrap!(element, *args); end

  def wrap_in!(template); end

  def wrapped_in(); end

  def wrapped_in=(wrapped_in); end

  def wrapped_in?(element); end
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::Output::Template
  def apply(target, replacement); end
end

class CodeRay::Encoders::HTML::Output::Template
  def self.wrap!(str, template, target); end
end

module CodeRay::Encoders::HTML::Output
  def self.extended(o); end

  def self.make_stylesheet(css, in_tag=T.unsafe(nil)); end

  def self.page_template_for_css(css); end
end

class CodeRay::Encoders::HTML
  def self.make_html_escape_hash(); end

  def self.token_path_to_hint(hint, kinds); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

class CodeRay::Scanners::Java
  def scan_tokens(encoder, options); end
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby
  def interpreted_string_state(); end

  def scan_tokens(encoder, options); end
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  def heredoc_pattern(delim, interpreted, indented); end

  def initialize(kind, interpreted, delim, heredoc=T.unsafe(nil)); end
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  def self.simple_key_pattern(delim); end
end

class CodeRay::Scanners::Scanner
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*arg); end

  def tokens(*arg); end
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::WordList
  def add(words, value=T.unsafe(nil)); end

  def initialize(default=T.unsafe(nil)); end
end

class CodeRay::WordList::CaseIgnoring
  def [](key); end

  def []=(key, value); end
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

class Comment
  include ::Comment::GeneratedAttributeMethods
  include ::Comment::GeneratedAssociationMethods
  def autosave_associated_records_for_commentable(*args); end

  def autosave_associated_records_for_comments(*args); end

  def autosave_associated_records_for_parent(*args); end

  def autosave_associated_records_for_user(*args); end

  def validate_associated_records_for_comments(*args); end
end

module Comment::GeneratedAssociationMethods
  def build_parent(*args, &block); end

  def build_user(*args, &block); end

  def comment_ids(); end

  def comment_ids=(ids); end

  def commentable(); end

  def commentable=(value); end

  def commentable_changed?(); end

  def commentable_previously_changed?(); end

  def comments(); end

  def comments=(value); end

  def create_parent(*args, &block); end

  def create_parent!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def parent(); end

  def parent=(value); end

  def parent_changed?(); end

  def parent_previously_changed?(); end

  def reload_commentable(); end

  def reload_parent(); end

  def reload_user(); end

  def reset_commentable(); end

  def reset_parent(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Comment::GeneratedAssociationMethods
end

module Comment::GeneratedAttributeMethods
end

module Comment::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::FiberLocalVar
  LOCALS = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

Concurrent::LockLocalVar = Concurrent::FiberLocalVar

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::ThreadLocalVar
  LOCALS = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  DEFAULT_INTERVAL_TYPE = ::T.let(nil, ::T.untyped)
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  FIXED_DELAY = ::T.let(nil, ::T.untyped)
  FIXED_RATE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class ConnectionPool
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Wrapper
  METHODS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

module Cssbundling
  VERSION = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__
  CONFIG = ::T.let(nil, ::T.untyped)
  CONFIG_MAP = ::T.let(nil, ::T.untyped)
  CONFIG_SET = ::T.let(nil, ::T.untyped)
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
  M_CLASS = ::T.let(nil, ::T.untyped)
  M_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  M_INSTANCE_VARIABLE_GET = ::T.let(nil, ::T.untyped)
  M_KIND_OF_P = ::T.let(nil, ::T.untyped)
  M_METHOD = ::T.let(nil, ::T.untyped)
  M_NAME = ::T.let(nil, ::T.untyped)
  M_OBJECT_ID = ::T.let(nil, ::T.untyped)
  M_RESPOND_TO_P = ::T.let(nil, ::T.untyped)
  M_SINGLETON_CLASS = ::T.let(nil, ::T.untyped)
  SESSION = ::T.let(nil, ::T.untyped)
  SHORT_INSPECT_LENGTH = ::T.let(nil, ::T.untyped)
  SO_VERSION = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::Color
  SUPPORT_COLORABLE_OPTION = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::Console
  def deactivate(); end

  def history(); end

  def history_file(); end

  def load_history(); end

  def load_history_if_not_loaded(); end

  def parse_input(buff, commands); end

  def read_history_file(); end

  def readline(prompt); end

  def readline_setup(prompt); end
  FH = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::ForkInterceptor
  def _fork(); end
end

module DEBUGGER__::ForkInterceptor::DaemonInterceptor
  def daemon(*args); end
end

class DEBUGGER__::FrameInfo
  BLOCK_LABL_REGEXP = ::T.let(nil, ::T.untyped)
  HOME = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::GlobalVariablesHelper
  SKIP_GLOBAL_LIST = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::LimitedPP
  def <<(other); end

  def buf(); end

  def initialize(max); end
end

class DEBUGGER__::LimitedPP
  def self.pp(obj, max=T.unsafe(nil)); end
end

module DEBUGGER__::MultiProcessGroup
  def after_fork(child: T.unsafe(nil)); end

  def info(msg); end

  def lock(); end

  def locked?(); end

  def multi_process!(); end

  def sync(&b); end

  def unlock(); end
end

class DEBUGGER__::ProcessGroup
  def after_fork(); end

  def lock(); end

  def locked?(); end

  def multi?(); end

  def multi_process!(); end

  def sync(); end

  def trylock(); end

  def unlock(); end
end

class DEBUGGER__::Session
  def activate_irb_integration(); end

  def after_fork_parent(); end

  def before_fork(need_lock=T.unsafe(nil)); end

  def capture_exception_frames(*exclude_path); end

  def check_postmortem(); end

  def check_unsafe(); end

  def enter_postmortem_session(exc); end

  def extend_feature(session: T.unsafe(nil), thread_client: T.unsafe(nil), ui: T.unsafe(nil)); end

  def intercept_trap_sigint(flag, &b); end

  def intercept_trap_sigint?(); end

  def intercept_trap_sigint_end(); end

  def intercept_trap_sigint_start(prev); end

  def postmortem=(is_enable); end

  def process_info(); end

  def save_int_trap(cmd); end

  def set_no_sigint_hook(old, new); end

  def width(); end
  BREAK_KEYWORDS = ::T.let(nil, ::T.untyped)
  METHOD_ADDED_TRACKERS = ::T.let(nil, ::T.untyped)
end

class DEBUGGER__::Session
  def self.activate_method_added_trackers(); end

  def self.create_method_added_tracker(mod, method_added_id, method_accessor=T.unsafe(nil)); end

  def self.deactivate_method_added_trackers(); end
end

class DEBUGGER__::ThreadClient
  SPECIAL_LOCAL_VARS = ::T.let(nil, ::T.untyped)
  SUPPORT_TARGET_THREAD = ::T.let(nil, ::T.untyped)
end

module DEBUGGER__::TrapInterceptor
  def trap(sig, *command, &command_proc); end
end

class DEBUGGER__::UI_Base
  def event(type, *args); end

  def flush(); end

  def ignore_output_on_suspend?(); end
end

class DEBUGGER__::UI_LocalConsole
  def activate(session, on_fork: T.unsafe(nil)); end

  def activate_sigint(); end

  def after_fork_parent(); end

  def ask(prompt); end

  def deactivate(); end

  def deactivate_sigint(); end

  def puts(str=T.unsafe(nil)); end

  def quit(n); end

  def readline(prompt=T.unsafe(nil)); end

  def remote?(); end

  def setup_interrupt(); end

  def width(); end
end

module DEBUGGER__
  def self.add_catch_breakpoint(pat); end

  def self.add_line_breakpoint(file, line, **kw); end

  def self.check_loglevel(level); end

  def self.compare_path(a, b); end

  def self.debug(&b); end

  def self.info(msg); end

  def self.initialize_session(&init_ui); end

  def self.load_rc(); end

  def self.log(level, msg); end

  def self.open(host: T.unsafe(nil), port: T.unsafe(nil), sock_path: T.unsafe(nil), sock_dir: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end

  def self.open_tcp(port:, host: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end

  def self.open_unix(sock_path: T.unsafe(nil), sock_dir: T.unsafe(nil), nonstop: T.unsafe(nil), **kw); end

  def self.require_location(); end

  def self.safe_inspect(obj, max_length: T.unsafe(nil), short: T.unsafe(nil)); end

  def self.setup_initial_suspend(); end

  def self.skip?(); end

  def self.skip_all(); end

  def self.start(nonstop: T.unsafe(nil), **kw); end

  def self.step_in(&b); end

  def self.warn(msg); end
end

module DRb
  VERSION = ::T.let(nil, ::T.untyped)
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.make_pool(); end

  def self.open(remote_uri); end

  def self.stop_pool(); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end
end

class DRb::DRbServer::InvokeMethod
  def initialize(drb_server, client); end

  def perform(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

class DRb::DRbServer
  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

class DRb::ThreadObject
  def _execute(); end

  def alive?(); end

  def initialize(&blk); end

  def kill(); end

  def method_missing(msg, *arg, &blk); end
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  def deconstruct_keys(arg); end

  def infinite?(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class DateTime
  def self.new(*arg); end
end

module DeadEnd
  DEFAULT_VALUE = ::T.let(nil, ::T.untyped)
  TIMEOUT_DEFAULT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DeadEnd::AroundBlockScan
  def after_index(); end

  def before_index(); end

  def capture_neighbor_context(); end

  def code_block(); end

  def initialize(code_lines:, block:); end

  def lines(); end

  def next_down(); end

  def next_up(); end

  def on_falling_indent(); end

  def scan_adjacent_indent(); end

  def scan_neighbors(); end

  def scan_while(); end

  def skip(name); end

  def start_at_next_line(); end

  def stop_after_kw(); end
end

class DeadEnd::AroundBlockScan
end

class DeadEnd::BlockExpand
  def call(block); end

  def expand_indent(block); end

  def expand_neighbors(block); end

  def initialize(code_lines:); end
end

class DeadEnd::BlockExpand
end

class DeadEnd::CaptureCodeContext
  def call(); end

  def capture_before_after_kws(block); end

  def capture_falling_indent(block); end

  def capture_first_kw_end_same_indent(block); end

  def capture_last_end_same_indent(block); end

  def code_lines(); end

  def initialize(blocks:, code_lines:); end
end

class DeadEnd::CaptureCodeContext
end

class DeadEnd::CleanDocument
  def call(); end

  def clean_sweep(source:); end

  def initialize(source:); end

  def join_consecutive!(); end

  def join_groups(groups); end

  def join_heredoc!(); end

  def join_trailing_slash!(); end

  def lines(); end

  def take_while_including(range=T.unsafe(nil)); end
end

class DeadEnd::CleanDocument
end

class DeadEnd::Cli
  def call(); end

  def initialize(argv:, exit_obj: T.unsafe(nil), io: T.unsafe(nil), env: T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parse(); end

  def parser(); end
end

class DeadEnd::Cli
end

class DeadEnd::CodeBlock
  def current_indent(); end

  def delete(); end

  def deleted?(); end

  def ends_at(); end

  def hidden?(); end

  def initialize(lines: T.unsafe(nil)); end

  def invalid?(); end

  def is_end?(); end

  def lines(); end

  def mark_invisible(); end

  def starts_at(); end

  def valid?(); end

  def visible_lines(); end
  UNSET = ::T.let(nil, ::T.untyped)
end

class DeadEnd::CodeBlock
end

class DeadEnd::CodeFrontier
  def <<(block); end

  def count(); end

  def detect_invalid_blocks(); end

  def expand?(); end

  def holds_all_syntax_errors?(block_array=T.unsafe(nil), can_cache: T.unsafe(nil)); end

  def initialize(code_lines:, unvisited: T.unsafe(nil)); end

  def next_indent_line(); end

  def pop(); end

  def register_engulf_block(block); end

  def register_indent_block(block); end
end

class DeadEnd::CodeFrontier
  def self.combination(array); end
end

class DeadEnd::CodeLine
  def empty?(); end

  def hidden?(); end

  def ignore_newline_not_beg?(); end

  def indent(); end

  def indent_index(); end

  def index(); end

  def initialize(line:, index:, lex:); end

  def is_end?(); end

  def is_kw?(); end

  def lex(); end

  def line(); end

  def line_number(); end

  def mark_invisible(); end

  def not_empty?(); end

  def number(); end

  def original(); end

  def trailing_slash?(); end

  def visible?(); end
  TRAILING_SLASH = ::T.let(nil, ::T.untyped)
end

class DeadEnd::CodeLine
  def self.from_source(source, lines: T.unsafe(nil)); end
end

class DeadEnd::CodeSearch
  def call(); end

  def code_lines(); end

  def create_blocks_from_untracked_lines(); end

  def expand_existing(); end

  def initialize(source, record_dir: T.unsafe(nil)); end

  def invalid_blocks(); end

  def push(block, name:); end

  def record(block:, name: T.unsafe(nil)); end

  def record_dir(); end
end

class DeadEnd::CodeSearch
end

class DeadEnd::DisplayCodeWithLineNumbers
  def call(); end

  def initialize(lines:, highlight_lines: T.unsafe(nil), terminal: T.unsafe(nil)); end
  TERMINAL_END = ::T.let(nil, ::T.untyped)
  TERMINAL_HIGHLIGHT = ::T.let(nil, ::T.untyped)
end

class DeadEnd::DisplayCodeWithLineNumbers
end

class DeadEnd::DisplayInvalidBlocks
  def call(); end

  def document_ok?(); end

  def filename(); end

  def initialize(code_lines:, blocks:, io: T.unsafe(nil), filename: T.unsafe(nil), terminal: T.unsafe(nil)); end
end

class DeadEnd::DisplayInvalidBlocks
end

class DeadEnd::Error
end

class DeadEnd::Error
end

class DeadEnd::ExplainSyntax
  def call(); end

  def errors(); end

  def initialize(code_lines:); end

  def missing(); end

  def why(miss); end
  INVERSE = ::T.let(nil, ::T.untyped)
end

class DeadEnd::ExplainSyntax
end

class DeadEnd::LeftRightLexCount
  def count_end(); end

  def count_for_char(char); end

  def count_kw(); end

  def count_lex(lex); end

  def missing(); end
  PAIRS = ::T.let(nil, ::T.untyped)
end

class DeadEnd::LeftRightLexCount
end

class DeadEnd::LexAll
  include ::Enumerable
  def [](index); end

  def each(&blk); end

  def initialize(source:, source_lines: T.unsafe(nil)); end

  def last(); end

  def to_a(); end
end

class DeadEnd::LexAll
end

class DeadEnd::LexValue
  def expr_beg?(); end

  def expr_label?(); end

  def fname?(); end

  def ignore_newline?(); end

  def initialize(line, type, token, state, last_lex=T.unsafe(nil)); end

  def is_end?(); end

  def is_kw?(); end

  def line(); end

  def state(); end

  def token(); end

  def type(); end
end

class DeadEnd::LexValue
end

class DeadEnd::ParseBlocksFromIndentLine
  def code_lines(); end

  def each_neighbor_block(target_line); end

  def initialize(code_lines:); end
end

class DeadEnd::ParseBlocksFromIndentLine
end

class DeadEnd::PathnameFromMessage
  def call(); end

  def initialize(message, io: T.unsafe(nil)); end

  def name(); end

  def skip_missing_file_name?(); end

  def stop?(); end
  EVAL_RE = ::T.let(nil, ::T.untyped)
  STREAMING_RE = ::T.let(nil, ::T.untyped)
end

class DeadEnd::PathnameFromMessage
end

class DeadEnd::PriorityEngulfQueue
  def empty?(); end

  def length(); end

  def peek(); end

  def pop(); end

  def push(block); end

  def to_a(); end
end

class DeadEnd::PriorityEngulfQueue
end

class DeadEnd::PriorityQueue
  def <<(element); end

  def elements(); end

  def empty?(); end

  def exchange(source, target); end

  def length(); end

  def peek(); end

  def pop(); end

  def sorted(); end

  def to_a(); end
end

class DeadEnd::PriorityQueue
end

class DeadEnd::RipperErrors
  def call(); end

  def errors(); end

  def on_alias_error(msg); end

  def on_assign_error(msg); end

  def on_class_name_error(msg); end

  def on_param_error(msg); end

  def on_parse_error(msg); end
end

class DeadEnd::RipperErrors
end

class DeadEnd::UnvisitedLines
  def empty?(); end

  def initialize(code_lines:); end

  def peek(); end

  def pop(); end

  def visit_block(block); end
end

class DeadEnd::UnvisitedLines
end

module DeadEnd
  def self.call(source:, filename: T.unsafe(nil), terminal: T.unsafe(nil), record_dir: T.unsafe(nil), timeout: T.unsafe(nil), io: T.unsafe(nil)); end

  def self.handle_error(e, re_raise: T.unsafe(nil), io: T.unsafe(nil)); end

  def self.invalid?(source); end

  def self.record_dir(dir); end

  def self.valid?(source); end

  def self.valid_without?(without_lines:, code_lines:); end
end

class DebugInspector
  def backtrace_locations(); end

  def frame_binding(arg); end

  def frame_class(arg); end

  def frame_iseq(arg); end

  def frame_self(arg); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class DebugInspector
  def self.open(); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Devise
  ALL = ::T.let(nil, ::T.untyped)
  CONTROLLERS = ::T.let(nil, ::T.untyped)
  NO_INPUT = ::T.let(nil, ::T.untyped)
  ROUTES = ::T.let(nil, ::T.untyped)
  STRATEGIES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
  URL_HELPERS = ::T.let(nil, ::T.untyped)
end

class Devise::ConfirmationsController
  def after_confirmation_path_for(resource_name, resource); end

  def after_resending_confirmation_instructions_path_for(resource_name); end

  def create(); end

  def new(); end

  def show(); end
end

module Devise::Controllers::Helpers
  def authenticate_user!(opts=T.unsafe(nil)); end

  def current_user(); end

  def user_session(); end

  def user_signed_in?(); end
end

module Devise::Controllers::Rememberable
  def forget_cookie_values(resource); end

  def forget_me(resource); end

  def remember_cookie_values(resource); end

  def remember_key(resource, scope); end

  def remember_me(resource); end

  def remember_me_is_active?(resource); end
end

module Devise::Controllers::Rememberable
  def self.cookie_values(); end
end

module Devise::Controllers::UrlHelpers
  def cancel_registration_path(resource_or_scope, *args); end

  def cancel_registration_url(resource_or_scope, *args); end

  def confirmation_path(resource_or_scope, *args); end

  def confirmation_url(resource_or_scope, *args); end

  def destroy_session_path(resource_or_scope, *args); end

  def destroy_session_url(resource_or_scope, *args); end

  def edit_password_path(resource_or_scope, *args); end

  def edit_password_url(resource_or_scope, *args); end

  def edit_registration_path(resource_or_scope, *args); end

  def edit_registration_url(resource_or_scope, *args); end

  def new_confirmation_path(resource_or_scope, *args); end

  def new_confirmation_url(resource_or_scope, *args); end

  def new_password_path(resource_or_scope, *args); end

  def new_password_url(resource_or_scope, *args); end

  def new_registration_path(resource_or_scope, *args); end

  def new_registration_url(resource_or_scope, *args); end

  def new_session_path(resource_or_scope, *args); end

  def new_session_url(resource_or_scope, *args); end

  def password_path(resource_or_scope, *args); end

  def password_url(resource_or_scope, *args); end

  def registration_path(resource_or_scope, *args); end

  def registration_url(resource_or_scope, *args); end

  def session_path(resource_or_scope, *args); end

  def session_url(resource_or_scope, *args); end
end

module Devise::Controllers::UrlHelpers
  def self.generate_helpers!(routes=T.unsafe(nil)); end

  def self.remove_helpers!(); end
end

class Devise::Delegator
  def call(env); end

  def failure_app(env); end
end

Devise::DeprecatedConstantAccessor = ActiveSupport::Deprecation::DeprecatedConstantAccessor

module Devise::Encryptor
end

module Devise::Encryptor
  def self.compare(klass, hashed_password, password); end

  def self.digest(klass, password); end
end

class Devise::FailureApp
  def __callbacks(); end

  def __callbacks?(); end

  def _process_action_callbacks(); end

  def _run_process_action_callbacks(&block); end

  def attempted_path(); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end

  def flash(*arg, **arg1, &arg2); end

  def http_auth(); end

  def http_auth?(); end

  def http_auth_body(); end

  def http_auth_header?(); end

  def i18n_locale(); end

  def i18n_message(default=T.unsafe(nil)); end

  def i18n_options(options); end

  def is_flashing_format?(); end

  def is_navigational_format?(); end

  def logger(); end

  def logger=(value); end

  def raise_on_missing_callback_actions(); end

  def raise_on_missing_callback_actions=(val); end

  def raise_on_open_redirects(); end

  def raise_on_open_redirects=(val); end

  def recall(); end

  def recall_app(app); end

  def redirect(); end

  def redirect_url(); end

  def relative_url_root(); end

  def relative_url_root?(); end

  def request_format(); end

  def respond(); end

  def route(scope); end

  def scope(); end

  def scope_class(); end

  def scope_url(); end

  def skip_format?(); end

  def store_location!(); end

  def warden(); end

  def warden_message(); end

  def warden_options(); end
end

class Devise::FailureApp
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self.call(env); end

  def self.default_url_options(*args); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.raise_on_missing_callback_actions(); end

  def self.raise_on_missing_callback_actions=(val); end

  def self.raise_on_open_redirects(); end

  def self.raise_on_open_redirects=(val); end
end

class Devise::Hooks::Proxy
  include ::Devise::Controllers::Rememberable
  include ::Devise::Controllers::SignInOut
  def cookies(*arg, **arg1, &arg2); end

  def initialize(warden); end

  def request(*arg, **arg1, &arg2); end

  def session(); end

  def warden(); end
end

class Devise::Hooks::Proxy
end

class Devise::Mailer
  def confirmation_instructions(record, token, opts=T.unsafe(nil)); end

  def email_changed(record, opts=T.unsafe(nil)); end

  def password_change(record, opts=T.unsafe(nil)); end

  def reset_password_instructions(record, token, opts=T.unsafe(nil)); end

  def unlock_instructions(record, token, opts=T.unsafe(nil)); end
end

module Devise::Mailers::Helpers
  def devise_mail(record, action, opts=T.unsafe(nil), &block); end

  def devise_mapping(); end

  def headers_for(action, opts); end

  def initialize_from_record(record); end

  def mailer_from(mapping); end

  def mailer_reply_to(mapping); end

  def mailer_sender(mapping, sender=T.unsafe(nil)); end

  def resource(); end

  def scope_name(); end

  def subject_for(key); end

  def template_paths(); end
end

module Devise::Models::Authenticatable
  UNSAFE_ATTRIBUTES_FOR_SERIALIZATION = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Confirmable
  def active_for_authentication?(); end

  def after_confirmation(); end

  def confirm(args=T.unsafe(nil)); end

  def confirmation_period_expired?(); end

  def confirmation_period_valid?(); end

  def confirmation_required?(); end

  def confirmed?(); end

  def generate_confirmation_token(); end

  def generate_confirmation_token!(); end

  def inactive_message(); end

  def initialize(*args, &block); end

  def pending_any_confirmation(); end

  def pending_reconfirmation?(); end

  def postpone_email_change?(); end

  def postpone_email_change_until_confirmation_and_regenerate_confirmation_token(); end

  def reconfirmation_required?(); end

  def resend_confirmation_instructions(); end

  def send_confirmation_instructions(); end

  def send_confirmation_notification?(); end

  def send_email_changed_notification?(); end

  def send_on_create_confirmation_instructions(); end

  def send_reconfirmation_instructions(); end

  def skip_confirmation!(); end

  def skip_confirmation_notification!(); end

  def skip_reconfirmation!(); end

  def skip_reconfirmation_in_callback!(); end
end

module Devise::Models::Confirmable::ClassMethods
  def allow_unconfirmed_access_for(); end

  def allow_unconfirmed_access_for=(value); end

  def confirm_by_token(confirmation_token); end

  def confirm_within(); end

  def confirm_within=(value); end

  def confirmation_keys(); end

  def confirmation_keys=(value); end

  def find_by_unconfirmed_email_with_errors(attributes=T.unsafe(nil)); end

  def reconfirmable(); end

  def reconfirmable=(value); end

  def send_confirmation_instructions(attributes=T.unsafe(nil)); end
end

module Devise::Models::Confirmable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Confirmable
  def self.required_fields(klass); end
end

module Devise::Models::DatabaseAuthenticatable
  def after_database_authentication(); end

  def authenticatable_salt(); end

  def clean_up_passwords(); end

  def destroy_with_password(current_password); end

  def initialize(*args, &block); end

  def password=(new_password); end

  def password_digest(password); end

  def send_email_changed_notification(); end

  def send_email_changed_notification?(); end

  def send_password_change_notification(); end

  def send_password_change_notification?(); end

  def skip_email_changed_notification!(); end

  def skip_password_change_notification!(); end

  def update_with_password(params, *options); end

  def update_without_password(params, *options); end

  def valid_password?(password); end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  def find_for_database_authentication(conditions); end

  def pepper(); end

  def pepper=(value); end

  def send_email_changed_notification(); end

  def send_email_changed_notification=(value); end

  def send_password_change_notification(); end

  def send_password_change_notification=(value); end

  def stretches(); end

  def stretches=(value); end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::DatabaseAuthenticatable
  def self.required_fields(klass); end
end

module Devise::Models::Lockable
  def access_locked?(); end

  def active_for_authentication?(); end

  def attempts_exceeded?(); end

  def if_access_locked(); end

  def inactive_message(); end

  def increment_failed_attempts(); end

  def last_attempt?(); end

  def lock_access!(opts=T.unsafe(nil)); end

  def lock_expired?(); end

  def lock_strategy_enabled?(*arg, **arg1, &arg2); end

  def resend_unlock_instructions(); end

  def reset_failed_attempts!(); end

  def send_unlock_instructions(); end

  def unauthenticated_message(); end

  def unlock_access!(); end

  def unlock_strategy_enabled?(*arg, **arg1, &arg2); end

  def valid_for_authentication?(); end
end

module Devise::Models::Lockable::ClassMethods
  def last_attempt_warning(); end

  def last_attempt_warning=(value); end

  def lock_strategy(); end

  def lock_strategy=(value); end

  def lock_strategy_enabled?(strategy); end

  def maximum_attempts(); end

  def maximum_attempts=(value); end

  def send_unlock_instructions(attributes=T.unsafe(nil)); end

  def unlock_access_by_token(unlock_token); end

  def unlock_in(); end

  def unlock_in=(value); end

  def unlock_keys(); end

  def unlock_keys=(value); end

  def unlock_strategy(); end

  def unlock_strategy=(value); end

  def unlock_strategy_enabled?(strategy); end
  BOTH_STRATEGIES = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Lockable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Lockable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::Recoverable
  def clear_reset_password_token(); end

  def clear_reset_password_token?(); end

  def reset_password(new_password, new_password_confirmation); end

  def reset_password_period_valid?(); end

  def send_reset_password_instructions(); end

  def send_reset_password_instructions_notification(token); end

  def set_reset_password_token(); end
end

module Devise::Models::Recoverable::ClassMethods
  def reset_password_by_token(attributes=T.unsafe(nil)); end

  def reset_password_keys(); end

  def reset_password_keys=(value); end

  def reset_password_within(); end

  def reset_password_within=(value); end

  def send_reset_password_instructions(attributes=T.unsafe(nil)); end

  def sign_in_after_reset_password(); end

  def sign_in_after_reset_password=(value); end

  def with_reset_password_token(token); end
end

module Devise::Models::Recoverable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Recoverable
  def self.required_fields(klass); end
end

module Devise::Models::Registerable::ClassMethods
  def new_with_session(params, session); end

  def sign_in_after_change_password(); end

  def sign_in_after_change_password=(value); end
end

module Devise::Models::Registerable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Registerable
  def self.required_fields(klass); end
end

module Devise::Models::Rememberable
  def after_remembered(); end

  def extend_remember_period(); end

  def forget_me!(); end

  def remember_expires_at(); end

  def remember_me(); end

  def remember_me!(); end

  def remember_me=(remember_me); end

  def remember_me?(token, generated_at); end

  def rememberable_options(); end

  def rememberable_value(); end
end

module Devise::Models::Rememberable::ClassMethods
  def expire_all_remember_me_on_sign_out(); end

  def expire_all_remember_me_on_sign_out=(value); end

  def extend_remember_period(); end

  def extend_remember_period=(value); end

  def remember_for(); end

  def remember_for=(value); end

  def remember_token(); end

  def rememberable_options(); end

  def rememberable_options=(value); end

  def serialize_from_cookie(*args); end

  def serialize_into_cookie(record); end
end

module Devise::Models::Rememberable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Rememberable
  def self.required_fields(klass); end
end

module Devise::Models::Timeoutable
  def timedout?(last_access); end

  def timeout_in(); end
end

module Devise::Models::Timeoutable::ClassMethods
  def timeout_in(); end

  def timeout_in=(value); end
end

module Devise::Models::Timeoutable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Timeoutable
  extend ::ActiveSupport::Concern
  def self.required_fields(klass); end
end

module Devise::Models::Trackable
  def extract_ip_from(request); end

  def update_tracked_fields(request); end

  def update_tracked_fields!(request); end
end

module Devise::Models::Trackable
  def self.required_fields(klass); end
end

module Devise::Models::Validatable
  def email_required?(); end

  def password_required?(); end
  VALIDATIONS = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Validatable::ClassMethods
  def email_regexp(); end

  def email_regexp=(value); end

  def password_length(); end

  def password_length=(value); end
end

module Devise::Models::Validatable::ClassMethods
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Validatable
  def self.assert_validations_api!(base); end

  def self.included(base); end

  def self.required_fields(klass); end
end

class Devise::OmniauthCallbacksController
  def after_omniauth_failure_path_for(scope); end

  def failed_strategy(); end

  def failure(); end

  def failure_message(); end

  def passthru(); end
end

module Devise::Orm::DirtyTrackingNewMethods
  def devise_email_before_last_save(); end

  def devise_email_in_database(); end

  def devise_respond_to_and_will_save_change_to_attribute?(attribute); end

  def devise_saved_change_to_email?(); end

  def devise_saved_change_to_encrypted_password?(); end

  def devise_will_save_change_to_email?(); end
end

module Devise::Orm::DirtyTrackingOldMethods
  def devise_email_before_last_save(); end

  def devise_email_in_database(); end

  def devise_respond_to_and_will_save_change_to_attribute?(attribute); end

  def devise_saved_change_to_email?(); end

  def devise_saved_change_to_encrypted_password?(); end

  def devise_will_save_change_to_email?(); end
end

module Devise::Orm
  def self.active_record?(model); end

  def self.active_record_51?(model); end

  def self.included(model); end
end

class Devise::ParameterFilter
  def filter(conditions); end

  def filtered_hash_by_method_for_given_keys(conditions, method, condition_keys); end

  def initialize(case_insensitive_keys, strip_whitespace_keys); end

  def stringify_params(conditions); end
end

class Devise::ParameterFilter
end

class Devise::ParameterSanitizer
  def initialize(resource_class, resource_name, params); end

  def permit(action, keys: T.unsafe(nil), except: T.unsafe(nil), &block); end

  def sanitize(action); end
  DEFAULT_PERMITTED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Devise::ParameterSanitizer
end

class Devise::PasswordsController
  def after_resetting_password_path_for(resource); end

  def after_sending_reset_password_instructions_path_for(resource_name); end

  def assert_reset_token_passed(); end

  def create(); end

  def edit(); end

  def new(); end

  def unlockable?(resource); end

  def update(); end
end

class Devise::RegistrationsController
  def account_update_params(); end

  def after_inactive_sign_up_path_for(resource); end

  def after_sign_up_path_for(resource); end

  def after_update_path_for(resource); end

  def authenticate_scope!(); end

  def build_resource(hash=T.unsafe(nil)); end

  def cancel(); end

  def create(); end

  def destroy(); end

  def edit(); end

  def new(); end

  def sign_up(resource_name, resource); end

  def sign_up_params(); end

  def update(); end

  def update_needs_confirmation?(resource, previous); end

  def update_resource(resource, params); end
end

class Devise::SecretKeyFinder
  def find(); end

  def initialize(application); end
end

class Devise::SecretKeyFinder
end

class Devise::SessionsController
  def auth_options(); end

  def create(); end

  def destroy(); end

  def new(); end

  def serialize_options(resource); end

  def sign_in_params(); end
end

class Devise::Strategies::Authenticatable
  def authentication_hash(); end

  def authentication_hash=(authentication_hash); end

  def authentication_type(); end

  def authentication_type=(authentication_type); end

  def clean_up_csrf?(); end

  def password(); end

  def password=(password); end
end

class Devise::Strategies::Base
  def mapping(); end
end

class Devise::Strategies::DatabaseAuthenticatable
  def authenticate!(); end
end

class Devise::Strategies::Rememberable
  def authenticate!(); end
end

module Devise::Test::ControllerHelpers
  def _catch_warden(&block); end

  def _process_unauthenticated(env, options=T.unsafe(nil)); end

  def process(*arg, **arg1); end

  def setup_controller_for_warden(); end

  def sign_in(resource, deprecated=T.unsafe(nil), scope: T.unsafe(nil)); end

  def sign_out(resource_or_scope); end

  def warden(); end
end

module Devise::Test::ControllerHelpers
  extend ::ActiveSupport::Concern
end

module Devise::Test::IntegrationHelpers
  def setup_integration_for_devise(); end

  def sign_in(resource, scope: T.unsafe(nil)); end

  def sign_out(resource_or_scope); end

  def teardown_integration_for_devise(); end
end

module Devise::Test::IntegrationHelpers
  def self.included(base); end
end

module Devise::TestHelpers
end

module Devise::TestHelpers
  def self.included(base); end
end

class Devise::TimeInflector
  include ::ActionView::Helpers::DateHelper
end

class Devise::TimeInflector
  def self.instance(); end

  def self.time_ago_in_words(*arg, **arg1, &arg2); end
end

class Devise::TokenGenerator
  def digest(klass, column, value); end

  def generate(klass, column); end

  def initialize(key_generator, digest=T.unsafe(nil)); end
end

class Devise::UnlocksController
  def after_sending_unlock_instructions_path_for(resource); end

  def after_unlock_path_for(resource); end

  def create(); end

  def new(); end

  def show(); end
end

class DeviseController
  def assert_is_devise_resource!(); end

  def clean_up_passwords(object); end

  def devise_i18n_options(options); end

  def devise_mapping(); end

  def find_message(kind, options=T.unsafe(nil)); end

  def navigational_formats(); end

  def require_no_authentication(); end

  def resource(); end

  def resource=(new_resource); end

  def resource_class(); end

  def resource_name(); end

  def resource_params(); end

  def respond_with_navigational(*args, &block); end

  def scope_name(); end

  def set_flash_message(key, kind, options=T.unsafe(nil)); end

  def set_flash_message!(key, kind, options=T.unsafe(nil)); end

  def set_minimum_password_length(); end

  def signed_in_resource(); end

  def successfully_sent?(resource); end

  def translation_scope(); end

  def unknown_action!(msg); end
end

module DeviseController::HelperMethods
  include ::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::DeviseI18n::ViewHelpers
  include ::ApplicationHelper
  include ::AnniversariesHelper
  include ::BirthdaysHelper
  include ::CheckoutHelper
  include ::MembersHelper
  include ::ParticipantsHelper
  include ::RoomsHelper
  include ::SubmitStoriesHelper
  include ::TodoItemsHelper
  include ::DeviseHelper
  def devise_mapping(*args, **arg, &block); end

  def resource(*args, **arg, &block); end

  def resource_class(*args, **arg, &block); end

  def resource_name(*args, **arg, &block); end

  def resource_params(*args, **arg, &block); end

  def scope_name(*args, **arg, &block); end

  def signed_in_resource(*args, **arg, &block); end
end

module DeviseHelper
  def devise_error_messages!(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def detailed_message(highlight: T.unsafe(nil), did_you_mean: T.unsafe(nil), **arg); end

  def original_message(); end

  def spell_checker(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Diff::LCS
  def diff(other, callbacks=T.unsafe(nil), &block); end

  def lcs(other, &block); end

  def patch(patchset); end

  def patch!(patchset); end

  def patch_me(patchset); end

  def sdiff(other, callbacks=T.unsafe(nil), &block); end

  def traverse_balanced(other, callbacks=T.unsafe(nil), &block); end

  def traverse_sequences(other, callbacks=T.unsafe(nil), &block); end

  def unpatch(patchset); end

  def unpatch!(patchset); end

  def unpatch_me(patchset); end
  VERSION = ::T.let(nil, ::T.untyped)
end

Diff::LCS::BalancedCallbacks = Diff::LCS::DefaultCallbacks

class Diff::LCS::Block
  def changes(); end

  def diff_size(); end

  def initialize(chunk); end

  def insert(); end

  def op(); end

  def remove(); end
end

class Diff::LCS::Change
  def ==(other); end

  def action(); end

  def adding?(); end

  def changed?(); end

  def deleting?(); end

  def element(); end

  def finished_a?(); end

  def finished_b?(); end

  def initialize(*args); end

  def inspect(*_args); end

  def position(); end

  def to_a(); end

  def to_ary(); end

  def unchanged?(); end
  VALID_ACTIONS = ::T.let(nil, ::T.untyped)
end

Diff::LCS::Change::IntClass = Integer

class Diff::LCS::Change
  def self.from_a(arr); end

  def self.valid_action?(action); end
end

class Diff::LCS::ContextChange
  def new_element(); end

  def new_position(); end

  def old_element(); end

  def old_position(); end
end

class Diff::LCS::ContextChange
  def self.simplify(event); end
end

class Diff::LCS::ContextDiffCallbacks
  def change(event); end
end

class Diff::LCS::DefaultCallbacks
  def self.change(event); end

  def self.discard_a(event); end

  def self.discard_b(event); end

  def self.match(event); end
end

class Diff::LCS::DiffCallbacks
  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def finish(); end

  def match(_event); end
end

class Diff::LCS::Hunk
  def blocks(); end

  def diff(format, last=T.unsafe(nil)); end

  def end_new(); end

  def end_old(); end

  def file_length_difference(); end

  def flag_context(); end

  def flag_context=(context); end

  def initialize(data_old, data_new, piece, flag_context, file_length_difference); end

  def merge(hunk); end

  def missing_last_newline?(data); end

  def overlaps?(hunk); end

  def start_new(); end

  def start_old(); end

  def unshift(hunk); end
end

module Diff::LCS::Internals
  def self.analyze_patchset(patchset, depth=T.unsafe(nil)); end

  def self.intuit_diff_direction(src, patchset, limit=T.unsafe(nil)); end

  def self.lcs(a, b); end
end

class Diff::LCS::SDiffCallbacks
  def change(event); end

  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def match(event); end
end

Diff::LCS::SequenceCallbacks = Diff::LCS::DefaultCallbacks

module Diff::LCS
  def self.LCS(seq1, seq2, &block); end

  def self.callbacks_for(callbacks); end

  def self.diff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.lcs(seq1, seq2, &block); end

  def self.patch(src, patchset, direction=T.unsafe(nil)); end

  def self.patch!(src, patchset); end

  def self.sdiff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.traverse_balanced(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.traverse_sequences(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.unpatch!(src, patchset); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  def self.uuid_from_hash(hash_class, namespace, name); end

  def self.uuid_v3(uuid_namespace, name); end

  def self.uuid_v4(); end

  def self.uuid_v5(uuid_namespace, name); end
end

class Dir
  def chdir(); end

  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.fchdir(arg); end

  def self.for_fd(arg); end
end

class Donation
  include ::Donation::GeneratedAttributeMethods
  include ::Donation::GeneratedAssociationMethods
  def autosave_associated_records_for_user(*args); end
end

module Donation::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Donation::GeneratedAssociationMethods
end

module Donation::GeneratedAttributeMethods
end

module Donation::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Dotenv
  def instrumenter(); end

  def instrumenter=(instrumenter); end

  def load(*filenames, overwrite: T.unsafe(nil), ignore: T.unsafe(nil)); end

  def load!(*filenames); end

  def modify(env=T.unsafe(nil), &block); end

  def overload(*filenames); end

  def overload!(*filenames); end

  def overwrite(*filenames); end

  def overwrite!(*filenames); end

  def parse(*filenames, overwrite: T.unsafe(nil), ignore: T.unsafe(nil), &block); end

  def require_keys(*keys); end

  def restore(env=T.unsafe(nil), safe: T.unsafe(nil)); end

  def save(); end

  def update(env=T.unsafe(nil), overwrite: T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dotenv::Diff
  def a(); end

  def added(); end

  def any?(); end

  def b(); end

  def changed(); end

  def env(); end

  def initialize(a: T.unsafe(nil), b: T.unsafe(nil), &block); end

  def removed(); end
end

class Dotenv::Environment
  def filename(); end

  def initialize(filename, overwrite: T.unsafe(nil)); end

  def load(); end

  def overwrite(); end

  def read(); end
end

class Dotenv::LogSubscriber
  def load(event); end

  def restore(event); end

  def save(event); end

  def update(event); end
end

class Dotenv::MissingKeys
  def initialize(keys); end
end

class Dotenv::Parser
  def call(); end

  def initialize(string, overwrite: T.unsafe(nil)); end
  LINE = ::T.let(nil, ::T.untyped)
end

class Dotenv::Parser
  def self.call(*arg, **arg1, &arg2); end

  def self.substitutions(); end
end

class Dotenv::Rails
  def autorestore(*arg, **arg1, &arg2); end

  def autorestore=(arg); end

  def deprecator(); end

  def env(); end

  def files(*arg, **arg1, &arg2); end

  def files=(arg); end

  def load(); end

  def logger(*arg, **arg1, &arg2); end

  def logger=(new_logger); end

  def overload(); end

  def overwrite(*arg, **arg1, &arg2); end

  def overwrite=(arg); end

  def root(); end
  TEST_RAKE_TASKS = ::T.let(nil, ::T.untyped)
end

class Dotenv::Rails
  def self.load(); end
end

class Dotenv::ReplayLogger
  def add(*args, &block); end

  def initialize(); end

  def replay(logger); end
end

module Dotenv::Substitutions::Command
  def self.call(value, _env, overwrite: T.unsafe(nil)); end
end

module Dotenv::Substitutions::Variable
  def self.call(value, env, overwrite: T.unsafe(nil)); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Escape
end

module ERB::Escape
  def self.html_escape(arg); end
end

module ERB::Util
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  INVALID_TAG_NAME_FOLLOWING_REGEXP = ::T.let(nil, ::T.untyped)
  INVALID_TAG_NAME_START_REGEXP = ::T.let(nil, ::T.untyped)
  SAFE_XML_TAG_NAME_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_NAME_FOLLOWING_CODEPOINTS = ::T.let(nil, ::T.untyped)
  TAG_NAME_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
  TAG_NAME_START_CODEPOINTS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  extend ::ActiveSupport::CoreExt::ERBUtil
end

class EmailSpec::AddressConverter
  def conversion(&block); end

  def convert(input); end

  def converter(); end

  def converter=(converter); end
end

module EmailSpec::Deliveries
  def all_emails(); end

  def deliveries(); end

  def last_email_sent(); end

  def mailbox_for(address); end

  def mailer(); end

  def parse_ar_to_mail(email); end

  def reset_mailer(); end
end

class EmailSpec::EmailViewer
  def self.open_in_browser(filename); end

  def self.open_in_text_editor(filename); end

  def self.save_and_open_all_html_emails(); end

  def self.save_and_open_all_raw_emails(); end

  def self.save_and_open_all_text_emails(); end

  def self.save_and_open_email(mail); end

  def self.save_and_open_email_attachments_list(mail); end

  def self.tmp_email_filename(extension=T.unsafe(nil)); end
end

module EmailSpec::Helpers
  def click_email_link_matching(regex, email=T.unsafe(nil)); end

  def click_first_link_in_email(email=T.unsafe(nil)); end

  def current_email(address=T.unsafe(nil)); end

  def current_email_attachments(address=T.unsafe(nil)); end

  def find_email(address, opts=T.unsafe(nil)); end

  def links_in_email(email); end

  def open_email(address, opts=T.unsafe(nil)); end

  def open_email_for(address, opts=T.unsafe(nil)); end

  def open_last_email(); end

  def open_last_email_for(address); end

  def read_emails_for(address); end

  def unread_emails_for(address); end

  def visit_in_email(link_text, address=T.unsafe(nil)); end
  A_TAG_BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  A_TAG_END_REGEX = ::T.let(nil, ::T.untyped)
end

module EmailSpec::MailExt
  def default_part(); end

  def default_part_body(); end

  def html(); end
end

module EmailSpec::Matchers
  def bcc_to(*expected_email_addresses_or_objects_that_respond_to_email); end

  def be_delivered_from(email); end

  def be_delivered_to(*expected_email_addresses_or_objects_that_respond_to_email); end

  def cc_to(*expected_email_addresses_or_objects_that_respond_to_email); end

  def deliver_from(email); end

  def deliver_to(*expected_email_addresses_or_objects_that_respond_to_email); end

  def have_body_text(text); end

  def have_header(name, value); end

  def have_reply_to(email); end

  def have_subject(subject); end

  def include_email_with_subject(*emails); end

  def reply_to(email); end
end

class EmailSpec::Matchers::BccTo
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_email_addresses_or_objects_that_respond_to_email); end

  def matches?(email); end

  def negative_failure_message(); end
end

class EmailSpec::Matchers::CcTo
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_email_addresses_or_objects_that_respond_to_email); end

  def matches?(email); end

  def negative_failure_message(); end
end

class EmailSpec::Matchers::DeliverFrom
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(email); end

  def matches?(email); end

  def negative_failure_message(); end
end

class EmailSpec::Matchers::DeliverTo
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_email_addresses_or_objects_that_respond_to_email); end

  def matches?(email); end

  def negative_failure_message(); end
end

class EmailSpec::Matchers::EmailMatcher
  def address_array(); end
end

class EmailSpec::Matchers::HaveBodyText
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(text); end

  def matches?(email); end

  def negative_failure_message(); end
end

class EmailSpec::Matchers::HaveHeader
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(name, value); end

  def mail_headers_hash(email_headers); end

  def matches?(email); end

  def negative_failure_message(); end
end

class EmailSpec::Matchers::HaveSubject
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(subject); end

  def matches?(email); end

  def negative_failure_message(); end
end

class EmailSpec::Matchers::IncludeEmailWithSubject
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(subject); end

  def matches?(emails); end

  def negative_failure_message(); end
end

class EmailSpec::Matchers::ReplyTo
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(email); end

  def matches?(email); end

  def negative_failure_message(); end
end

module EmailSpec::Matchers
  def self.included(base); end
end

class EmailSpec::TestObserver
  def self.delivered_email(message); end
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
  LF_NEWLINE_DECORATOR = ::T.let(nil, ::T.untyped)
end

class Encoding
  def self._load(arg); end
end

class EnsFeed
  include ::EnsFeed::GeneratedAttributeMethods
  include ::EnsFeed::GeneratedAssociationMethods
end

module EnsFeed::GeneratedAssociationMethods
end

module EnsFeed::GeneratedAssociationMethods
end

module EnsFeed::GeneratedAttributeMethods
end

module EnsFeed::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def compact(); end
end

module Enumerable
  extend ::ActiveSupport::EnumerableCoreExt::Constants
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Product
  def each(&blk); end
end

class Enumerator::Product
end

class Enumerator
  def self.product(*arg); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

module ErrorHighlight::CoreExt
  def detailed_message(highlight: T.unsafe(nil), error_highlight: T.unsafe(nil), **arg); end
end

module Erubi
  FREEZE_TEMPLATE_LITERALS = ::T.let(nil, ::T.untyped)
  MATCH_METHOD = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  SKIP_DEFINED_FOR_INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Erubi::Engine
  def bufvar(); end

  def filename(); end

  def initialize(input, properties=T.unsafe(nil)); end

  def src(); end
  DEFAULT_REGEXP = ::T.let(nil, ::T.untyped)
end

module Erubi
  def self.h(arg); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid=(_); end

  def mem=(_); end

  def name=(_); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Event
  include ::Event::GeneratedAttributeMethods
  include ::Event::GeneratedAssociationMethods
  def autosave_associated_records_for_tickets(*args); end

  def validate_associated_records_for_tickets(*args); end
end

module Event::GeneratedAssociationMethods
  def ticket_ids(); end

  def ticket_ids=(ids); end

  def tickets(); end

  def tickets=(value); end
end

module Event::GeneratedAssociationMethods
end

module Event::GeneratedAttributeMethods
end

module Event::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Exception
  include ::BetterErrors::ExceptionExtension
  def __bb_context(); end

  def binding_locations(); end

  def bindings(); end
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExceptionForMatrix::ErrDimensionMismatch
  def initialize(val=T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrNotRegular
  def initialize(val=T.unsafe(nil)); end
end

class ExceptionForMatrix::ErrOperationNotDefined
  def initialize(vals); end
end

class ExceptionForMatrix::ErrOperationNotImplemented
  def initialize(vals); end
end

module Excon
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CR_NL = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_CA_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_REDIRECT_LIMIT = ::T.let(nil, ::T.untyped)
  DEFAULT_RETRY_ERRORS = ::T.let(nil, ::T.untyped)
  DEFAULT_RETRY_LIMIT = ::T.let(nil, ::T.untyped)
  DEPRECATED_VALID_REQUEST_KEYS = ::T.let(nil, ::T.untyped)
  FORCE_ENC = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_1_1 = ::T.let(nil, ::T.untyped)
  HTTP_VERBS = ::T.let(nil, ::T.untyped)
  NO_ENTITY = ::T.let(nil, ::T.untyped)
  REDACTED = ::T.let(nil, ::T.untyped)
  UNIX = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  VALID_CONNECTION_KEYS = ::T.let(nil, ::T.untyped)
  VALID_REQUEST_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSIONS = ::T.let(nil, ::T.untyped)
end

Excon::Errors::Accepted = Excon::Error::Accepted

Excon::Errors::BadGateway = Excon::Error::BadGateway

Excon::Errors::BadRequest = Excon::Error::BadRequest

Excon::Errors::CertificateError = Excon::Error::Certificate

Excon::Errors::ClientError = Excon::Error::Client

Excon::Errors::Conflict = Excon::Error::Conflict

Excon::Errors::Continue = Excon::Error::Continue

Excon::Errors::Created = Excon::Error::Created

Excon::Errors::Error = Excon::Error

Excon::Errors::ExpectationFailed = Excon::Error::ExpectationFailed

Excon::Errors::Forbidden = Excon::Error::Forbidden

Excon::Errors::Found = Excon::Error::Found

Excon::Errors::GatewayTimeout = Excon::Error::GatewayTimeout

Excon::Errors::Gone = Excon::Error::Gone

Excon::Errors::HTTPStatusError = Excon::Error::HTTPStatus

Excon::Errors::Informational = Excon::Error::Informational

Excon::Errors::InternalServerError = Excon::Error::InternalServerError

Excon::Errors::InvalidHeaderKey = Excon::Error::InvalidHeaderKey

Excon::Errors::InvalidHeaderValue = Excon::Error::InvalidHeaderValue

Excon::Errors::InvalidStub = Excon::Error::InvalidStub

Excon::Errors::LengthRequired = Excon::Error::LengthRequired

Excon::Errors::MethodNotAllowed = Excon::Error::MethodNotAllowed

Excon::Errors::MovedPermanently = Excon::Error::MovedPermanently

Excon::Errors::MultipleChoices = Excon::Error::MultipleChoices

Excon::Errors::NoContent = Excon::Error::NoContent

Excon::Errors::NonAuthoritativeInformation = Excon::Error::NonAuthoritativeInformation

Excon::Errors::NotAcceptable = Excon::Error::NotAcceptable

Excon::Errors::NotFound = Excon::Error::NotFound

Excon::Errors::NotImplemented = Excon::Error::NotImplemented

Excon::Errors::NotModified = Excon::Error::NotModified

Excon::Errors::OK = Excon::Error::OK

Excon::Errors::PartialContent = Excon::Error::PartialContent

Excon::Errors::PaymentRequired = Excon::Error::PaymentRequired

Excon::Errors::PreconditionFailed = Excon::Error::PreconditionFailed

Excon::Errors::ProxyAuthenticationRequired = Excon::Error::ProxyAuthenticationRequired

Excon::Errors::ProxyConnectionError = Excon::Error::ProxyConnectionError

Excon::Errors::ProxyParse = Excon::Error::ProxyParse

Excon::Errors::Redirection = Excon::Error::Redirection

Excon::Errors::RequestEntityTooLarge = Excon::Error::RequestEntityTooLarge

Excon::Errors::RequestTimeout = Excon::Error::RequestTimeout

Excon::Errors::RequestURITooLong = Excon::Error::RequestURITooLong

Excon::Errors::RequestedRangeNotSatisfiable = Excon::Error::RequestedRangeNotSatisfiable

Excon::Errors::ResetContent = Excon::Error::ResetContent

Excon::Errors::ResponseParse = Excon::Error::ResponseParse

Excon::Errors::SeeOther = Excon::Error::SeeOther

Excon::Errors::ServerError = Excon::Error::Server

Excon::Errors::ServiceUnavailable = Excon::Error::ServiceUnavailable

Excon::Errors::SocketError = Excon::Error::Socket

Excon::Errors::StubNotFound = Excon::Error::StubNotFound

Excon::Errors::Success = Excon::Error::Success

Excon::Errors::SwitchingProtocols = Excon::Error::SwitchingProtocols

Excon::Errors::TemporaryRedirect = Excon::Error::TemporaryRedirect

Excon::Errors::Timeout = Excon::Error::Timeout

Excon::Errors::TooManyRedirects = Excon::Error::TooManyRedirects

Excon::Errors::TooManyRequests = Excon::Error::TooManyRequests

Excon::Errors::Unauthorized = Excon::Error::Unauthorized

Excon::Errors::UnprocessableEntity = Excon::Error::UnprocessableEntity

Excon::Errors::UnsupportedMediaType = Excon::Error::UnsupportedMediaType

Excon::Errors::UseProxy = Excon::Error::UseProxy

Excon::Errors::Warning = Excon::Error::Warning

class Excon::Headers
  SENTINEL = ::T.let(nil, ::T.untyped)
end

class Excon::Middleware::Decompress
  INFLATE_RAW = ::T.let(nil, ::T.untyped)
  INFLATE_ZLIB_OR_GZIP = ::T.let(nil, ::T.untyped)
end

class Excon::SSLSocket
  HAVE_NONBLOCK = ::T.let(nil, ::T.untyped)
end

class Excon::Socket
  CONNECT_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
  OPERATION_TO_TIMEOUT = ::T.let(nil, ::T.untyped)
  READ_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
  WRITE_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
end

module Excon::Utils
  CONTROL = ::T.let(nil, ::T.untyped)
  DELIMS = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  UNESCAPED = ::T.let(nil, ::T.untyped)
  UNWISE = ::T.let(nil, ::T.untyped)
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

FFI::CallbackInfo = FFI::FunctionType

class FFI::DynamicLibrary
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  SEARCH_PATH = ::T.let(nil, ::T.untyped)
  SEARCH_PATH_MESSAGE = ::T.let(nil, ::T.untyped)
end

class FFI::Function
  include ::FFI::Function::RegisterAttach
end

FFI::FunctionInfo = FFI::FunctionType

module FFI::Library
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  GNU_LIBC = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Struct::InlineArray
  include ::Enumerable
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayoutBuilder
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::Type
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

FFI::Type::Function = FFI::FunctionType

FFI::Type::Struct = FFI::StructByValue

class FSEvent
  def callback(); end

  def initialize(args=T.unsafe(nil), &block); end

  def open_pipe(); end

  def paths(); end

  def process_running?(pid); end

  def run(); end

  def stop(); end

  def watch(watch_paths, options=T.unsafe(nil), &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class FSEvent
  def self.root_path(); end

  def self.watcher_path(); end
end

module FactoryBot
  Deprecation = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Attribute
  def alias_for?(attr); end

  def association?(); end

  def ignored(); end

  def initialize(name, ignored); end

  def name(); end

  def to_proc(); end
end

class FactoryBot::Attribute::Association
  def factory(); end

  def initialize(name, factory, overrides); end
end

class FactoryBot::Attribute::Dynamic
  def initialize(name, ignored, block); end
end

class FactoryBot::Attribute::Sequence
  def initialize(name, sequence, ignored); end
end

class FactoryBot::AttributeAssigner
  def initialize(evaluator, build_class, &instance_builder); end

  def object(); end
end

class FactoryBot::AttributeList
  def apply_attributes(attributes_to_apply); end

  def associations(); end

  def define_attribute(attribute); end

  def each(&block); end

  def ignored(); end

  def initialize(name=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def names(); end

  def non_ignored(); end
end

class FactoryBot::Callback
  def ==(other); end

  def block(); end

  def initialize(name, block); end

  def name(); end

  def run(instance, evaluator); end
end

class FactoryBot::CallbacksObserver
  def initialize(callbacks, evaluator); end

  def update(name, result_instance); end
end

class FactoryBot::Configuration
  def after(*arg, **arg1, &arg2); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def callback_names(); end

  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def factories(); end

  def initialize_with(&block); end

  def inline_sequences(); end

  def sequences(); end

  def skip_create(*arg, **arg1, &arg2); end

  def strategies(); end

  def to_create(*arg, **arg1, &arg2); end

  def traits(); end
end

class FactoryBot::Declaration
  def ignored(); end

  def initialize(name, ignored=T.unsafe(nil)); end

  def name(); end

  def to_attributes(); end
end

class FactoryBot::Declaration::Association
  def ==(other); end

  def initialize(name, *options); end

  def options(); end
end

class FactoryBot::Declaration::Dynamic
  def ==(other); end

  def block(); end

  def initialize(name, ignored=T.unsafe(nil), block=T.unsafe(nil)); end
end

class FactoryBot::Declaration::Implicit
  def ==(other); end

  def factory(); end

  def initialize(name, factory=T.unsafe(nil), ignored=T.unsafe(nil)); end
end

class FactoryBot::DeclarationList
  def attributes(); end

  def declare_attribute(declaration); end

  def each(&block); end

  def initialize(name=T.unsafe(nil)); end

  def overridable(); end
end

class FactoryBot::Decorator
  def initialize(component); end

  def method_missing(*arg, **arg1, &arg2); end

  def send(*arg, **arg1, &arg2); end
end

class FactoryBot::Decorator::AttributeHash
  def attributes(); end

  def initialize(component, attributes=T.unsafe(nil)); end
end

class FactoryBot::Decorator::DisallowsDuplicatesRegistry
  def register(name, item); end
end

class FactoryBot::Decorator::InvocationTracker
  def __invoked_methods__(); end

  def method_missing(name, *args, **arg, &block); end
end

class FactoryBot::Decorator::NewConstructor
  def initialize(component, build_class); end

  def new(*arg, **arg1, &arg2); end
end

class FactoryBot::Decorator
  def self.const_missing(name); end
end

class FactoryBot::Definition
  def add_callback(callback); end

  def after(*names, &block); end

  def append_traits(new_traits); end

  def attributes(); end

  def before(*names, &block); end

  def callback(*names, &block); end

  def callbacks(); end

  def compile(klass=T.unsafe(nil)); end

  def constructor(); end

  def declarations(); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_constructor(&block); end

  def define_trait(trait); end

  def defined_traits(); end

  def inherit_traits(new_traits); end

  def initialize(name, base_traits=T.unsafe(nil)); end

  def klass(); end

  def klass=(klass); end

  def name(); end

  def overridable(); end

  def register_enum(enum); end

  def registered_enums(); end

  def skip_create(); end

  def to_create(&block); end
end

class FactoryBot::DefinitionHierarchy
  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def to_create(*arg, **arg1, &arg2); end
end

class FactoryBot::DefinitionHierarchy
  def self.build_from_definition(definition); end
end

class FactoryBot::DefinitionProxy
  def add_attribute(name, &block); end

  def after(*arg, **arg1, &arg2); end

  def association(name, *options); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def child_factories(); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize(definition, ignore=T.unsafe(nil)); end

  def initialize_with(&block); end

  def method_missing(name, *args, &block); end

  def sequence(name, *arg, **arg1, &arg2); end

  def singleton_method_added(name); end

  def skip_create(); end

  def to_create(&block); end

  def trait(name, &block); end

  def traits_for_enum(attribute_name, values=T.unsafe(nil)); end

  def transient(&block); end
  UNPROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Enum
  def build_traits(klass); end

  def initialize(attribute_name, values=T.unsafe(nil)); end
end

class FactoryBot::Evaluation
  def create(result_instance); end

  def hash(*arg, **arg1, &arg2); end

  def initialize(evaluator, attribute_assigner, to_create, observer); end

  def notify(name, result_instance); end

  def object(*arg, **arg1, &arg2); end
end

class FactoryBot::Evaluator
  def __override_names__(); end

  def association(factory_name, *traits_and_overrides); end

  def attribute_lists(); end

  def attribute_lists=(attribute_lists); end

  def attribute_lists?(); end

  def increment_sequence(sequence); end

  def initialize(build_strategy, overrides=T.unsafe(nil)); end

  def instance(); end

  def instance=(instance); end

  def method_missing(method_name, *arg, **arg1, &arg2); end
end

class FactoryBot::Evaluator
  def self.attribute_list(); end

  def self.attribute_lists(); end

  def self.attribute_lists=(value); end

  def self.attribute_lists?(); end

  def self.define_attribute(name, &block); end
end

class FactoryBot::EvaluatorClassDefiner
  def evaluator_class(); end

  def initialize(attributes, parent_class); end
end

class FactoryBot::Factory
  def add_callback(*arg, **arg1, &arg2); end

  def append_traits(*arg, **arg1, &arg2); end

  def associations(); end

  def attributes(); end

  def build_class(); end

  def build_hierarchy(); end

  def callbacks(); end

  def class_name(); end

  def compile(); end

  def compiled_constructor(); end

  def compiled_to_create(); end

  def constructor(*arg, **arg1, &arg2); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_trait(*arg, **arg1, &arg2); end

  def defined_traits(*arg, **arg1, &arg2); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def hierarchy_instance(); end

  def human_names(); end

  def inherit_traits(*arg, **arg1, &arg2); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def names(); end

  def run(build_strategy, overrides, &block); end

  def to_create(*arg, **arg1, &arg2); end

  def with_traits(traits); end
end

class FactoryBot::FactoryRunner
  def initialize(name, strategy, traits_and_overrides); end

  def run(runner_strategy=T.unsafe(nil), &block); end
end

module FactoryBot::Internal
  def self.after(*arg, **arg1, &arg2); end

  def self.before(*arg, **arg1, &arg2); end

  def self.callbacks(*arg, **arg1, &arg2); end

  def self.configuration(); end

  def self.constructor(*arg, **arg1, &arg2); end

  def self.factories(*arg, **arg1, &arg2); end

  def self.factory_by_name(name); end

  def self.initialize_with(*arg, **arg1, &arg2); end

  def self.inline_sequences(*arg, **arg1, &arg2); end

  def self.register_default_strategies(); end

  def self.register_factory(factory); end

  def self.register_inline_sequence(sequence); end

  def self.register_sequence(sequence); end

  def self.register_strategy(strategy_name, strategy_class); end

  def self.register_trait(trait); end

  def self.reset_configuration(); end

  def self.rewind_inline_sequences(); end

  def self.rewind_sequences(); end

  def self.sequence_by_name(name); end

  def self.sequences(*arg, **arg1, &arg2); end

  def self.skip_create(*arg, **arg1, &arg2); end

  def self.strategies(*arg, **arg1, &arg2); end

  def self.strategy_by_name(name); end

  def self.to_create(*arg, **arg1, &arg2); end

  def self.trait_by_name(name, klass); end

  def self.traits(*arg, **arg1, &arg2); end
end

class FactoryBot::Linter
  def initialize(factories, strategy: T.unsafe(nil), traits: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def lint!(); end
end

class FactoryBot::Linter::FactoryError
  def initialize(wrapped_error, factory); end

  def location(); end

  def message(); end

  def verbose_message(); end
end

class FactoryBot::Linter::FactoryTraitError
  def initialize(wrapped_error, factory, trait_name); end
end

class FactoryBot::NullFactory
  def attributes(*arg, **arg1, &arg2); end

  def callbacks(*arg, **arg1, &arg2); end

  def class_name(); end

  def compile(); end

  def constructor(*arg, **arg1, &arg2); end

  def defined_traits(*arg, **arg1, &arg2); end

  def definition(); end

  def evaluator_class(); end

  def hierarchy_class(); end

  def to_create(*arg, **arg1, &arg2); end
end

class FactoryBot::NullObject
  def initialize(methods_to_respond_to); end

  def method_missing(name, *args, &block); end

  def respond_to?(method); end
end

class FactoryBot::Registry
  def [](name); end

  def clear(); end

  def each(&block); end

  def find(name); end

  def initialize(name); end

  def name(); end

  def register(name, item); end

  def registered?(name); end
end

class FactoryBot::Sequence
  def initialize(name, *args, &proc); end

  def name(); end

  def names(); end

  def next(scope=T.unsafe(nil)); end

  def rewind(); end
end

class FactoryBot::Sequence::EnumeratorAdapter
  def initialize(value); end

  def next(); end

  def peek(); end

  def rewind(); end
end

class FactoryBot::Strategy::AttributesFor
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Build
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Create
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Null
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
end

class FactoryBot::Strategy::Stub
  def association(runner); end

  def result(evaluation); end

  def to_sym(); end
  DISABLED_PERSISTENCE_METHODS = ::T.let(nil, ::T.untyped)
end

class FactoryBot::Strategy::Stub
  def self.next_id=(id); end
end

class FactoryBot::StrategyCalculator
  def initialize(name_or_object); end

  def strategy(); end
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def define_strategy_methods(); end

  def initialize(strategy_name); end
end

class FactoryBot::StrategySyntaxMethodRegistrar
  def self.with_index(block, index); end
end

module FactoryBot::Syntax::Default
  def define(&block); end

  def modify(&block); end
end

class FactoryBot::Syntax::Default::DSL
  def after(*arg, **arg1, &arg2); end

  def before(*arg, **arg1, &arg2); end

  def callback(*arg, **arg1, &arg2); end

  def factory(name, options=T.unsafe(nil), &block); end

  def initialize_with(*arg, **arg1, &arg2); end

  def sequence(name, *arg, **arg1, &arg2); end

  def skip_create(*arg, **arg1, &arg2); end

  def to_create(*arg, **arg1, &arg2); end

  def trait(name, &block); end
end

class FactoryBot::Syntax::Default::DSL
  def self.run(block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def factory(name, _options=T.unsafe(nil), &block); end
end

class FactoryBot::Syntax::Default::ModifyDSL
  def self.run(block); end
end

module FactoryBot::Syntax::Methods
  def attributes_for(name, *traits_and_overrides, &block); end

  def attributes_for_list(name, amount, *traits_and_overrides, &block); end

  def attributes_for_pair(name, *traits_and_overrides, &block); end

  def build(name, *traits_and_overrides, &block); end

  def build_list(name, amount, *traits_and_overrides, &block); end

  def build_pair(name, *traits_and_overrides, &block); end

  def build_stubbed(name, *traits_and_overrides, &block); end

  def build_stubbed_list(name, amount, *traits_and_overrides, &block); end

  def build_stubbed_pair(name, *traits_and_overrides, &block); end

  def create(name, *traits_and_overrides, &block); end

  def create_list(name, amount, *traits_and_overrides, &block); end

  def create_pair(name, *traits_and_overrides, &block); end

  def generate(name); end

  def generate_list(name, count); end

  def null(name, *traits_and_overrides, &block); end

  def null_list(name, amount, *traits_and_overrides, &block); end

  def null_pair(name, *traits_and_overrides, &block); end
end

class FactoryBot::Trait
  def ==(other); end

  def add_callback(*arg, **arg1, &arg2); end

  def attributes(*arg, **arg1, &arg2); end

  def block(); end

  def callbacks(*arg, **arg1, &arg2); end

  def constructor(*arg, **arg1, &arg2); end

  def declare_attribute(*arg, **arg1, &arg2); end

  def define_trait(*arg, **arg1, &arg2); end

  def definition(); end

  def initialize(name, &block); end

  def klass(*arg, **arg1, &arg2); end

  def klass=(arg); end

  def name(); end

  def names(); end

  def to_create(*arg, **arg1, &arg2); end
end

module FactoryBot
  def self.aliases(); end

  def self.aliases=(aliases); end

  def self.aliases_for(attribute); end

  def self.automatically_define_enum_traits(); end

  def self.automatically_define_enum_traits=(val); end

  def self.build_stubbed_starting_id=(starting_id); end

  def self.definition_file_paths(); end

  def self.definition_file_paths=(definition_file_paths); end

  def self.factories(*arg, **arg1, &arg2); end

  def self.find_definitions(); end

  def self.lint(*args); end

  def self.register_strategy(strategy_name, strategy_class, &block); end

  def self.reload(); end

  def self.rewind_sequences(&block); end

  def self.strategy_by_name(name, &block); end

  def self.use_parent_strategy(); end

  def self.use_parent_strategy=(val); end
end

class FactoryBotRails::DefinitionFilePaths
  def any?(); end

  def directories(); end

  def files(); end

  def initialize(definition_file_paths); end
end

class FactoryBotRails::FactoryValidator
  def add_validator(validator); end

  def initialize(validators=T.unsafe(nil)); end

  def run(); end
end

class FactoryBotRails::Generator
  def factory_bot_disabled?(); end

  def generator(); end

  def initialize(config); end

  def rails_options(); end

  def run(); end

  def test_framework(); end
end

class FactoryBotRails::Generators::NonRSpecGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Generators::NullGenerator
  def initialize(*arg); end

  def run(); end
end

class FactoryBotRails::Generators::RSpecGenerator
  def initialize(generators); end

  def run(); end
end

class FactoryBotRails::Reloader
  def initialize(app); end

  def run(); end
end

module Faraday
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_WITH_BODY = ::T.let(nil, ::T.untyped)
  METHODS_WITH_QUERY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  TIMEOUT_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttp
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

Faraday::CompositeReadIO = Faraday::Multipart::CompositeReadIO

class Faraday::Connection
  METHODS = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
end

module Faraday::DecodeMethods
  SUBKEYS_REGEX = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

Faraday::FilePart = Multipart::Post::UploadIO

class Faraday::Logging::Formatter
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Faraday::Multipart
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Multipart::CompositeReadIO
  def close(); end

  def ensure_open_and_readable(); end

  def initialize(*parts); end

  def length(); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Faraday::Multipart::CompositeReadIO
end

Faraday::Multipart::FilePart = Multipart::Post::UploadIO

class Faraday::Multipart::Middleware
  def create_multipart(env, params); end

  def has_multipart?(obj); end

  def part(boundary, key, value); end

  def process_params(params, prefix=T.unsafe(nil), pieces=T.unsafe(nil), &block); end

  def unique_boundary(); end
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

class Faraday::Multipart::Middleware
end

class Faraday::Multipart::ParamPart
  def content_id(); end

  def content_type(); end

  def headers(); end

  def initialize(value, content_type, content_id=T.unsafe(nil)); end

  def to_part(boundary, key); end

  def value(); end
end

class Faraday::Multipart::ParamPart
end

Faraday::Multipart::Parts = Multipart::Post::Parts

module Faraday::Multipart
  def self.multipart_post_version(); end
end

module Faraday::NetHttp
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::ParamPart = Faraday::Multipart::ParamPart

Faraday::Parts = Multipart::Post::Parts

class Faraday::RackBuilder
  LOCK_ERR = ::T.let(nil, ::T.untyped)
  MISSING_ADAPTER_ERROR = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Json
  MIME_TYPE = ::T.let(nil, ::T.untyped)
  MIME_TYPE_REGEX = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::UrlEncoded
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::RaiseError
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
  ServerErrorStatuses = ::T.let(nil, ::T.untyped)
end

Faraday::UploadIO = Multipart::Post::UploadIO

module Faraday::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  KeyMap = ::T.let(nil, ::T.untyped)
end

module Feedjira
  VERSION = ::T.let(nil, ::T.untyped)
end

module Feedjira::FeedEntryUtilities
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module Feedjira::FeedUtilities
  UPDATABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Fiber
  def active_support_execution_state(); end

  def active_support_execution_state=(active_support_execution_state); end

  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def kill(); end

  def storage(); end

  def storage=(storage); end

  def transfer(*arg); end
end

class Fiber
  def self.[](arg); end

  def self.[]=(arg, arg1); end

  def self.blocking(); end

  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

module Fiddle
  ALIGN_BOOL = ::T.let(nil, ::T.untyped)
  ALIGN_INT16_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT32_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT64_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT8_T = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  Qfalse = ::T.let(nil, ::T.untyped)
  Qnil = ::T.let(nil, ::T.untyped)
  Qtrue = ::T.let(nil, ::T.untyped)
  Qundef = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  SIZEOF_BOOL = ::T.let(nil, ::T.untyped)
  SIZEOF_CONST_STRING = ::T.let(nil, ::T.untyped)
  SIZEOF_INT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT8_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UCHAR = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT8_T = ::T.let(nil, ::T.untyped)
  SIZEOF_ULONG = ::T.let(nil, ::T.untyped)
  SIZEOF_ULONG_LONG = ::T.let(nil, ::T.untyped)
  SIZEOF_USHORT = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_CONST_STRING = ::T.let(nil, ::T.untyped)
  TYPE_INT16_T = ::T.let(nil, ::T.untyped)
  TYPE_INT32_T = ::T.let(nil, ::T.untyped)
  TYPE_INT64_T = ::T.let(nil, ::T.untyped)
  TYPE_INT8_T = ::T.let(nil, ::T.untyped)
  TYPE_UCHAR = ::T.let(nil, ::T.untyped)
  TYPE_UINT = ::T.let(nil, ::T.untyped)
  TYPE_UINT16_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT32_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT64_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT8_T = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_ULONG_LONG = ::T.let(nil, ::T.untyped)
  TYPE_USHORT = ::T.let(nil, ::T.untyped)
  TYPE_VARIADIC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Fiddle::CStruct
  include ::Enumerable
  def each(&blk); end

  def each_pair(); end

  def replace(another); end

  def to_h(); end
end

class Fiddle::CStruct
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

module Fiddle::CStructBuilder
end

module Fiddle::CStructBuilder
  def self.create(klass, types, members); end
end

class Fiddle::CStructEntity
  include ::Fiddle::PackInfo
  include ::Fiddle::ValueUtil
  def [](*args); end

  def []=(*args); end

  def assign_names(members); end

  def initialize(addr, types, func=T.unsafe(nil)); end

  def set_ctypes(types); end

  def to_s(); end
end

class Fiddle::CStructEntity
  def self.alignment(types); end

  def self.malloc(types, func=T.unsafe(nil), size=T.unsafe(nil), &block); end

  def self.size(types); end
end

class Fiddle::CUnion
end

class Fiddle::CUnion
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

class Fiddle::CUnionEntity
end

class Fiddle::CUnionEntity
end

class Fiddle::ClearedReferenceError
end

class Fiddle::ClearedReferenceError
end

class Fiddle::Closure
  def free(); end

  def freed?(); end
end

class Fiddle::Closure
  def self.create(*args); end
end

class Fiddle::CompositeHandler
  def [](symbol); end

  def handlers(); end

  def initialize(handlers); end

  def sym(symbol); end
end

class Fiddle::CompositeHandler
end

class Fiddle::Error
end

class Fiddle::Error
end

class Fiddle::Function
  def need_gvl?(); end

  def to_proc(); end
end

class Fiddle::Handle
  def file_name(); end

  def sym_defined?(arg); end

  def to_ptr(); end
end

class Fiddle::Handle
  def self.sym_defined?(arg); end
end

module Fiddle::Importer
  include ::Fiddle
  include ::Fiddle::CParser
end

module Fiddle::Importer
  extend ::Fiddle::Importer
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Fiddle::MemoryView
  def [](*arg); end

  def byte_size(); end

  def format(); end

  def initialize(arg); end

  def item_size(); end

  def ndim(); end

  def obj(); end

  def readonly?(); end

  def release(); end

  def shape(); end

  def strides(); end

  def sub_offsets(); end
end

class Fiddle::MemoryView
  def self.export(arg); end
end

module Fiddle::PackInfo
  ALIGN_MAP = ::T.let(nil, ::T.untyped)
  PACK_MAP = ::T.let(nil, ::T.untyped)
  SIZE_MAP = ::T.let(nil, ::T.untyped)
end

module Fiddle::PackInfo
  def self.align(addr, align); end
end

class Fiddle::Packer
  include ::Fiddle::PackInfo
  def initialize(types); end

  def pack(ary); end

  def size(); end

  def unpack(ary); end
end

class Fiddle::Packer
  def self.[](*types); end
end

class Fiddle::Pinned
  def clear(); end

  def cleared?(); end

  def initialize(arg); end

  def ref(); end
end

class Fiddle::Pinned
end

class Fiddle::Pointer
  def call_free(); end

  def freed?(); end
end

class Fiddle::Pointer
  def self.read(arg, arg1); end

  def self.write(arg, arg1); end
end

class Fiddle::StructArray
  include ::Fiddle::ValueUtil
  def []=(index, value); end

  def initialize(ptr, type, initial_values); end

  def to_ptr(); end
end

class Fiddle::StructArray
end

module Fiddle::Types
  BOOL = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  CONST_STRING = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16_T = ::T.let(nil, ::T.untyped)
  INT32_T = ::T.let(nil, ::T.untyped)
  INT64_T = ::T.let(nil, ::T.untyped)
  INT8_T = ::T.let(nil, ::T.untyped)
  INTPTR_T = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  PTRDIFF_T = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SIZE_T = ::T.let(nil, ::T.untyped)
  SSIZE_T = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16_T = ::T.let(nil, ::T.untyped)
  UINT32_T = ::T.let(nil, ::T.untyped)
  UINT64_T = ::T.let(nil, ::T.untyped)
  UINT8_T = ::T.let(nil, ::T.untyped)
  UINTPTR_T = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARIADIC = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
  VOIDP = ::T.let(nil, ::T.untyped)
end

module Fiddle::Types
end

module Fiddle::ValueUtil
  def signed_value(val, ty); end

  def unsigned_value(val, ty); end

  def wrap_arg(arg, ty, funcs=T.unsafe(nil), &block); end

  def wrap_args(args, tys, funcs, &block); end
end

module Fiddle::ValueUtil
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
end

class File
  def self.absolute_path?(arg); end

  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.cleanpath(path, rel_root=T.unsafe(nil)); end

  def self.open!(file, *args, &block); end

  def self.probe_stat_in(dir); end

  def self.read_binary(file); end

  def self.relative_path(from, to); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Find
  VERSION = ::T.let(nil, ::T.untyped)
end

module Flatpickr
  VERSION = ::T.let(nil, ::T.untyped)
end

class Float
  include ::ActiveSupport::NumericWithFormat
end

module Fog::AWS
  VERSION = ::T.let(nil, ::T.untyped)
end

class Fog::AWS::AutoScaling
  ExpectedOptions = ::T.let(nil, ::T.untyped)
end

module Fog::AWS::AutoScaling::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::AutoScaling::Collections
end

class Fog::AWS::AutoScaling::Error
end

class Fog::AWS::AutoScaling::Error
end

class Fog::AWS::AutoScaling::IdentifierTaken
end

class Fog::AWS::AutoScaling::IdentifierTaken
end

class Fog::AWS::AutoScaling::Mock
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def region=(region); end

  def region_data(); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::AutoScaling::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::AutoScaling::NotFound
end

class Fog::AWS::AutoScaling::NotFound
end

class Fog::AWS::AutoScaling::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def region=(region); end

  def reload(); end
end

class Fog::AWS::AutoScaling::Real
end

class Fog::AWS::AutoScaling::ResourceInUse
end

class Fog::AWS::AutoScaling::ResourceInUse
end

class Fog::AWS::AutoScaling::ValidationError
end

class Fog::AWS::AutoScaling::ValidationError
end

class Fog::AWS::AutoScaling
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::CDN
end

module Fog::AWS::CDN::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::CDN::Collections
end

class Fog::AWS::CDN::Error
end

class Fog::AWS::CDN::Error
end

class Fog::AWS::CDN::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options=T.unsafe(nil)); end

  def signature(params); end
  CDN_ERRORS = ::T.let(nil, ::T.untyped)
end

class Fog::AWS::CDN::Mock
  def self.data(); end

  def self.distribution_id(); end

  def self.domain_name(); end

  def self.error(code, argument=T.unsafe(nil)); end

  def self.generic_id(); end

  def self.raise_error(status, code, message=T.unsafe(nil)); end

  def self.random_id(length); end

  def self.reset(); end
end

class Fog::AWS::CDN::NotFound
end

class Fog::AWS::CDN::NotFound
end

class Fog::AWS::CDN::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::CDN::Real
end

class Fog::AWS::CDN
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::CloudFormation
end

module Fog::AWS::CloudFormation::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::CloudFormation::Collections
end

class Fog::AWS::CloudFormation::Error
end

class Fog::AWS::CloudFormation::Error
end

class Fog::AWS::CloudFormation::Mock
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::CloudFormation::Mock
end

class Fog::AWS::CloudFormation::NotFound
end

class Fog::AWS::CloudFormation::NotFound
end

class Fog::AWS::CloudFormation::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::CloudFormation::Real
end

class Fog::AWS::CloudFormation
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::CloudWatch
end

module Fog::AWS::CloudWatch::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::CloudWatch::Collections
end

class Fog::AWS::CloudWatch::Error
end

class Fog::AWS::CloudWatch::Error
end

class Fog::AWS::CloudWatch::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end
end

class Fog::AWS::CloudWatch::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::CloudWatch::NotFound
end

class Fog::AWS::CloudWatch::NotFound
end

class Fog::AWS::CloudWatch::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::CloudWatch::Real
end

class Fog::AWS::CloudWatch
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Compute
end

module Fog::AWS::Compute::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Compute::Collections
end

class Fog::AWS::Compute::Error
end

class Fog::AWS::Compute::Error
end

class Fog::AWS::Compute::InvalidURIError
end

class Fog::AWS::Compute::InvalidURIError
end

class Fog::AWS::Compute::Mock
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def apply_tag_filters(resources, filters, resource_id_key); end

  def data(); end

  def default_vpc(); end

  def default_vpc=(value); end

  def disable_ec2_classic(); end

  def enable_ec2_classic(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def region=(region); end

  def region_data(); end

  def reset_data(); end

  def set_supported_platforms(values); end

  def setup_credentials(options); end

  def setup_default_vpc!(); end

  def supported_platforms(); end

  def tagged_resources(resources); end

  def visible_images(); end
  MOCKED_TAG_TYPES = ::T.let(nil, ::T.untyped)
  VPC_BLANK_VALUE = ::T.let(nil, ::T.untyped)
end

class Fog::AWS::Compute::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::Compute::NotFound
end

class Fog::AWS::Compute::NotFound
end

class Fog::AWS::Compute::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def modify_image_attributes(*params); end

  def region(); end

  def region=(region); end

  def reload(); end

  def supported_platforms(); end
end

class Fog::AWS::Compute::Real
end

class Fog::AWS::Compute::RequestLimitExceeded
end

class Fog::AWS::Compute::RequestLimitExceeded
end

class Fog::AWS::Compute
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

module Fog::AWS::CredentialFetcher
  CONTAINER_CREDENTIALS_HOST = ::T.let(nil, ::T.untyped)
  INSTANCE_METADATA_AZ = ::T.let(nil, ::T.untyped)
  INSTANCE_METADATA_HOST = ::T.let(nil, ::T.untyped)
  INSTANCE_METADATA_PATH = ::T.let(nil, ::T.untyped)
  INSTANCE_METADATA_TOKEN = ::T.let(nil, ::T.untyped)
end

module Fog::AWS::CredentialFetcher::ConnectionMethods
  def refresh_credentials_if_expired(); end
end

module Fog::AWS::CredentialFetcher::ConnectionMethods
end

module Fog::AWS::CredentialFetcher::ServiceMethods
  def fetch_credentials(options); end

  def fetch_credentials_token_header(connection, disable_imds_v2); end
end

module Fog::AWS::CredentialFetcher::ServiceMethods
end

module Fog::AWS::CredentialFetcher
end

class Fog::AWS::DNS
end

module Fog::AWS::DNS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::DNS::Collections
end

class Fog::AWS::DNS::Error
end

class Fog::AWS::DNS::Error
end

class Fog::AWS::DNS::Mock
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options); end

  def signature(params); end
end

class Fog::AWS::DNS::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::DNS::NotFound
end

class Fog::AWS::DNS::NotFound
end

class Fog::AWS::DNS::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::DNS::Real
end

class Fog::AWS::DNS
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.change_resource_record_sets_data(zone_id, change_batch, version, options=T.unsafe(nil)); end

  def self.elb_dualstack_hosted_zone_mapping(); end

  def self.elb_hosted_zone_mapping(); end

  def self.hosted_zone_for_alias_target(dns_name); end

  def self.service(); end
end

class Fog::AWS::DataPipeline
end

module Fog::AWS::DataPipeline::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::DataPipeline::Collections
end

class Fog::AWS::DataPipeline::Error
end

class Fog::AWS::DataPipeline::Error
end

class Fog::AWS::DataPipeline::Mock
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def data(); end

  def find_pipeline(id); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def region=(region); end

  def reset(); end

  def stringify_keys(object); end
end

class Fog::AWS::DataPipeline::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::DataPipeline::NotFound
end

class Fog::AWS::DataPipeline::NotFound
end

class Fog::AWS::DataPipeline::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def owner_id(); end

  def region(); end

  def reload(); end
end

class Fog::AWS::DataPipeline::Real
end

class Fog::AWS::DataPipeline
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::DynamoDB
end

module Fog::AWS::DynamoDB::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::DynamoDB::Collections
end

class Fog::AWS::DynamoDB::Error
end

class Fog::AWS::DynamoDB::Error
end

class Fog::AWS::DynamoDB::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::DynamoDB::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::DynamoDB::NotFound
end

class Fog::AWS::DynamoDB::NotFound
end

class Fog::AWS::DynamoDB::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::DynamoDB::Real
end

class Fog::AWS::DynamoDB
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::ECS
end

module Fog::AWS::ECS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::ECS::Collections
end

class Fog::AWS::ECS::Error
end

class Fog::AWS::ECS::Error
end

class Fog::AWS::ECS::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def region=(region); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::ECS::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::ECS::NotFound
end

class Fog::AWS::ECS::NotFound
end

class Fog::AWS::ECS::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def reload(); end
end

class Fog::AWS::ECS::Real
end

class Fog::AWS::ECS
  def self.service(); end
end

class Fog::AWS::EFS
end

module Fog::AWS::EFS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::EFS::Collections
end

class Fog::AWS::EFS::Error
end

class Fog::AWS::EFS::Error
end

class Fog::AWS::EFS::FileSystemInUse
end

class Fog::AWS::EFS::FileSystemInUse
end

class Fog::AWS::EFS::IncorrectFileSystemLifeCycleState
end

class Fog::AWS::EFS::IncorrectFileSystemLifeCycleState
end

class Fog::AWS::EFS::InvalidSubnet
end

class Fog::AWS::EFS::InvalidSubnet
end

class Fog::AWS::EFS::Mock
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def mock_compute(); end

  def region(); end

  def region=(region); end

  def reset(); end
end

class Fog::AWS::EFS::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::EFS::NotFound
end

class Fog::AWS::EFS::NotFound
end

class Fog::AWS::EFS::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def _request(body, headers, idempotent, parser, method, path, expects); end

  def initialize(options=T.unsafe(nil)); end

  def reload(); end

  def request(params); end

  def setup_credentials(options); end
end

class Fog::AWS::EFS::Real
end

class Fog::AWS::EFS
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::ELB
end

module Fog::AWS::ELB::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::ELB::Collections
end

class Fog::AWS::ELB::DuplicatePolicyName
end

class Fog::AWS::ELB::DuplicatePolicyName
end

class Fog::AWS::ELB::Error
end

class Fog::AWS::ELB::Error
end

class Fog::AWS::ELB::IdentifierTaken
end

class Fog::AWS::ELB::IdentifierTaken
end

class Fog::AWS::ELB::InvalidConfigurationRequest
end

class Fog::AWS::ELB::InvalidConfigurationRequest
end

class Fog::AWS::ELB::InvalidInstance
end

class Fog::AWS::ELB::InvalidInstance
end

class Fog::AWS::ELB::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def reset_data(); end

  def setup_credentials(options); end
  POLICY_TYPES = ::T.let(nil, ::T.untyped)
end

class Fog::AWS::ELB::Mock
  def self.data(); end

  def self.dns_name(name, region); end

  def self.reset(); end
end

class Fog::AWS::ELB::NotFound
end

class Fog::AWS::ELB::NotFound
end

class Fog::AWS::ELB::PolicyNotFound
end

class Fog::AWS::ELB::PolicyNotFound
end

class Fog::AWS::ELB::PolicyTypeNotFound
end

class Fog::AWS::ELB::PolicyTypeNotFound
end

class Fog::AWS::ELB::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def reload(); end
end

class Fog::AWS::ELB::Real
end

class Fog::AWS::ELB::Throttled
end

class Fog::AWS::ELB::Throttled
end

class Fog::AWS::ELB::TooManyPolicies
end

class Fog::AWS::ELB::TooManyPolicies
end

class Fog::AWS::ELB::ValidationError
end

class Fog::AWS::ELB::ValidationError
end

class Fog::AWS::ELB
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::ELBV2
end

module Fog::AWS::ELBV2::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::ELBV2::Collections
end

class Fog::AWS::ELBV2::Error
end

class Fog::AWS::ELBV2::Error
end

class Fog::AWS::ELBV2::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::ELBV2::Mock
  def self.data(); end

  def self.dns_name(name, region); end

  def self.reset(); end
end

class Fog::AWS::ELBV2::NotFound
end

class Fog::AWS::ELBV2::NotFound
end

class Fog::AWS::ELBV2::Real
end

class Fog::AWS::ELBV2::Real
end

class Fog::AWS::ELBV2
end

class Fog::AWS::EMR
end

module Fog::AWS::EMR::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::EMR::Collections
end

class Fog::AWS::EMR::Error
end

class Fog::AWS::EMR::Error
end

class Fog::AWS::EMR::IdentifierTaken
end

class Fog::AWS::EMR::IdentifierTaken
end

class Fog::AWS::EMR::Mock
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::EMR::Mock
end

class Fog::AWS::EMR::NotFound
end

class Fog::AWS::EMR::NotFound
end

class Fog::AWS::EMR::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::EMR::Real
end

class Fog::AWS::EMR
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::ElasticBeanstalk
end

module Fog::AWS::ElasticBeanstalk::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::ElasticBeanstalk::Collections
end

class Fog::AWS::ElasticBeanstalk::Error
end

class Fog::AWS::ElasticBeanstalk::Error
end

class Fog::AWS::ElasticBeanstalk::InvalidParameterError
end

class Fog::AWS::ElasticBeanstalk::InvalidParameterError
end

class Fog::AWS::ElasticBeanstalk::Mock
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::ElasticBeanstalk::Mock
end

class Fog::AWS::ElasticBeanstalk::NotFound
end

class Fog::AWS::ElasticBeanstalk::NotFound
end

class Fog::AWS::ElasticBeanstalk::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end

  def solution_stacks(); end
end

class Fog::AWS::ElasticBeanstalk::Real
end

class Fog::AWS::ElasticBeanstalk
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Elasticache
end

class Fog::AWS::Elasticache::AuthorizationAlreadyExists
end

class Fog::AWS::Elasticache::AuthorizationAlreadyExists
end

module Fog::AWS::Elasticache::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Elasticache::Collections
end

class Fog::AWS::Elasticache::Error
end

class Fog::AWS::Elasticache::Error
end

class Fog::AWS::Elasticache::IdentifierTaken
end

class Fog::AWS::Elasticache::IdentifierTaken
end

class Fog::AWS::Elasticache::InvalidInstance
end

class Fog::AWS::Elasticache::InvalidInstance
end

class Fog::AWS::Elasticache::Mock
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def create_cache_nodes(cluster_id, num_nodes=T.unsafe(nil), port=T.unsafe(nil)); end

  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region_data(); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::Elasticache::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::Elasticache::NotFound
end

class Fog::AWS::Elasticache::NotFound
end

class Fog::AWS::Elasticache::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::Elasticache::Real
end

class Fog::AWS::Elasticache
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

module Fog::AWS::Errors
end

module Fog::AWS::Errors
  def self.match_error(error); end
end

class Fog::AWS::Federation
end

module Fog::AWS::Federation::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Federation::Collections
end

class Fog::AWS::Federation::Error
end

class Fog::AWS::Federation::Error
end

class Fog::AWS::Federation::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end
end

class Fog::AWS::Federation::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::Federation::NotFound
end

class Fog::AWS::Federation::NotFound
end

class Fog::AWS::Federation::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def request(action, session); end
end

class Fog::AWS::Federation::Real
end

class Fog::AWS::Federation
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Glacier
  MEGABYTE = ::T.let(nil, ::T.untyped)
end

module Fog::AWS::Glacier::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Glacier::Collections
end

class Fog::AWS::Glacier::Error
end

class Fog::AWS::Glacier::Error
end

class Fog::AWS::Glacier::Mock
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::Glacier::Mock
end

class Fog::AWS::Glacier::NotFound
end

class Fog::AWS::Glacier::NotFound
end

class Fog::AWS::Glacier::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::Glacier::Real
end

class Fog::AWS::Glacier::TreeHash
  def add_part(bytes); end

  def digest(); end

  def digest_for_part(body); end

  def hexdigest(); end

  def prepare_body_for_slice(body); end

  def reduce_digest_stack(digest, stack); end

  def update_digest_stack(digest, stack); end
end

class Fog::AWS::Glacier::TreeHash
  def self.digest(body); end
end

class Fog::AWS::Glacier
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::IAM
end

module Fog::AWS::IAM::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::IAM::Collections
end

class Fog::AWS::IAM::EntityAlreadyExists
end

class Fog::AWS::IAM::EntityAlreadyExists
end

class Fog::AWS::IAM::Error
end

class Fog::AWS::IAM::Error
end

class Fog::AWS::IAM::KeyPairMismatch
end

class Fog::AWS::IAM::KeyPairMismatch
end

class Fog::AWS::IAM::LimitExceeded
end

class Fog::AWS::IAM::LimitExceeded
end

class Fog::AWS::IAM::MalformedCertificate
end

class Fog::AWS::IAM::MalformedCertificate
end

class Fog::AWS::IAM::Mock
  def account_id(); end

  def current_user(); end

  def current_user_name(); end

  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::IAM::Mock
  def self.data(); end

  def self.default_policies(); end

  def self.default_policy_versions(); end

  def self.reset(); end

  def self.server_certificate_id(); end
end

class Fog::AWS::IAM::NotFound
end

class Fog::AWS::IAM::NotFound
end

class Fog::AWS::IAM::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::IAM::Real
end

class Fog::AWS::IAM::ValidationError
end

class Fog::AWS::IAM::ValidationError
end

class Fog::AWS::IAM
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::KMS
end

module Fog::AWS::KMS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::KMS::Collections
end

class Fog::AWS::KMS::DependencyTimeoutException
end

class Fog::AWS::KMS::DependencyTimeoutException
end

class Fog::AWS::KMS::DisabledException
end

class Fog::AWS::KMS::DisabledException
end

class Fog::AWS::KMS::Error
end

class Fog::AWS::KMS::Error
end

class Fog::AWS::KMS::InvalidArnException
end

class Fog::AWS::KMS::InvalidArnException
end

class Fog::AWS::KMS::InvalidGrantTokenException
end

class Fog::AWS::KMS::InvalidGrantTokenException
end

class Fog::AWS::KMS::InvalidKeyUsageException
end

class Fog::AWS::KMS::InvalidKeyUsageException
end

class Fog::AWS::KMS::KMSInternalException
end

class Fog::AWS::KMS::KMSInternalException
end

class Fog::AWS::KMS::KeyUnavailableException
end

class Fog::AWS::KMS::KeyUnavailableException
end

class Fog::AWS::KMS::MalformedPolicyDocumentException
end

class Fog::AWS::KMS::MalformedPolicyDocumentException
end

class Fog::AWS::KMS::Mock
  def account_id(); end

  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::KMS::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::KMS::NotFound
end

class Fog::AWS::KMS::NotFound
end

class Fog::AWS::KMS::NotFoundException
end

class Fog::AWS::KMS::NotFoundException
end

class Fog::AWS::KMS::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::KMS::Real
end

class Fog::AWS::KMS
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Kinesis
end

module Fog::AWS::Kinesis::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Kinesis::Collections
end

class Fog::AWS::Kinesis::Error
end

class Fog::AWS::Kinesis::Error
end

class Fog::AWS::Kinesis::ExpiredIterator
end

class Fog::AWS::Kinesis::ExpiredIterator
end

class Fog::AWS::Kinesis::InvalidArgument
end

class Fog::AWS::Kinesis::InvalidArgument
end

class Fog::AWS::Kinesis::LimitExceeded
end

class Fog::AWS::Kinesis::LimitExceeded
end

class Fog::AWS::Kinesis::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def next_sequence_number(); end

  def next_shard_id(); end

  def reset_data(); end
end

class Fog::AWS::Kinesis::Mock
  def self.data(); end

  def self.next_sequence_number(); end

  def self.next_shard_id(); end

  def self.reset(); end
end

class Fog::AWS::Kinesis::NotFound
end

class Fog::AWS::Kinesis::NotFound
end

class Fog::AWS::Kinesis::ProvisionedThroughputExceeded
end

class Fog::AWS::Kinesis::ProvisionedThroughputExceeded
end

class Fog::AWS::Kinesis::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::Kinesis::Real
end

class Fog::AWS::Kinesis::ResourceInUse
end

class Fog::AWS::Kinesis::ResourceInUse
end

class Fog::AWS::Kinesis::ResourceNotFound
end

class Fog::AWS::Kinesis::ResourceNotFound
end

class Fog::AWS::Kinesis
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Lambda
end

module Fog::AWS::Lambda::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Lambda::Collections
end

class Fog::AWS::Lambda::Error
end

class Fog::AWS::Lambda::Error
end

class Fog::AWS::Lambda::Mock
  def account_id(); end

  def aws_access_key_id(); end

  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def reset_data(); end
end

class Fog::AWS::Lambda::Mock
  def self.data(); end
end

class Fog::AWS::Lambda::NotFound
end

class Fog::AWS::Lambda::NotFound
end

class Fog::AWS::Lambda::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def reload(); end
end

class Fog::AWS::Lambda::Real
end

class Fog::AWS::Lambda
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Mock
end

class Fog::AWS::Mock
  def self.arn(vendor, account_id, path, region=T.unsafe(nil)); end

  def self.availability_zone(region); end

  def self.box_usage(); end

  def self.change_id(); end

  def self.console_output(); end

  def self.data_pipeline_id(); end

  def self.default_vpc_for(region); end

  def self.dhcp_options_id(); end

  def self.dns_name_for(ip_address); end

  def self.image(); end

  def self.image_id(); end

  def self.instance_id(); end

  def self.internet_gateway_id(); end

  def self.ip_address(); end

  def self.kernel_id(); end

  def self.key_fingerprint(); end

  def self.key_id(length=T.unsafe(nil)); end

  def self.key_material(); end

  def self.nameservers(); end

  def self.network_acl_association_id(); end

  def self.network_acl_id(); end

  def self.network_interface_id(); end

  def self.owner_id(); end

  def self.private_dns_name_for(ip_address); end

  def self.private_ip_address(); end

  def self.ramdisk_id(); end

  def self.rds_address(db_name, region); end

  def self.request_id(); end

  def self.reservation_id(); end

  def self.reserved_instances_id(); end

  def self.reserved_instances_offering_id(); end

  def self.route_table_id(); end

  def self.security_group_id(); end

  def self.snapshot_id(); end

  def self.spot_instance_request_id(); end

  def self.spot_product_descriptions(); end

  def self.sqs_message_id(); end

  def self.sqs_sender_id(); end

  def self.subnet_id(); end

  def self.volume_id(); end

  def self.vpc_id(); end

  def self.zone_id(); end
end

class Fog::AWS::RDS
end

class Fog::AWS::RDS::AuthorizationAlreadyExists
end

class Fog::AWS::RDS::AuthorizationAlreadyExists
end

module Fog::AWS::RDS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::RDS::Collections
end

class Fog::AWS::RDS::Error
end

class Fog::AWS::RDS::Error
end

class Fog::AWS::RDS::IdentifierTaken
end

class Fog::AWS::RDS::IdentifierTaken
end

class Fog::AWS::RDS::InvalidParameterCombination
end

class Fog::AWS::RDS::InvalidParameterCombination
end

class Fog::AWS::RDS::Mock
  def aws_access_key_id(); end

  def aws_access_key_id=(aws_access_key_id); end

  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def region=(region); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::RDS::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::RDS::NotFound
end

class Fog::AWS::RDS::NotFound
end

class Fog::AWS::RDS::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def owner_id(); end

  def region(); end

  def reload(); end
end

class Fog::AWS::RDS::Real
end

class Fog::AWS::RDS
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Redshift
end

module Fog::AWS::Redshift::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Redshift::Collections
end

class Fog::AWS::Redshift::Error
end

class Fog::AWS::Redshift::Error
end

class Fog::AWS::Redshift::Mock
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::Redshift::Mock
end

class Fog::AWS::Redshift::NotFound
end

class Fog::AWS::Redshift::NotFound
end

class Fog::AWS::Redshift::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::Redshift::Real
end

class Fog::AWS::Redshift
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::SES
end

module Fog::AWS::SES::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::SES::Collections
end

class Fog::AWS::SES::Error
end

class Fog::AWS::SES::Error
end

class Fog::AWS::SES::InvalidParameterError
end

class Fog::AWS::SES::InvalidParameterError
end

class Fog::AWS::SES::MessageRejected
end

class Fog::AWS::SES::MessageRejected
end

class Fog::AWS::SES::Mock
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::SES::Mock
end

class Fog::AWS::SES::NotFound
end

class Fog::AWS::SES::NotFound
end

class Fog::AWS::SES::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::SES::Real
end

class Fog::AWS::SES
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::SNS
end

module Fog::AWS::SNS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::SNS::Collections
end

class Fog::AWS::SNS::Error
end

class Fog::AWS::SNS::Error
end

class Fog::AWS::SNS::Mock
  def account_id=(account_id); end

  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def reset_data(); end
end

class Fog::AWS::SNS::Mock
  def self.data(); end
end

class Fog::AWS::SNS::NotFound
end

class Fog::AWS::SNS::NotFound
end

class Fog::AWS::SNS::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def reload(); end
end

class Fog::AWS::SNS::Real
end

class Fog::AWS::SNS
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::SQS
end

module Fog::AWS::SQS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::SQS::Collections
end

class Fog::AWS::SQS::Error
end

class Fog::AWS::SQS::Error
end

class Fog::AWS::SQS::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::SQS::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::SQS::NotFound
end

class Fog::AWS::SQS::NotFound
end

class Fog::AWS::SQS::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::SQS::Real
end

class Fog::AWS::SQS
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::STS
end

class Fog::AWS::STS::AwsAccessKeysMissing
end

class Fog::AWS::STS::AwsAccessKeysMissing
end

module Fog::AWS::STS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::STS::Collections
end

class Fog::AWS::STS::EntityAlreadyExists
end

class Fog::AWS::STS::EntityAlreadyExists
end

class Fog::AWS::STS::Error
end

class Fog::AWS::STS::Error
end

class Fog::AWS::STS::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::STS::Mock
  def self.data(); end

  def self.reset(); end

  def self.server_certificate_id(); end
end

class Fog::AWS::STS::NotFound
end

class Fog::AWS::STS::NotFound
end

class Fog::AWS::STS::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::STS::Real
end

class Fog::AWS::STS::ValidationError
end

class Fog::AWS::STS::ValidationError
end

class Fog::AWS::STS
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::ServiceMapper
end

class Fog::AWS::ServiceMapper
  def self.[](service); end

  def self.class_for(key); end

  def self.services(); end
end

class Fog::AWS::SignatureV4
  def canonical_headers(headers); end

  def canonical_path(path); end

  def canonical_query_string(query); end

  def components_to_header(components); end

  def credential_scope(date); end

  def derived_hmac(date); end

  def initialize(aws_access_key_id, secret_key, region, service); end

  def sign(params, date); end

  def signature_components(params, date, body_sha); end

  def signature_header(params, date, body_sha=T.unsafe(nil)); end

  def signature_parameters(params, date, body_sha=T.unsafe(nil)); end

  def signed_headers(headers); end
  ALGORITHM = ::T.let(nil, ::T.untyped)
end

class Fog::AWS::SignatureV4
end

class Fog::AWS::SimpleDB
end

module Fog::AWS::SimpleDB::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::SimpleDB::Collections
end

class Fog::AWS::SimpleDB::Error
end

class Fog::AWS::SimpleDB::Error
end

class Fog::AWS::SimpleDB::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options); end
end

class Fog::AWS::SimpleDB::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::SimpleDB::NotFound
end

class Fog::AWS::SimpleDB::NotFound
end

class Fog::AWS::SimpleDB::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end
end

class Fog::AWS::SimpleDB::Real
end

class Fog::AWS::SimpleDB
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Storage
  ACCELERATION_HOST = ::T.let(nil, ::T.untyped)
  COMPLIANT_BUCKET_NAMES = ::T.let(nil, ::T.untyped)
  DEFAULT_CONNECTION_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_REGION = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEME = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEME_PORT = ::T.let(nil, ::T.untyped)
  MAX_SINGLE_PUT_SIZE = ::T.let(nil, ::T.untyped)
  MIN_MULTIPART_CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  VALID_QUERY_KEYS = ::T.let(nil, ::T.untyped)
end

module Fog::AWS::Storage::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Storage::Collections
end

class Fog::AWS::Storage::Error
end

class Fog::AWS::Storage::Error
end

class Fog::AWS::Storage::Mock
  include ::Fog::AWS::Storage::Utils
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def reset_data(); end

  def setup_credentials(options); end

  def signature_v2(params, expires); end
end

class Fog::AWS::Storage::Mock
  def self.acls(type); end

  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::Storage::NotFound
end

class Fog::AWS::Storage::NotFound
end

class Fog::AWS::Storage::Real
  include ::Fog::AWS::Storage::Utils
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def initialize(options=T.unsafe(nil)); end

  def reload(); end
end

class Fog::AWS::Storage::Real::S3Streamer
  def body(); end

  def body=(body); end

  def call(); end

  def date(); end

  def date=(date); end

  def finished(); end

  def finished=(finished); end

  def initial_signature(); end

  def initial_signature=(initial_signature); end

  def initialize(body, signature, signer, date); end

  def next_chunk(); end

  def rewind(); end

  def sign_chunk(data, previous_signature); end

  def signature(); end

  def signature=(signature); end

  def signer(); end

  def signer=(signer); end
end

class Fog::AWS::Storage::Real::S3Streamer
end

class Fog::AWS::Storage::Real
end

module Fog::AWS::Storage::Utils
  def cdn(); end

  def disable_content_md5_validation(); end

  def disable_content_md5_validation=(disable_content_md5_validation); end

  def http_url(params, expires); end

  def https_url(params, expires); end

  def max_copy_chunk_size(); end

  def max_put_chunk_size(); end

  def region(); end

  def region=(region); end

  def request_url(params); end

  def require_mime_types(); end

  def signed_url(params, expires); end

  def url(params, expires); end

  def validate_chunk_size(value, description); end
end

module Fog::AWS::Storage::Utils
end

class Fog::AWS::Storage
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::AWS::Support
end

module Fog::AWS::Support::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::AWS::Support::Collections
end

class Fog::AWS::Support::Error
end

class Fog::AWS::Support::Error
end

class Fog::AWS::Support::Mock
  def data(); end

  def initialize(options=T.unsafe(nil)); end

  def region(); end

  def region=(region); end

  def reset(); end
end

class Fog::AWS::Support::Mock
  def self.data(); end

  def self.reset(); end
end

class Fog::AWS::Support::NotFound
end

class Fog::AWS::Support::NotFound
end

class Fog::AWS::Support::Real
  include ::Fog::AWS::CredentialFetcher::ConnectionMethods
  def _request(body, headers, idempotent, parser); end

  def initialize(options=T.unsafe(nil)); end

  def reload(); end

  def request(params); end

  def setup_credentials(options); end
end

class Fog::AWS::Support::Real
end

class Fog::AWS::Support
  extend ::Fog::AWS::CredentialFetcher::ServiceMethods
  def self.service(); end
end

class Fog::CDN::AWS
end

module Fog::CDN::AWS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::CDN::AWS::Collections
end

class Fog::CDN::AWS::Error
end

class Fog::CDN::AWS::Error
end

class Fog::CDN::AWS::NotFound
end

class Fog::CDN::AWS::NotFound
end

class Fog::CDN::AWS
  def self.new(*arg); end
end

class Fog::Cache
  REQUIRED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SANDBOX = ::T.let(nil, ::T.untyped)
end

class Fog::Compute::AWS
end

module Fog::Compute::AWS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::Compute::AWS::Collections
end

class Fog::Compute::AWS::Error
end

class Fog::Compute::AWS::Error
end

class Fog::Compute::AWS::NotFound
end

class Fog::Compute::AWS::NotFound
end

class Fog::Compute::AWS
  def self.new(*arg); end
end

module Fog::Core
  VERSION = ::T.let(nil, ::T.untyped)
end

class Fog::CurrentMachine
  AMAZON_AWS_CHECK_IP = ::T.let(nil, ::T.untyped)
end

class Fog::DNS::AWS
end

module Fog::DNS::AWS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::DNS::AWS::Collections
end

class Fog::DNS::AWS::Error
end

class Fog::DNS::AWS::Error
end

class Fog::DNS::AWS::NotFound
end

class Fog::DNS::AWS::NotFound
end

class Fog::DNS::AWS
  def self.new(*arg); end
end

module Fog::Formatador
  INDENT_REGEX = ::T.let(nil, ::T.untyped)
  PARSE_REGEX = ::T.let(nil, ::T.untyped)
  STYLES = ::T.let(nil, ::T.untyped)
end

module Fog::Json
  VERSION = ::T.let(nil, ::T.untyped)
end

class Fog::Parsers::Base
  def attr_value(name, attrs); end

  def reset(); end

  def response(); end

  def value(); end
end

class Fog::Parsers::Base
end

module Fog::ServicesMixin
  E_SERVICE_PROVIDER_CONSTANT = ::T.let(nil, ::T.untyped)
  E_SERVICE_PROVIDER_PATH = ::T.let(nil, ::T.untyped)
end

class Fog::Storage::AWS
end

module Fog::Storage::AWS::Collections
  include ::Fog::Service::Collections
  def service(); end
end

module Fog::Storage::AWS::Collections
end

class Fog::Storage::AWS::Error
end

class Fog::Storage::AWS::Error
end

class Fog::Storage::AWS::NotFound
end

class Fog::Storage::AWS::NotFound
end

class Fog::Storage::AWS
  def self.new(*arg); end
end

class Fog::Time
  DAYS = ::T.let(nil, ::T.untyped)
  MONTHS = ::T.let(nil, ::T.untyped)
end

class Fog::ToHashDocument
  def body(); end

  def response(); end

  def start_element(name, attributes=T.unsafe(nil)); end
end

class Fog::ToHashDocument
end

class Fog::XML::Connection
  def request(params, &_block); end
end

class Fog::XML::Connection
end

class Fog::XML::Response
  def call(chunk, _remaining, _total); end

  def finish(); end

  def initialize(parser); end

  def rewind(); end
end

class Fog::XML::Response
end

class Fog::XML::SAXParserConnection
  def request(parser, params); end
end

class Fog::XML::SAXParserConnection
end

module Fog::Xml
  VERSION = ::T.let(nil, ::T.untyped)
end

class Formatador
  INDENT_REGEX = ::T.let(nil, ::T.untyped)
  PARSE_REGEX = ::T.let(nil, ::T.untyped)
  STYLES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FormationTalk
  include ::FormationTalk::GeneratedAttributeMethods
  include ::FormationTalk::GeneratedAssociationMethods
end

module FormationTalk::GeneratedAssociationMethods
end

module FormationTalk::GeneratedAssociationMethods
end

module FormationTalk::GeneratedAttributeMethods
end

module FormationTalk::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end
end

module GLib
  GLIB_TO_SEVERITY = ::T.let(nil, ::T.untyped)
  G_FREE = ::T.let(nil, ::T.untyped)
  LOG_FLAG_FATAL = ::T.let(nil, ::T.untyped)
  LOG_FLAG_RECURSION = ::T.let(nil, ::T.untyped)
  LOG_HANDLER = ::T.let(nil, ::T.untyped)
  LOG_LEVEL_CRITICAL = ::T.let(nil, ::T.untyped)
  LOG_LEVEL_DEBUG = ::T.let(nil, ::T.untyped)
  LOG_LEVEL_ERROR = ::T.let(nil, ::T.untyped)
  LOG_LEVEL_INFO = ::T.let(nil, ::T.untyped)
  LOG_LEVEL_MESSAGE = ::T.let(nil, ::T.untyped)
  LOG_LEVEL_WARNING = ::T.let(nil, ::T.untyped)
end

module GObject
  GBOOL_TYPE = ::T.let(nil, ::T.untyped)
  GDOUBLE_TYPE = ::T.let(nil, ::T.untyped)
  GENUM_TYPE = ::T.let(nil, ::T.untyped)
  GFLAGS_TYPE = ::T.let(nil, ::T.untyped)
  GINT_TYPE = ::T.let(nil, ::T.untyped)
  GOBJECT_TYPE = ::T.let(nil, ::T.untyped)
  GSTR_TYPE = ::T.let(nil, ::T.untyped)
  GUINT64_TYPE = ::T.let(nil, ::T.untyped)
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  ARCHDIR = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  EXACT = ::T.let(nil, ::T.untyped)
  LIBDIR = ::T.let(nil, ::T.untyped)
  LIBEXT = ::T.let(nil, ::T.untyped)
  PREFIXED = ::T.let(nil, ::T.untyped)
  SINCE = ::T.let(nil, ::T.untyped)
  WARNED = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  def self.build_message(gem); end

  def self.find_gem(path); end

  def self.replace_require(specs); end

  def self.warning?(name, specs: T.unsafe(nil)); end
end

class Gem::BasicSpecification
  def plugins(); end
end

module Gem::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Gem::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

Gem::Cache = Gem::SourceIndex

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end

  def last_update_check(); end

  def last_update_check=(timestamp); end

  def state_file_name(); end

  def state_file_writable?(); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
  def self.dump_with_rubygems_yaml(content); end

  def self.load_with_rubygems_config_hash(yaml); end
end

class Gem::Dependency
  include ::Bundler::ForcePlatform
  def force_ruby_platform(); end

  def prioritizes_bundler?(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(version=T.unsafe(nil)); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  DEPRECATED_EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_EXCEPTION_REGEXP = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_REGEXP = ::T.let(nil, ::T.untyped)
  LICENSE_REF = ::T.let(nil, ::T.untyped)
  VALID_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  def self.deprecated_exception_id?(license); end

  def self.deprecated_license_id?(license); end
end

module Gem::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::SpecificationProvider
end

module Gem::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Molinillo::UI
end

class Gem::NameTuple
  def lock_name(); end
end

module Gem::Net
end

class Gem::Net::BufferedIO
  def <<(*strs); end

  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def eof?(); end

  def initialize(io, read_timeout: T.unsafe(nil), write_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  def io(); end

  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  def read_all(dest=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readline(); end

  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  def write(*strs); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end

  def writeline(str); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
end

class Gem::Net::BufferedIO
end

class Gem::Net::HTTP
  def active?(); end

  def address(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def ca_path(); end

  def ca_path=(ca_path); end

  def cert(); end

  def cert=(cert); end

  def cert_store(); end

  def cert_store=(cert_store); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def close_on_empty_response(); end

  def close_on_empty_response=(close_on_empty_response); end

  def continue_timeout(); end

  def continue_timeout=(sec); end

  def copy(path, initheader=T.unsafe(nil)); end

  def delete(path, initheader=T.unsafe(nil)); end

  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def finish(); end

  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def get2(path, initheader=T.unsafe(nil), &block); end

  def head(path, initheader=T.unsafe(nil)); end

  def head2(path, initheader=T.unsafe(nil), &block); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(address, port=T.unsafe(nil)); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(keep_alive_timeout); end

  def key(); end

  def key=(key); end

  def local_host(); end

  def local_host=(local_host); end

  def local_port(); end

  def local_port=(local_port); end

  def lock(path, body, initheader=T.unsafe(nil)); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def move(path, initheader=T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def options(path, initheader=T.unsafe(nil)); end

  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def peer_cert(); end

  def port(); end

  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def post2(path, data, initheader=T.unsafe(nil), &block); end

  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def proppatch(path, body, initheader=T.unsafe(nil)); end

  def proxy?(); end

  def proxy_address(); end

  def proxy_address=(proxy_address); end

  def proxy_from_env=(proxy_from_env); end

  def proxy_from_env?(); end

  def proxy_pass(); end

  def proxy_pass=(proxy_pass); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_uri(); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def proxyaddr(); end

  def proxyport(); end

  def put(path, data, initheader=T.unsafe(nil)); end

  def put2(path, data, initheader=T.unsafe(nil), &block); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def request(req, body=T.unsafe(nil), &block); end

  def request_get(path, initheader=T.unsafe(nil), &block); end

  def request_head(path, initheader=T.unsafe(nil), &block); end

  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  def set_debug_output(output); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(); end

  def started?(); end

  def trace(path, initheader=T.unsafe(nil)); end

  def unlock(path, body, initheader=T.unsafe(nil)); end

  def use_ssl=(flag); end

  def use_ssl?(); end

  def verify_callback(); end

  def verify_callback=(verify_callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(sec); end
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
end

class Gem::Net::HTTP::Delete
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Delete
end

class Gem::Net::HTTP::Get
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Get
end

class Gem::Net::HTTP::Head
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Head
end

class Gem::Net::HTTP::Lock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Lock
end

class Gem::Net::HTTP::Mkcol
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Mkcol
end

class Gem::Net::HTTP::Move
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Move
end

class Gem::Net::HTTP::Options
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Options
end

class Gem::Net::HTTP::Patch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Patch
end

class Gem::Net::HTTP::Persistent
  def ca_file(); end

  def ca_file=(file); end

  def ca_path(); end

  def ca_path=(path); end

  def cert(); end

  def cert=(certificate); end

  def cert_store(); end

  def cert_store=(store); end

  def certificate(); end

  def certificate=(certificate); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def connection_for(uri); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def escape(str); end

  def expired?(connection); end

  def finish(connection); end

  def generation(); end

  def headers(); end

  def http_version(uri); end

  def http_versions(); end

  def idle_timeout(); end

  def idle_timeout=(idle_timeout); end

  def initialize(name: T.unsafe(nil), proxy: T.unsafe(nil), pool_size: T.unsafe(nil)); end

  def keep_alive(); end

  def keep_alive=(keep_alive); end

  def key(); end

  def key=(key); end

  def max_requests(); end

  def max_requests=(max_requests); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def name(); end

  def no_proxy(); end

  def normalize_uri(uri); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def override_headers(); end

  def pool(); end

  def private_key(); end

  def private_key=(key); end

  def proxy=(proxy); end

  def proxy_bypass?(host, port); end

  def proxy_from_env(); end

  def proxy_uri(); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def reconnect(); end

  def reconnect_ssl(); end

  def request(uri, req=T.unsafe(nil), &block); end

  def request_setup(req_or_uri); end

  def reset(connection); end

  def reuse_ssl_sessions(); end

  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  def shutdown(); end

  def socket_options(); end

  def ssl(connection); end

  def ssl_generation(); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(http); end

  def timeout_key(); end

  def unescape(str); end

  def verify_callback(); end

  def verify_callback=(callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Persistent::Connection
  def close(); end

  def finish(); end

  def http(); end

  def http=(http); end

  def initialize(http_class, http_args, ssl_generation); end

  def last_use(); end

  def last_use=(last_use); end

  def requests(); end

  def requests=(requests); end

  def reset(); end

  def ressl(ssl_generation); end

  def ssl_generation(); end

  def ssl_generation=(ssl_generation); end
end

class Gem::Net::HTTP::Persistent::Connection
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Pool
  def checkin(net_http_args); end

  def checkout(net_http_args); end

  def key(); end

  def shutdown(); end
end

class Gem::Net::HTTP::Persistent::Pool
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
  def self.hash_of_arrays(); end
end

class Gem::Net::HTTP::Persistent
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Gem::Net::HTTP::Post
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Post
end

class Gem::Net::HTTP::Propfind
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Propfind
end

class Gem::Net::HTTP::Proppatch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Proppatch
end

module Gem::Net::HTTP::ProxyDelta
end

module Gem::Net::HTTP::ProxyDelta
end

Gem::Net::HTTP::ProxyMod = Gem::Net::HTTP::ProxyDelta

class Gem::Net::HTTP::Put
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Put
end

class Gem::Net::HTTP::Trace
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Trace
end

class Gem::Net::HTTP::Unlock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Unlock
end

class Gem::Net::HTTP
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  def self.default_port(); end

  def self.get(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_print(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_response(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil), &block); end

  def self.http_default_port(); end

  def self.https_default_port(); end

  def self.is_version_1_1?(); end

  def self.is_version_1_2?(); end

  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil), p_no_proxy=T.unsafe(nil)); end

  def self.newobj(*arg, **arg1); end

  def self.post(url, data, header=T.unsafe(nil)); end

  def self.post_form(url, params); end

  def self.proxy_address(); end

  def self.proxy_class?(); end

  def self.proxy_pass(); end

  def self.proxy_port(); end

  def self.proxy_user(); end

  def self.socket_type(); end

  def self.start(address, *arg, &block); end

  def self.version_1_1?(); end

  def self.version_1_2(); end

  def self.version_1_2?(); end
end

class Gem::Net::HTTPAccepted
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAccepted
end

class Gem::Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAlreadyReported
end

class Gem::Net::HTTPBadGateway
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadGateway
end

class Gem::Net::HTTPBadRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadRequest
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPClientError
end

Gem::Net::HTTPClientErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPClientException
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPClientException
end

class Gem::Net::HTTPConflict
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPConflict
end

class Gem::Net::HTTPContinue
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPContinue
end

class Gem::Net::HTTPCreated
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPCreated
end

class Gem::Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPEarlyHints
end

class Gem::Net::HTTPError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPError
end

module Gem::Net::HTTPExceptions
  def data(); end

  def initialize(msg, res); end

  def response(); end
end

module Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPExpectationFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPExpectationFailed
end

class Gem::Net::HTTPFailedDependency
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFailedDependency
end

class Gem::Net::HTTPFatalError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPFatalError
end

Gem::Net::HTTPFatalErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPForbidden
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPForbidden
end

class Gem::Net::HTTPFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFound
end

Gem::Net::HTTPGatewayTimeOut = Gem::Net::HTTPGatewayTimeout

class Gem::Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGatewayTimeout
end

class Gem::Net::HTTPGenericRequest
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(str); end

  def body_exist?(); end

  def body_stream(); end

  def body_stream=(input); end

  def decode_content(); end

  def exec(sock, ver, path); end

  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  def method(); end

  def path(); end

  def request_body_permitted?(); end

  def response_body_permitted?(); end

  def set_body_internal(str); end

  def update_uri(addr, port, ssl); end

  def uri(); end
end

class Gem::Net::HTTPGenericRequest::Chunker
  def finish(); end

  def initialize(sock); end

  def write(buf); end
end

class Gem::Net::HTTPGenericRequest::Chunker
end

class Gem::Net::HTTPGenericRequest
end

class Gem::Net::HTTPGone
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGone
end

module Gem::Net::HTTPHeader
  def [](key); end

  def []=(key, val); end

  def add_field(key, val); end

  def basic_auth(account, password); end

  def canonical_each(); end

  def chunked?(); end

  def connection_close?(); end

  def connection_keep_alive?(); end

  def content_length(); end

  def content_length=(len); end

  def content_range(); end

  def content_type(); end

  def content_type=(type, params=T.unsafe(nil)); end

  def delete(key); end

  def each(&blk); end

  def each_capitalized(); end

  def each_capitalized_name(); end

  def each_header(); end

  def each_key(&block); end

  def each_name(&block); end

  def each_value(); end

  def fetch(key, *args, &block); end

  def form_data=(params, sep=T.unsafe(nil)); end

  def get_fields(key); end

  def initialize_http_header(initheader); end

  def key?(key); end

  def length(); end

  def main_type(); end

  def proxy_basic_auth(account, password); end

  def range(); end

  def range=(r, e=T.unsafe(nil)); end

  def range_length(); end

  def set_content_type(type, params=T.unsafe(nil)); end

  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  def set_form_data(params, sep=T.unsafe(nil)); end

  def set_range(r, e=T.unsafe(nil)); end

  def size(); end

  def sub_type(); end

  def to_hash(); end

  def type_params(); end
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

module Gem::Net::HTTPHeader
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPIMUsed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPIMUsed
end

class Gem::Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInformation
end

class Gem::Net::HTTPInformation
end

Gem::Net::HTTPInformationCode::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPInformation
end

class Gem::Net::HTTPInsufficientStorage
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInsufficientStorage
end

class Gem::Net::HTTPInternalServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInternalServerError
end

class Gem::Net::HTTPLengthRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLengthRequired
end

class Gem::Net::HTTPLocked
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLocked
end

class Gem::Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLoopDetected
end

class Gem::Net::HTTPMethodNotAllowed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMethodNotAllowed
end

class Gem::Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMisdirectedRequest
end

class Gem::Net::HTTPMovedPermanently
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMovedPermanently
end

Gem::Net::HTTPMovedTemporarily = Gem::Net::HTTPFound

class Gem::Net::HTTPMultiStatus
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultiStatus
end

Gem::Net::HTTPMultipleChoice = Gem::Net::HTTPMultipleChoices

class Gem::Net::HTTPMultipleChoices
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultipleChoices
end

class Gem::Net::HTTPNetworkAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNetworkAuthenticationRequired
end

class Gem::Net::HTTPNoContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNoContent
end

class Gem::Net::HTTPNonAuthoritativeInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNonAuthoritativeInformation
end

class Gem::Net::HTTPNotAcceptable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotAcceptable
end

class Gem::Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotExtended
end

class Gem::Net::HTTPNotFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotFound
end

class Gem::Net::HTTPNotImplemented
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotImplemented
end

class Gem::Net::HTTPNotModified
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotModified
end

class Gem::Net::HTTPOK
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPOK
end

class Gem::Net::HTTPPartialContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPartialContent
end

class Gem::Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPayloadTooLarge
end

class Gem::Net::HTTPPaymentRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPaymentRequired
end

class Gem::Net::HTTPPermanentRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPermanentRedirect
end

class Gem::Net::HTTPPreconditionFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionFailed
end

class Gem::Net::HTTPPreconditionRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionRequired
end

class Gem::Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProcessing
end

class Gem::Net::HTTPProxyAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProxyAuthenticationRequired
end

class Gem::Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRangeNotSatisfiable
end

class Gem::Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRedirection
end

Gem::Net::HTTPRedirectionCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRequest
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Gem::Net::HTTPRequest
end

Gem::Net::HTTPRequestEntityTooLarge = Gem::Net::HTTPPayloadTooLarge

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
end

Gem::Net::HTTPRequestTimeOut = Gem::Net::HTTPRequestTimeout

class Gem::Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestTimeout
end

Gem::Net::HTTPRequestURITooLarge = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestURITooLong = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestedRangeNotSatisfiable = Gem::Net::HTTPRangeNotSatisfiable

class Gem::Net::HTTPResetContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResetContent
end

Gem::Net::HTTPResponceReceiver = Gem::Net::HTTPResponse

class Gem::Net::HTTPResponse
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(value); end

  def body_encoding(); end

  def body_encoding=(value); end

  def code(); end

  def code_type(); end

  def decode_content(); end

  def decode_content=(decode_content); end

  def entity(); end

  def error!(); end

  def error_type(); end

  def header(); end

  def http_version(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(httpv, code, msg); end

  def message(); end

  def msg(); end

  def read_body(dest=T.unsafe(nil), &block); end

  def read_header(); end

  def reading_body(sock, reqmethodallowbody); end

  def response(); end

  def uri(); end

  def uri=(uri); end

  def value(); end
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResponse::Inflater
  def bytes_inflated(); end

  def finish(); end

  def inflate_adapter(dest); end

  def initialize(socket); end

  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  def read_all(dest); end
end

class Gem::Net::HTTPResponse::Inflater
end

class Gem::Net::HTTPResponse
  def self.body_permitted?(); end

  def self.exception_type(); end

  def self.read_new(sock); end
end

Gem::Net::HTTPResponseReceiver = Gem::Net::HTTPResponse

Gem::Net::HTTPRetriableCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRetriableError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPRetriableError
end

class Gem::Net::HTTPSeeOther
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSeeOther
end

class Gem::Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServerError
end

Gem::Net::HTTPServerErrorCode = Gem::Net::HTTPServerError

Gem::Net::HTTPServerException = Gem::Net::HTTPClientException

class Gem::Net::HTTPServiceUnavailable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServiceUnavailable
end

Gem::Net::HTTPSession = Gem::Net::HTTP

class Gem::Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSuccess
end

class Gem::Net::HTTPSuccess
end

Gem::Net::HTTPSuccessCode::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPSuccess
end

class Gem::Net::HTTPSwitchProtocol
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSwitchProtocol
end

class Gem::Net::HTTPTemporaryRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTemporaryRedirect
end

class Gem::Net::HTTPTooManyRequests
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTooManyRequests
end

class Gem::Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPURITooLong
end

class Gem::Net::HTTPUnauthorized
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnauthorized
end

class Gem::Net::HTTPUnavailableForLegalReasons
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnavailableForLegalReasons
end

class Gem::Net::HTTPUnknownResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPUnknownResponse::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPUnknownResponse
end

class Gem::Net::HTTPUnprocessableEntity
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnprocessableEntity
end

class Gem::Net::HTTPUnsupportedMediaType
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnsupportedMediaType
end

class Gem::Net::HTTPUpgradeRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUpgradeRequired
end

class Gem::Net::HTTPUseProxy
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUseProxy
end

class Gem::Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVariantAlsoNegotiates
end

class Gem::Net::HTTPVersionNotSupported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVersionNotSupported
end

class Gem::Net::InternetMessageIO
  def each_list_item(); end

  def each_message_chunk(); end

  def initialize(*arg, **arg1); end

  def write_message(src); end

  def write_message_0(src); end

  def write_message_by_block(&block); end
end

class Gem::Net::InternetMessageIO
end

module Gem::Net::NetPrivate
end

Gem::Net::NetPrivate::HTTPRequest = Gem::Net::HTTPRequest

Gem::Net::NetPrivate::Socket = Gem::Net::InternetMessageIO

module Gem::Net::NetPrivate
end

class Gem::Net::OpenTimeout
end

class Gem::Net::OpenTimeout
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoUnknownError
end

class Gem::Net::ProtoUnknownError
end

Gem::Net::ProtocRetryError = Gem::Net::ProtoRetriableError

class Gem::Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::Protocol
  def self.protocol_param(name, val); end
end

class Gem::Net::ProtocolError
end

class Gem::Net::ProtocolError
end

class Gem::Net::ReadAdapter
  def <<(str); end

  def initialize(block); end
end

class Gem::Net::ReadAdapter
end

class Gem::Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::ReadTimeout
end

class Gem::Net::WriteAdapter
  def <<(str); end

  def initialize(writer); end

  def print(str); end

  def printf(*args); end

  def puts(str=T.unsafe(nil)); end

  def write(str); end
end

class Gem::Net::WriteAdapter
end

class Gem::Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::WriteTimeout
end

module Gem::Net
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def normalized_linux_version(); end

  def normalized_linux_version_ext(); end
  WINDOWS = ::T.let(nil, ::T.untyped)
  X64_LINUX = ::T.let(nil, ::T.untyped)
  X64_LINUX_MUSL = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self._deprecated_match(platform); end

  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolv
  def each_address(name); end

  def each_name(address); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(resolvers=T.unsafe(nil), use_ipv6: T.unsafe(nil)); end
  AddressRegex = ::T.let(nil, ::T.untyped)
  DefaultResolver = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS
  def close(); end

  def each_address(name); end

  def each_name(address); end

  def each_resource(name, typeclass, &proc); end

  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def getresource(name, typeclass); end

  def getresources(name, typeclass); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end

  def timeouts=(values); end
  Port = ::T.let(nil, ::T.untyped)
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
  UDPSize = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end

  def use_ipv6?(); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::EncodeError
end

class Gem::Resolv::DNS::EncodeError
end

module Gem::Resolv::DNS::Label
end

class Gem::Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Gem::Resolv::DNS::Label::Str
end

module Gem::Resolv::DNS::Label
  def self.split(arg); end
end

class Gem::Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_list(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
end

class Gem::Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d, compress: T.unsafe(nil)); end

  def put_length16(); end

  def put_name(d, compress: T.unsafe(nil)); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Gem::Resolv::DNS::Message::MessageEncoder
end

class Gem::Resolv::DNS::Message
  def self.decode(m); end
end

class Gem::Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def absolute?(); end

  def eql?(other); end

  def initialize(labels, absolute=T.unsafe(nil)); end

  def length(); end

  def subdomain_of?(other); end

  def to_a(); end
end

class Gem::Resolv::DNS::Name
  def self.create(arg); end
end

module Gem::Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::OpCode
end

class Gem::Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Gem::Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Gem::Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::RCode
end

class Gem::Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Gem::Resolv::DNS::Requester::Sender
end

class Gem::Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
end

class Gem::Resolv::DNS::Requester::TCP
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
end

class Gem::Resolv::DNS::Requester
end

class Gem::Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end

  def ttl(); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
end

class Gem::Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CNAME
end

class Gem::Resolv::DNS::Resource::DomainName
  def initialize(name); end

  def name(); end
end

class Gem::Resolv::DNS::Resource::DomainName
end

class Gem::Resolv::DNS::Resource::Generic
  def data(); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Gem::Resolv::DNS::Resource::HINFO
  def cpu(); end

  def initialize(cpu, os); end

  def os(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::HINFO
end

module Gem::Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
end

class Gem::Resolv::DNS::Resource::IN::AAAA
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::AAAA
end

class Gem::Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::ANY
end

class Gem::Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::CNAME
end

class Gem::Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HINFO
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
end

class Gem::Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::LOC
end

class Gem::Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MINFO
end

class Gem::Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MX
end

class Gem::Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::NS
end

class Gem::Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::PTR
end

class Gem::Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SOA
end

class Gem::Resolv::DNS::Resource::IN::SRV
  def initialize(priority, weight, port, target); end

  def port(); end

  def priority(); end

  def target(); end

  def weight(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SRV
end

class Gem::Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SVCB
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Gem::Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::TXT
end

class Gem::Resolv::DNS::Resource::IN::WKS
  def address(); end

  def bitmap(); end

  def initialize(address, protocol, bitmap); end

  def protocol(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::WKS
end

module Gem::Resolv::DNS::Resource::IN
end

class Gem::Resolv::DNS::Resource::LOC
  def altitude(); end

  def hprecision(); end

  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end

  def latitude(); end

  def longitude(); end

  def ssize(); end

  def version(); end

  def vprecision(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::LOC
end

class Gem::Resolv::DNS::Resource::MINFO
  def emailbx(); end

  def initialize(rmailbx, emailbx); end

  def rmailbx(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MINFO
end

class Gem::Resolv::DNS::Resource::MX
  def exchange(); end

  def initialize(preference, exchange); end

  def preference(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MX
end

class Gem::Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::NS
end

class Gem::Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::PTR
end

class Gem::Resolv::DNS::Resource::SOA
  def expire(); end

  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end

  def minimum(); end

  def mname(); end

  def refresh(); end

  def retry(); end

  def rname(); end

  def serial(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::SOA
end

class Gem::Resolv::DNS::Resource::TXT
  def data(); end

  def initialize(first_string, *rest_strings); end

  def strings(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::TXT
end

class Gem::Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Gem::Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Gem::Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Gem::Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.open(*args); end

  def self.random(arg); end
end

class Gem::Resolv::Hosts
  def each_address(name, &proc); end

  def each_name(address, &proc); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(filename=T.unsafe(nil)); end

  def lazy_initialize(); end
  DefaultFileName = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::Hosts
end

class Gem::Resolv::IPv4
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex256 = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv4
  def self.create(arg); end
end

class Gem::Resolv::IPv6
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex_6Hex4Dec = ::T.let(nil, ::T.untyped)
  Regex_8Hex = ::T.let(nil, ::T.untyped)
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex4Dec = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv6
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::LOC::Alt
  def ==(other); end

  def altitude(); end

  def eql?(other); end

  def initialize(altitude); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Alt
  def self.create(arg); end
end

class Gem::Resolv::LOC::Coord
  def ==(other); end

  def coordinates(); end

  def eql?(other); end

  def initialize(coordinates, orientation); end

  def orientation(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Coord
  def self.create(arg); end
end

class Gem::Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end

  def initialize(scalar); end

  def scalar(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Size
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::MDNS
  AddressV4 = ::T.let(nil, ::T.untyped)
  AddressV6 = ::T.let(nil, ::T.untyped)
  Addresses = ::T.let(nil, ::T.untyped)
  Port = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::MDNS
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv
  def self.each_address(name, &block); end

  def self.each_name(address, &proc); end

  def self.getaddress(name); end

  def self.getaddresses(name); end

  def self.getname(address); end

  def self.getnames(address); end
end

class Gem::Resolver
  include ::Gem::Molinillo::UI
  include ::Gem::Molinillo::SpecificationProvider
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::SourceIndex
  def ==(other); end

  def add_spec(gem_spec, name=T.unsafe(nil)); end

  def add_specs(*gem_specs); end

  def all_gems(); end

  def dump(); end

  def each(&block); end

  def find_name(gem_name, requirement=T.unsafe(nil)); end

  def gem_signature(gem_full_name); end

  def gems(); end

  def index_signature(); end

  def initialize(specifications=T.unsafe(nil)); end

  def latest_specs(include_prerelease=T.unsafe(nil)); end

  def length(); end

  def load_gems_in(*spec_dirs); end

  def outdated(); end

  def prerelease_gems(); end

  def prerelease_specs(); end

  def refresh!(); end

  def released_gems(); end

  def released_specs(); end

  def remove_spec(full_name); end

  def search(gem_pattern, platform_only=T.unsafe(nil)); end

  def size(); end

  def spec_dirs(); end

  def spec_dirs=(spec_dirs); end

  def specification(full_name); end
end

class Gem::SourceIndex
  def self.from_gems_in(*spec_dirs); end

  def self.from_installed_gems(*deprecated); end

  def self.installed_spec_directories(); end

  def self.load_specification(file_name); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchMetadata
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def flatten_require_paths(); end

  def removed_method_calls(); end

  def to_ruby(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.find_by_full_name(full_name); end

  def self.latest_spec_for(name); end

  def self.remove_spec(spec); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end

  def validate_required_ruby_version(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def spec(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

module Gem::Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Timeout::Error
end

class Gem::Timeout::Error
  def self.handle_timeout(message); end
end

class Gem::Timeout::ExitException
  def exception(*arg); end
end

class Gem::Timeout::ExitException
end

module Gem::Timeout
  def self.ensure_timeout_thread_created(); end

  def self.timeout(sec, klass=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Gem::URI::BadURIError
end

class Gem::URI::BadURIError
end

class Gem::URI::Error
end

class Gem::URI::Error
end

class Gem::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Gem::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Gem::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::File
end

class Gem::URI::Generic
  include ::Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def decoded_password(); end

  def decoded_user(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def to_str(); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Gem::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Gem::URI::HTTP
  def authority(); end

  def origin(); end

  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTP
end

class Gem::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTPS
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAP
end

class Gem::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAPS
end

class Gem::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::URI::MailTo
end

Gem::URI::Parser = Gem::URI::RFC2396_Parser

Gem::URI::REGEXP = Gem::URI::RFC2396_REGEXP

class Gem::URI::RFC2396_Parser
  include ::Gem::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Gem::URI::RFC2396_Parser
end

module Gem::URI::RFC2396_REGEXP
end

module Gem::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Gem::URI::RFC2396_REGEXP::PATTERN
end

module Gem::URI::RFC2396_REGEXP
end

class Gem::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Gem::URI::RFC3986_Parser
end

module Gem::URI::Util
end

module Gem::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class Gem::URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WS
end

class Gem::URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WSS
end

module Gem::URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_uri_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end

  def self.scheme_list(); end

  def self.split(uri); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

class Gem::Version
  def partition_segments(ver); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::WebauthnVerificationError
  def initialize(message); end
end

class Gem::WebauthnVerificationError
end

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.default_user_install(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.discover_gems_on_require(); end

  def self.discover_gems_on_require=(discover_gems_on_require); end

  def self.dynamic_library_suffixes(); end

  def self.find_config_file(); end

  def self.find_default_spec(path); end

  def self.load_safe_marshal(); end

  def self.open_file(path, flags, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.solaris_platform?(); end

  def self.source_index(); end

  def self.state_file(); end

  def self.state_home(); end
end

module Geocoder::Calculations
  COMPASS_POINTS = ::T.let(nil, ::T.untyped)
  DEGREES_PER_RADIAN = ::T.let(nil, ::T.untyped)
  EARTH_RADII = ::T.let(nil, ::T.untyped)
  EARTH_RADIUS = ::T.let(nil, ::T.untyped)
  KM_IN_MI = ::T.let(nil, ::T.untyped)
  KM_IN_NM = ::T.let(nil, ::T.untyped)
end

class Geocoder::Configuration
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Geocoder::IpAddress
  PRIVATE_IPS = ::T.let(nil, ::T.untyped)
end

class Geocoder::Logger
  SEVERITY = ::T.let(nil, ::T.untyped)
end

module Geocoder::Request
  GEOCODER_CANDIDATE_HEADERS = ::T.let(nil, ::T.untyped)
end

class GetText::PoParser
  def _(x); end

  def _reduce_10(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def on_comment(comment); end

  def on_message(msgid, msgstr); end

  def parse(str, data, ignore_fuzzy=T.unsafe(nil)); end

  def unescape(orig); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module GlobalID::FixtureSet
  def global_id(fixture_set_name, label, column_type: T.unsafe(nil), **options); end

  def signed_global_id(fixture_set_name, label, column_type: T.unsafe(nil), **options); end
end

module GlobalID::FixtureSet
end

module GlobalID::Identification
  def to_gid(options=T.unsafe(nil)); end

  def to_gid_param(options=T.unsafe(nil)); end

  def to_global_id(options=T.unsafe(nil)); end

  def to_sgid(options=T.unsafe(nil)); end

  def to_sgid_param(options=T.unsafe(nil)); end

  def to_signed_global_id(options=T.unsafe(nil)); end
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid, options=T.unsafe(nil)); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid, options=T.unsafe(nil)); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::InvalidModelIdError
end

class GlobalID::Locator::InvalidModelIdError
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class Guard::Config
  def initialize(); end

  def silence_deprecations?(); end
end

module Guard::Deprecated::Dsl
  MORE_INFO_ON_UPGRADING_TO_GUARD_2 = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Dsl::ClassMethods
  def evaluate_guardfile(options=T.unsafe(nil)); end
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Dsl
  def self.add_deprecated(dsl_klass); end
end

module Guard::Deprecated::Evaluator
  def evaluate_guardfile(); end

  def reevaluate_guardfile(); end
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
  REEVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Evaluator
  def self.add_deprecated(klass); end
end

module Guard::Deprecated::Guard::ClassMethods
  def add_group(name, options=T.unsafe(nil)); end

  def add_guard(*args); end

  def add_plugin(name, options=T.unsafe(nil)); end

  def evaluate_guardfile(); end

  def evaluator(); end

  def get_guard_class(name, fail_gracefully=T.unsafe(nil)); end

  def group(filter); end

  def groups(filter); end

  def guard_gem_names(); end

  def guards(filter=T.unsafe(nil)); end

  def listener=(_); end

  def locate_guard(name); end

  def lock(); end

  def options(); end

  def plugin(filter); end

  def plugins(filter); end

  def reset_evaluator(_options); end

  def runner(); end

  def running(); end

  def scope(); end

  def scope=(scope); end
  ADD_GROUP = ::T.let(nil, ::T.untyped)
  ADD_GUARD = ::T.let(nil, ::T.untyped)
  ADD_PLUGIN = ::T.let(nil, ::T.untyped)
  EVALUATE_GUARDFILE = ::T.let(nil, ::T.untyped)
  EVALUATOR = ::T.let(nil, ::T.untyped)
  GET_GUARD_CLASS = ::T.let(nil, ::T.untyped)
  GROUP = ::T.let(nil, ::T.untyped)
  GROUPS = ::T.let(nil, ::T.untyped)
  GUARDS = ::T.let(nil, ::T.untyped)
  GUARD_GEM_NAMES = ::T.let(nil, ::T.untyped)
  LISTENER_ASSIGN = ::T.let(nil, ::T.untyped)
  LOCATE_GUARD = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
  MORE_INFO_ON_UPGRADING_TO_GUARD_2 = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PLUGIN = ::T.let(nil, ::T.untyped)
  PLUGINS = ::T.let(nil, ::T.untyped)
  RESET_EVALUATOR = ::T.let(nil, ::T.untyped)
  RUNNER = ::T.let(nil, ::T.untyped)
  RUNNING = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_ASSIGN = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Guard
  def self.add_deprecated(klass); end
end

module Guard::Deprecated::Watcher::ClassMethods
  def match_guardfile?(files); end
  MATCH_GUARDFILE = ::T.let(nil, ::T.untyped)
end

module Guard::Deprecated::Watcher
  def self.add_deprecated(klass); end
end

class Guard::Dsl
  def callback(*args, &block); end

  def clearing(on); end

  def directories(directories); end

  def evaluate(contents, filename, lineno); end

  def filter(*regexps); end

  def filter!(*regexps); end

  def group(*args); end

  def guard(name, options=T.unsafe(nil)); end

  def ignore(*regexps); end

  def ignore!(*regexps); end

  def interactor(options); end

  def logger(options); end

  def notification(notifier, opts=T.unsafe(nil)); end

  def scope(scope=T.unsafe(nil)); end

  def watch(pattern, &action); end
  WARN_INVALID_LOG_LEVEL = ::T.let(nil, ::T.untyped)
  WARN_INVALID_LOG_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Guard::DslReader
  def callback(*_args, &_block); end

  def clearing(_on); end

  def directories(_directories); end

  def group(*_args); end

  def guard(name, _options=T.unsafe(nil)); end

  def ignore(*_regexps); end

  def ignore!(*_regexps); end

  def interactor(_options); end

  def logger(_options); end

  def notification(_notifier, _opts=T.unsafe(nil)); end

  def plugin_names(); end

  def scope(_scope=T.unsafe(nil)); end

  def watch(_pattern, &_action); end
end

class Guard::Group
  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def title(); end
end

class Guard::Guardfile::Evaluator
  def custom?(); end

  def evaluate(); end

  def guardfile_contents(); end

  def guardfile_include?(plugin_name); end

  def guardfile_path(); end

  def guardfile_source(); end

  def initialize(opts=T.unsafe(nil)); end

  def inline?(); end

  def options(); end

  def path(); end
  DEFAULT_GUARDFILES = ::T.let(nil, ::T.untyped)
  ERROR_NO_GUARDFILE = ::T.let(nil, ::T.untyped)
  ERROR_NO_PLUGINS = ::T.let(nil, ::T.untyped)
end

class Guard::Interactor
  def background(*args, **arg, &block); end

  def foreground(*args, **arg, &block); end

  def handle_interrupt(*args, **arg, &block); end

  def initialize(no_interaction=T.unsafe(nil)); end

  def interactive?(); end
end

class Guard::Interactor
  def self.enabled(); end

  def self.enabled=(enabled); end

  def self.enabled?(); end

  def self.options(); end

  def self.options=(options); end
end

class Guard::Internals::Debugging
  def self.start(); end

  def self.stop(); end
end

class Guard::Internals::Groups
  def add(name, options=T.unsafe(nil)); end

  def all(filter=T.unsafe(nil)); end
  DEFAULT_GROUPS = ::T.let(nil, ::T.untyped)
end

module Guard::Internals::Helpers
  def _relative_pathname(path); end
end

class Guard::Internals::Plugins
  def add(name, options); end

  def all(filter=T.unsafe(nil)); end

  def remove(plugin); end
end

class Guard::Internals::Queue
  def <<(changes); end

  def initialize(commander); end

  def pending?(); end

  def process(); end
end

class Guard::Internals::Scope
  def from_interactor(scope); end

  def grouped_plugins(scope=T.unsafe(nil)); end

  def titles(scope=T.unsafe(nil)); end

  def to_hash(); end
end

class Guard::Internals::Session
  def clear?(); end

  def clearing(on); end

  def clearing?(); end

  def cmdline_groups(); end

  def cmdline_plugins(); end

  def convert_scope(entries); end

  def debug?(); end

  def evaluator_options(); end

  def groups(); end

  def guardfile_group_scope(); end

  def guardfile_ignore(); end

  def guardfile_ignore=(ignores); end

  def guardfile_ignore_bang(); end

  def guardfile_ignore_bang=(guardfile_ignore_bang); end

  def guardfile_notification=(config); end

  def guardfile_plugin_scope(); end

  def guardfile_scope(scope); end

  def initialize(new_options); end

  def interactor_name(); end

  def listener_args(); end

  def notify_options(); end

  def plugins(); end

  def watchdirs(); end

  def watchdirs=(dirs); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Guard::Internals::State
  def initialize(cmdline_opts); end

  def scope(); end

  def session(); end
end

module Guard::Internals::Tracing
  def self.trace(mod, meth); end

  def self.untrace(mod, meth); end
end

module Guard::Internals::Traps
  def self.handle(signal, &block); end
end

class Guard::Notifier
  DEPRECATED_IMPLICIT_CONNECT = ::T.let(nil, ::T.untyped)
end

class Guard::Notifier
  def self.connect(options=T.unsafe(nil)); end

  def self.detected(); end

  def self.disconnect(); end

  def self.notify(message, options=T.unsafe(nil)); end

  def self.supported(); end

  def self.toggle(); end

  def self.turn_on(); end
end

class Guard::Options
  def fetch(name); end

  def initialize(opts=T.unsafe(nil), default_opts=T.unsafe(nil)); end
end

class Guard::Plugin
  def callbacks(); end

  def callbacks=(callbacks); end

  def group(); end

  def group=(group); end

  def hook(event, *args); end

  def initialize(options=T.unsafe(nil)); end

  def name(); end

  def options(); end

  def options=(options); end

  def title(); end

  def watchers(); end

  def watchers=(watchers); end
  TEMPLATE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Guard::Plugin
  def self.add_callback(listener, guard_plugin, events); end

  def self.callbacks(); end

  def self.non_namespaced_classname(); end

  def self.non_namespaced_name(); end

  def self.notify(guard_plugin, event, *args); end

  def self.reset_callbacks!(); end

  def self.template(plugin_location); end
end

class Guard::PluginUtil
  def add_to_guardfile(); end

  def initialize(name); end

  def initialize_plugin(options); end

  def name(); end

  def name=(name); end

  def plugin_class(options=T.unsafe(nil)); end

  def plugin_location(); end
  ERROR_NO_GUARD_OR_CLASS = ::T.let(nil, ::T.untyped)
  INFO_ADDED_GUARD_TO_GUARDFILE = ::T.let(nil, ::T.untyped)
end

class Guard::PluginUtil
  def self._gem_valid?(gem); end

  def self.plugin_names(); end
end

class Guard::Runner
  def _supervise(plugin, task, *args); end

  def run(task, scope_hash=T.unsafe(nil)); end

  def run_on_changes(modified, added, removed); end
  ADDITION_TASKS = ::T.let(nil, ::T.untyped)
  MODIFICATION_TASKS = ::T.let(nil, ::T.untyped)
  PLUGIN_FAILED = ::T.let(nil, ::T.untyped)
  REMOVAL_TASKS = ::T.let(nil, ::T.untyped)
end

class Guard::Runner
  def self.stopping_symbol_for(guard); end
end

class Guard::Terminal
  def self.clear(); end
end

module Guard::UI::Colors
  ANSI_ESCAPE_BGBLACK = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGBLUE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGCYAN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGGREEN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGMAGENTA = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGRED = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGWHITE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BGYELLOW = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BLACK = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BLUE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_BRIGHT = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_CYAN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_GREEN = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_MAGENTA = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_RED = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_WHITE = ::T.let(nil, ::T.untyped)
  ANSI_ESCAPE_YELLOW = ::T.let(nil, ::T.untyped)
end

class Guard::UI::Config
  def [](name); end

  def device(); end

  def except(); end

  def initialize(options=T.unsafe(nil)); end

  def logger_config(); end

  def only(); end

  def with_progname(name); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEPRECATED_OPTS = ::T.let(nil, ::T.untyped)
end

class Guard::UI::Logger::Config
  def initialize(options=T.unsafe(nil)); end

  def level=(value); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

module Guard::UI
  def self.action_with_scopes(action, scope); end

  def self.clear(opts=T.unsafe(nil)); end

  def self.clearable(); end

  def self.debug(message, options=T.unsafe(nil)); end

  def self.deprecation(message, options=T.unsafe(nil)); end

  def self.error(message, options=T.unsafe(nil)); end

  def self.info(message, options=T.unsafe(nil)); end

  def self.level=(new_level); end

  def self.logger(); end

  def self.options(); end

  def self.options=(options); end

  def self.reset_and_clear(); end

  def self.reset_line(); end

  def self.reset_logger(); end

  def self.warning(message, options=T.unsafe(nil)); end
end

class Guard::Watcher
  def ==(other); end

  def action(); end

  def action=(action); end

  def call_action(matches); end

  def initialize(pattern, action=T.unsafe(nil)); end

  def match(string_or_pathname); end

  def pattern(); end

  def pattern=(pattern); end
end

class Guard::Watcher::Pattern::DeprecatedRegexp
  def deprecated?(); end

  def initialize(pattern); end
end

class Guard::Watcher::Pattern::DeprecatedRegexp
  def self.convert(pattern); end

  def self.show_deprecation(pattern); end
end

class Guard::Watcher::Pattern::MatchResult
  def [](index); end

  def initialize(match_result, original_value); end
end

class Guard::Watcher::Pattern::Matcher
  def ==(other); end

  def initialize(obj); end

  def match(string_or_pathname); end

  def matcher(); end
end

class Guard::Watcher::Pattern::SimplePath
  def initialize(string_or_pathname); end

  def match(string_or_pathname); end

  def normalize(string_or_pathname); end
end

class Guard::Watcher::Pattern
  def self.create(pattern); end
end

class Guard::Watcher
  def self.match_files(guard, files); end
end

module Guard
  extend ::Guard::Internals::Helpers
  def self.async_queue_add(changes); end

  def self.init(cmdline_options); end

  def self.interactor(); end

  def self.listener(); end

  def self.queue(); end

  def self.setup(cmdline_options=T.unsafe(nil)); end

  def self.state(); end
end

class HTMLEntities
  def decode(source); end

  def encode(source, *instructions); end

  def initialize(flavor=T.unsafe(nil)); end
  FLAVORS = ::T.let(nil, ::T.untyped)
  MAPPINGS = ::T.let(nil, ::T.untyped)
  SKIP_DUP_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class HTMLEntities::Decoder
  def decode(source); end

  def initialize(flavor); end
end

class HTMLEntities::Encoder
  def encode(source); end

  def initialize(flavor, instructions); end
  INSTRUCTIONS = ::T.let(nil, ::T.untyped)
end

module HTMLEntities::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class HTTParty::Decompressor
  SupportedEncodings = ::T.let(nil, ::T.untyped)
end

class HTTParty::Request::Body
  MULTIPART_FORM_DATA_REPLACEMENT_TABLE = ::T.let(nil, ::T.untyped)
end

class HTTParty::Response::Headers
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class HTTParty::ResponseFragment
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hash
  def deconstruct_keys(arg); end

  def deep_transform_values(&block); end

  def deep_transform_values!(&block); end
end

class Hash
  def self.from_trusted_xml(xml); end

  def self.ruby2_keywords_hash(arg); end
end

class Homilist
  include ::Homilist::GeneratedAttributeMethods
  include ::Homilist::GeneratedAssociationMethods
  def autosave_associated_records_for_sermons(*args); end

  def validate_associated_records_for_sermons(*args); end
end

module Homilist::GeneratedAssociationMethods
  def sermon_ids(); end

  def sermon_ids=(ids); end

  def sermons(); end

  def sermons=(value); end
end

module Homilist::GeneratedAssociationMethods
end

module Homilist::GeneratedAttributeMethods
end

module Homilist::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Hotwire
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Base
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def resolve_entry(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Chain::Implementation
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(token); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::Flatten
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::LazyLoadable
  def initialize(lazy_load: T.unsafe(nil)); end

  def initialized_locales(); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
  def initialize(file, expected_locale, unexpected_locales); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
end

class I18n::Backend::LazyLoadable
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

class I18n::Backend::Simple
  include ::I18n::Backend::Pluralization
end

module I18n::Backend::Simple::Implementation
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
  MUTEX = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

class I18n::InvalidFilenames
  NUMBER_OF_ERRORS_SHOWN = ::T.let(nil, ::T.untyped)
end

I18n::JSON = ActiveSupport::JSON

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

class I18n::Locale::Tag::Rfc4646
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

module I18n::MissingTranslation::Base
  PERMITTED_KEYS = ::T.let(nil, ::T.untyped)
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.perform_caching?(); end
end

module INotify
  VERSION = ::T.let(nil, ::T.untyped)
end

class INotify::Event
  def absolute_name(); end

  def callback!(); end

  def cookie(); end

  def flags(); end

  def initialize(data, notifier); end

  def name(); end

  def notifier(); end

  def related(); end

  def size(); end

  def watcher(); end

  def watcher_id(); end
end

class INotify::Event
  def self.consume(data, notifier); end
end

module INotify::Native
  def fpathconf(*arg); end

  def inotify_add_watch(*arg); end

  def inotify_init(*arg); end

  def inotify_rm_watch(*arg); end
end

module INotify::Native::Flags
  IN_ACCESS = ::T.let(nil, ::T.untyped)
  IN_ALL_EVENTS = ::T.let(nil, ::T.untyped)
  IN_ATTRIB = ::T.let(nil, ::T.untyped)
  IN_CLOSE = ::T.let(nil, ::T.untyped)
  IN_CLOSE_NOWRITE = ::T.let(nil, ::T.untyped)
  IN_CLOSE_WRITE = ::T.let(nil, ::T.untyped)
  IN_CREATE = ::T.let(nil, ::T.untyped)
  IN_DELETE = ::T.let(nil, ::T.untyped)
  IN_DELETE_SELF = ::T.let(nil, ::T.untyped)
  IN_DONT_FOLLOW = ::T.let(nil, ::T.untyped)
  IN_IGNORED = ::T.let(nil, ::T.untyped)
  IN_ISDIR = ::T.let(nil, ::T.untyped)
  IN_MASK_ADD = ::T.let(nil, ::T.untyped)
  IN_MODIFY = ::T.let(nil, ::T.untyped)
  IN_MOVE = ::T.let(nil, ::T.untyped)
  IN_MOVED_FROM = ::T.let(nil, ::T.untyped)
  IN_MOVED_TO = ::T.let(nil, ::T.untyped)
  IN_MOVE_SELF = ::T.let(nil, ::T.untyped)
  IN_ONESHOT = ::T.let(nil, ::T.untyped)
  IN_ONLYDIR = ::T.let(nil, ::T.untyped)
  IN_OPEN = ::T.let(nil, ::T.untyped)
  IN_Q_OVERFLOW = ::T.let(nil, ::T.untyped)
  IN_UNMOUNT = ::T.let(nil, ::T.untyped)
  PC_NAME_MAX = ::T.let(nil, ::T.untyped)
end

module INotify::Native::Flags
  def self.from_mask(mask); end

  def self.to_mask(flags); end
end

module INotify::Native
  def self.fpathconf(*arg); end

  def self.inotify_add_watch(*arg); end

  def self.inotify_init(*arg); end

  def self.inotify_rm_watch(*arg); end
end

class INotify::Notifier
  def close(); end

  def fd(); end

  def process(); end

  def read_events(); end

  def run(); end

  def stop(); end

  def to_io(); end

  def watch(path, *flags, &callback); end

  def watchers(); end
  RECURSIVE_BLACKLIST = ::T.let(nil, ::T.untyped)
end

class INotify::Watcher
  def callback!(event); end

  def close(); end

  def flags(); end

  def id(); end

  def initialize(notifier, path, *flags, &callback); end

  def notifier(); end

  def path(); end
end

class IO
  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def path(); end

  def pathconf(arg); end

  def ready?(); end

  def timeout(); end

  def timeout=(timeout); end

  def to_path(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def &(arg); end

  def ^(arg); end

  def and!(arg); end

  def clear(*arg); end

  def copy(*arg); end

  def each(*arg, &blk); end

  def each_byte(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def get_values(arg, arg1); end

  def hexdump(*arg); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def not!(); end

  def null?(); end

  def or!(arg); end

  def pread(*arg); end

  def private?(); end

  def pwrite(*arg); end

  def read(*arg); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def set_values(arg, arg1, arg2); end

  def shared?(); end

  def size(); end

  def slice(*arg); end

  def transfer(); end

  def valid?(); end

  def values(*arg); end

  def write(*arg); end

  def xor!(arg); end

  def |(arg); end

  def ~(); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  SHARED = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::MaskError
end

class IO::Buffer::MaskError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end

  def self.size_of(arg); end

  def self.string(arg); end
end

class IO::ConsoleMode
  VERSION = ::T.let(nil, ::T.untyped)
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO::TimeoutError
end

class IO::TimeoutError
end

class IO
  def self.console(*arg); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.new(*arg); end
end

class IPAddr
  def ==(other); end

  def begin_addr(); end

  def end_addr(); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::BaseCompletor
  GEM_PATHS = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  DIM = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class IRB::ColorPrinter
  METHOD_INSPECT = ::T.let(nil, ::T.untyped)
  METHOD_RESPOND_TO = ::T.let(nil, ::T.untyped)
end

module IRB::Command
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

class IRB::Command::Debug
  BINDING_IRB_FRAME_REGEXPS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

module IRB::Debug
  IRB_DIR = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommand = IRB::Command

module IRB::InputCompletor
  CompletionProc = ::T.let(nil, ::T.untyped)
end

class IRB::InputMethod
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  KERNEL_INSPECT = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
  CONTROL_CHARACTERS_PATTERN = ::T.let(nil, ::T.untyped)
  PROMPT_MAIN_TRUNCATE_LENGTH = ::T.let(nil, ::T.untyped)
  PROMPT_MAIN_TRUNCATE_OMISSION = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
  LEGACY_ENCODING_ALIAS_MAP = ::T.let(nil, ::T.untyped)
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

module IRB::NestingParser
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
end

class IRB::Pager
  PAGE_COMMANDS = ::T.let(nil, ::T.untyped)
end

class IRB::RegexpCompletor
  Operators = ::T.let(nil, ::T.untyped)
end

class IRB::RelineInputMethod
  HISTORY = ::T.let(nil, ::T.untyped)
end

class IRB::RubyLex
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
  ERROR_TOKENS = ::T.let(nil, ::T.untyped)
  FREE_INDENT_TOKENS = ::T.let(nil, ::T.untyped)
  LTYPE_TOKENS = ::T.let(nil, ::T.untyped)
end

module ImageProcessing
  VERSION = ::T.let(nil, ::T.untyped)
end

module ImageProcessing::Chainable
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ImageProcessing::MiniMagick
end

class ImageProcessing::MiniMagick::Processor
  def append(*args); end

  def composite(overlay=T.unsafe(nil), mask: T.unsafe(nil), mode: T.unsafe(nil), gravity: T.unsafe(nil), offset: T.unsafe(nil), args: T.unsafe(nil), **options, &block); end

  def crop(*args); end

  def define(options); end

  def limits(options); end

  def magick(); end

  def resize_and_pad(width, height, background: T.unsafe(nil), gravity: T.unsafe(nil), **options); end

  def resize_to_fill(width, height, gravity: T.unsafe(nil), **options); end

  def resize_to_fit(width, height, **options); end

  def resize_to_limit(width, height, **options); end

  def rotate(degrees, background: T.unsafe(nil)); end
  SHARPEN_PARAMETERS = ::T.let(nil, ::T.untyped)
end

ImageProcessing::MiniMagick::Processor::ACCUMULATOR_CLASS = MiniMagick::Tool

module ImageProcessing::MiniMagick::Processor::Utils
end

module ImageProcessing::MiniMagick::Processor::Utils
  def self.apply_define(magick, options); end

  def self.apply_options(magick, define: T.unsafe(nil), **options); end

  def self.disallow_split_layers!(destination_path); end
end

class ImageProcessing::MiniMagick::Processor
  def self.load_image(path_or_magick, loader: T.unsafe(nil), page: T.unsafe(nil), geometry: T.unsafe(nil), auto_orient: T.unsafe(nil), **options); end

  def self.save_image(magick, destination_path, allow_splitting: T.unsafe(nil), **options); end
end

module ImageProcessing::MiniMagick
  extend ::ImageProcessing::Chainable
  def self.valid_image?(file); end
end

class ImageProcessing::Pipeline
  DEFAULT_FORMAT = ::T.let(nil, ::T.untyped)
end

module ImageProcessing::Vips
end

class ImageProcessing::Vips::Processor
  def composite(overlay, _mode=T.unsafe(nil), mode: T.unsafe(nil), gravity: T.unsafe(nil), offset: T.unsafe(nil), **options); end

  def image(); end

  def remove(*args); end

  def resize_and_pad(width, height, gravity: T.unsafe(nil), extend: T.unsafe(nil), background: T.unsafe(nil), alpha: T.unsafe(nil), **options); end

  def resize_to_fill(width, height, **options); end

  def resize_to_fit(width, height, **options); end

  def resize_to_limit(width, height, **options); end

  def rotate(degrees, **options); end

  def set(*args); end

  def set_type(*args); end

  def set_value(*args); end
  SHARPEN_MASK = ::T.let(nil, ::T.untyped)
end

ImageProcessing::Vips::Processor::ACCUMULATOR_CLASS = Vips::Image

module ImageProcessing::Vips::Processor::Utils
end

module ImageProcessing::Vips::Processor::Utils
  def self.select_valid_loader_options(source_path, options); end

  def self.select_valid_options(operation_name, options); end

  def self.select_valid_saver_options(destination_path, options); end
end

class ImageProcessing::Vips::Processor
  def self.load_image(path_or_image, loader: T.unsafe(nil), autorot: T.unsafe(nil), **options); end

  def self.save_image(image, path, saver: T.unsafe(nil), quality: T.unsafe(nil), **options); end
end

module ImageProcessing::Vips
  extend ::ImageProcessing::Chainable
  def self.valid_image?(file); end
end

class Insertion
  def after(val, recursive=T.unsafe(nil)); end

  def after_any(val); end

  def before(val, recursive=T.unsafe(nil)); end

  def before_any(val); end

  def initialize(list, value); end
end

class Integer
  include ::ActiveSupport::NumericWithFormat
  def ceildiv(other); end

  def multiple_of?(number); end

  def ordinal(); end

  def ordinalize(); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.try_convert(arg); end
end

module JMESPath
  VERSION = ::T.let(nil, ::T.untyped)
end

class JMESPath::Lexer
  NUMBERS = ::T.let(nil, ::T.untyped)
  SIMPLE_TOKENS = ::T.let(nil, ::T.untyped)
  STATE_AND = ::T.let(nil, ::T.untyped)
  STATE_EQ = ::T.let(nil, ::T.untyped)
  STATE_GT = ::T.let(nil, ::T.untyped)
  STATE_IDENTIFIER = ::T.let(nil, ::T.untyped)
  STATE_JSON_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_LBRACKET = ::T.let(nil, ::T.untyped)
  STATE_LT = ::T.let(nil, ::T.untyped)
  STATE_NOT = ::T.let(nil, ::T.untyped)
  STATE_NUMBER = ::T.let(nil, ::T.untyped)
  STATE_PIPE = ::T.let(nil, ::T.untyped)
  STATE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  STATE_SINGLE_CHAR = ::T.let(nil, ::T.untyped)
  STATE_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  STATE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TRANSLATION_TABLE = ::T.let(nil, ::T.untyped)
  T_AND = ::T.let(nil, ::T.untyped)
  T_COLON = ::T.let(nil, ::T.untyped)
  T_COMMA = ::T.let(nil, ::T.untyped)
  T_COMPARATOR = ::T.let(nil, ::T.untyped)
  T_CURRENT = ::T.let(nil, ::T.untyped)
  T_DOT = ::T.let(nil, ::T.untyped)
  T_EOF = ::T.let(nil, ::T.untyped)
  T_EXPREF = ::T.let(nil, ::T.untyped)
  T_FILTER = ::T.let(nil, ::T.untyped)
  T_FLATTEN = ::T.let(nil, ::T.untyped)
  T_IDENTIFIER = ::T.let(nil, ::T.untyped)
  T_LBRACE = ::T.let(nil, ::T.untyped)
  T_LBRACKET = ::T.let(nil, ::T.untyped)
  T_LITERAL = ::T.let(nil, ::T.untyped)
  T_LPAREN = ::T.let(nil, ::T.untyped)
  T_NOT = ::T.let(nil, ::T.untyped)
  T_NUMBER = ::T.let(nil, ::T.untyped)
  T_OR = ::T.let(nil, ::T.untyped)
  T_PIPE = ::T.let(nil, ::T.untyped)
  T_QUOTED_IDENTIFIER = ::T.let(nil, ::T.untyped)
  T_RBRACE = ::T.let(nil, ::T.untyped)
  T_RBRACKET = ::T.let(nil, ::T.untyped)
  T_RPAREN = ::T.let(nil, ::T.untyped)
  T_STAR = ::T.let(nil, ::T.untyped)
  T_UNKNOWN = ::T.let(nil, ::T.untyped)
  VALID_IDENTIFIERS = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::Comparator
  COMPARABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::ComparatorCondition
  COMPARABLE_TYPES = ::T.let(nil, ::T.untyped)
  COMPARATOR_TO_CONDITION = ::T.let(nil, ::T.untyped)
end

class JMESPath::Nodes::Function
  FUNCTIONS = ::T.let(nil, ::T.untyped)
end

JMESPath::Nodes::Index = JMESPath::Nodes::Field

JMESPath::Nodes::Pipe = JMESPath::Nodes::Subexpression

module JMESPath::Nodes::TypeChecker
  ARRAY_TYPE = ::T.let(nil, ::T.untyped)
  BOOLEAN_TYPE = ::T.let(nil, ::T.untyped)
  EXPRESSION_TYPE = ::T.let(nil, ::T.untyped)
  NULL_TYPE = ::T.let(nil, ::T.untyped)
  NUMBER_TYPE = ::T.let(nil, ::T.untyped)
  OBJECT_TYPE = ::T.let(nil, ::T.untyped)
  STRING_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class JMESPath::Parser
  AFTER_DOT = ::T.let(nil, ::T.untyped)
  COLON_RBRACKET = ::T.let(nil, ::T.untyped)
  CURRENT_NODE = ::T.let(nil, ::T.untyped)
  NUM_COLON_RBRACKET = ::T.let(nil, ::T.untyped)
end

JMESPath::Runtime::DEFAULT_PARSER = JMESPath::CachingParser

class JMESPath::Token
  BINDING_POWER = ::T.let(nil, ::T.untyped)
  NULL_TOKEN = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end

  def script_safe(); end

  def script_safe=(script_safe); end

  def script_safe?(); end

  def strict(); end

  def strict=(strict); end

  def strict?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  extend ::Bootsnap::CompileCache::JSON::Patch
  def self.create_fast_state(); end

  def self.create_pretty_state(); end
end

module JaroWinkler
  VERSION = ::T.let(nil, ::T.untyped)
end

class JaroWinkler::Error
end

class JaroWinkler::Error
end

class JaroWinkler::InvalidWeightError
end

class JaroWinkler::InvalidWeightError
end

module JaroWinkler
  def self.distance(*arg); end

  def self.jaro_distance(*arg); end
end

class Jbuilder
  BLANK = ::T.let(nil, ::T.untyped)
  NON_ENUMERABLES = ::T.let(nil, ::T.untyped)
end

class Jbuilder::DependencyTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  DIRECT_RENDERS = ::T.let(nil, ::T.untyped)
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  INDIRECT_RENDERS = ::T.let(nil, ::T.untyped)
end

class Jbuilder::DependencyTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end
end

class Jbuilder::EnumerableCompat
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Jsbundling
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kernel
  include ::DEBUGGER__::TrapInterceptor
  def Namespace(name); end

  def TypeName(string); end

  def class_eval(*args, &block); end

  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end

  def self.exit(*arg); end

  def self.no_warning_require(arg); end

  def self.trap(*arg); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module Kramdown
  VERSION = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Base
  def apply_template_after?(); end

  def apply_template_before?(); end

  def basic_generate_id(str); end

  def convert(_el); end

  def data(); end

  def extract_code_language(attr); end

  def extract_code_language!(attr); end

  def format_math(el, opts=T.unsafe(nil)); end

  def generate_id(str); end

  def highlight_code(text, lang, type, opts=T.unsafe(nil)); end

  def in_toc?(el); end

  def initialize(root, options); end

  def options(); end

  def output_header_level(level); end

  def root(); end

  def smart_quote_entity(el); end

  def warning(text); end

  def warnings(); end
  SMART_QUOTE_INDICES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Base
  def self.apply_template(converter, body); end

  def self.convert(tree, options=T.unsafe(nil)); end

  def self.get_template(template); end
end

class Kramdown::Converter::HashAST
  def convert(el); end
end

class Kramdown::Converter::HashAST
end

Kramdown::Converter::HashAst = Kramdown::Converter::HashAST

class Kramdown::Converter::Html
  def add_syntax_highlighter_to_class_attr(attr, lang=T.unsafe(nil)); end

  def convert(el, indent=T.unsafe(nil)); end

  def convert_a(el, indent); end

  def convert_abbreviation(el, _indent); end

  def convert_blank(_el, _indent); end

  def convert_blockquote(el, indent); end

  def convert_br(_el, _indent); end

  def convert_codeblock(el, indent); end

  def convert_codespan(el, _indent); end

  def convert_comment(el, indent); end

  def convert_dd(el, indent); end

  def convert_dl(el, indent); end

  def convert_dt(el, indent); end

  def convert_em(el, indent); end

  def convert_entity(el, _indent); end

  def convert_footnote(el, _indent); end

  def convert_header(el, indent); end

  def convert_hr(el, indent); end

  def convert_html_element(el, indent); end

  def convert_img(el, _indent); end

  def convert_li(el, indent); end

  def convert_math(el, indent); end

  def convert_ol(el, indent); end

  def convert_p(el, indent); end

  def convert_raw(el, _indent); end

  def convert_root(el, indent); end

  def convert_smart_quote(el, _indent); end

  def convert_standalone_image(el, indent); end

  def convert_strong(el, indent); end

  def convert_table(el, indent); end

  def convert_tbody(el, indent); end

  def convert_td(el, indent); end

  def convert_text(el, _indent); end

  def convert_tfoot(el, indent); end

  def convert_thead(el, indent); end

  def convert_tr(el, indent); end

  def convert_typographic_sym(el, _indent); end

  def convert_ul(el, indent); end

  def convert_xml_comment(el, indent); end

  def convert_xml_pi(el, indent); end

  def fix_for_toc_entry(elements); end

  def footnote_content(); end

  def format_as_block_html(name, attr, body, indent); end

  def format_as_indented_block_html(name, attr, body, indent); end

  def format_as_span_html(name, attr, body); end

  def generate_toc_tree(toc, type, attr); end

  def indent(); end

  def indent=(indent); end

  def inner(el, indent); end

  def obfuscate(text); end

  def remove_footnotes(elements); end

  def unwrap_links(elements); end
  ENTITY_NBSP = ::T.let(nil, ::T.untyped)
  FOOTNOTE_BACKLINK_FMT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Kramdown
  include ::Kramdown::Utils::Html
  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, _opts); end

  def convert_blank(_el, _opts); end

  def convert_blockquote(el, opts); end

  def convert_br(_el, _opts); end

  def convert_codeblock(el, _opts); end

  def convert_codespan(el, _opts); end

  def convert_comment(el, _opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, _opts); end

  def convert_footnote(el, _opts); end

  def convert_header(el, opts); end

  def convert_hr(_el, _opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, _opts); end

  def convert_li(el, opts); end

  def convert_math(el, _opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, _opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, _opts); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, _opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, _opts); end

  def convert_xml_pi(el, _opts); end

  def create_abbrev_defs(); end

  def create_footnote_defs(); end

  def create_link_defs(); end

  def ial_for_element(el); end

  def inner(el, opts=T.unsafe(nil)); end

  def parse_title(attr); end
  ESCAPED_CHAR_RE = ::T.let(nil, ::T.untyped)
  HTML_TAGS_WITH_BODY = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Kramdown
end

class Kramdown::Converter::Latex
  def attribute_list(el); end

  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, _opts); end

  def convert_blank(_el, opts); end

  def convert_blockquote(el, opts); end

  def convert_br(_el, opts); end

  def convert_codeblock(el, _opts); end

  def convert_codespan(el, _opts); end

  def convert_comment(el, _opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, _opts); end

  def convert_footnote(el, opts); end

  def convert_header(el, opts); end

  def convert_hr(el, _opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, _opts); end

  def convert_li(el, opts); end

  def convert_math(el, _opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, _opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, opts); end

  def convert_standalone_image(el, _opts, img); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, _opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, _opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, _opts); end

  def convert_xml_pi(_el, _opts); end

  def entity_to_latex(entity); end

  def escape(str); end

  def inner(el, opts); end

  def latex_environment(type, el, text); end

  def latex_link_target(el, add_label=T.unsafe(nil)); end

  def normalize_abbreviation_key(key); end
  ENTITY_CONV_TABLE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
  TABLE_ALIGNMENT_CHAR = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Latex
end

class Kramdown::Converter::Man
  def convert(el, opts=T.unsafe(nil)); end
  TABLE_CELL_ALIGNMENT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_MAP = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Man
end

class Kramdown::Converter::RemoveHtmlTags
  def convert(el); end
end

class Kramdown::Converter::RemoveHtmlTags
end

class Kramdown::Converter::Toc
  def convert(el); end
end

class Kramdown::Converter::Toc
end

module Kramdown::Converter
  def self.add_math_engine(data, *args, &block); end

  def self.add_syntax_highlighter(data, *args, &block); end

  def self.configurables(); end

  def self.math_engine(data); end

  def self.syntax_highlighter(data); end
end

class Kramdown::Document
  def initialize(source, options=T.unsafe(nil)); end

  def method_missing(id, *attr, &block); end

  def options(); end

  def root(); end

  def root=(root); end

  def try_require(type, name); end

  def warnings(); end
end

class Kramdown::Element
  def attr(); end

  def block?(); end

  def children(); end

  def children=(children); end

  def initialize(type, value=T.unsafe(nil), attr=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def span?(); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  CATEGORY = ::T.let(nil, ::T.untyped)
end

class Kramdown::Element
  def self.category(el); end
end

module Kramdown::Options
  ALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Options::Boolean
  def self.===(other); end
end

class Kramdown::Options::Definition
  def default(); end

  def default=(_); end

  def desc(); end

  def desc=(_); end

  def name(); end

  def name=(_); end

  def type(); end

  def type=(_); end

  def validator(); end

  def validator=(_); end
end

class Kramdown::Options::Definition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Kramdown::Options
  def self.defaults(); end

  def self.define(name, type, default, desc, &block); end

  def self.defined?(name); end

  def self.definitions(); end

  def self.merge(hash); end

  def self.parse(name, data); end

  def self.simple_array_validator(val, name, size=T.unsafe(nil)); end

  def self.simple_hash_validator(val, name); end

  def self.str_to_sym(data); end
end

class Kramdown::Parser::Base
  def adapt_source(source); end

  def add_text(text, tree=T.unsafe(nil), type=T.unsafe(nil)); end

  def extract_string(range, strscan); end

  def initialize(source, options); end

  def options(); end

  def parse(); end

  def root(); end

  def source(); end

  def warning(text); end

  def warnings(); end
end

class Kramdown::Parser::Base
  def self.parse(source, options=T.unsafe(nil)); end
end

class Kramdown::Parser::GFM
  def generate_gfm_header_id(text); end

  def parse_atx_header_gfm_quirk(); end

  def parse_strikethrough_gfm(); end

  def update_elements(element); end
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS_GFM = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  LIST_TYPES = ::T.let(nil, ::T.untyped)
  NON_WORD_RE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END_GFM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_DELIM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_MATCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kramdown::Parser::Html::Constants
  HTML_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_COMMENT_RE = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_BLOCK = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_RAW = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_SPAN = ::T.let(nil, ::T.untyped)
  HTML_DOCTYPE_RE = ::T.let(nil, ::T.untyped)
  HTML_ELEMENT = ::T.let(nil, ::T.untyped)
  HTML_ELEMENTS_WITHOUT_BODY = ::T.let(nil, ::T.untyped)
  HTML_ENTITY_RE = ::T.let(nil, ::T.untyped)
  HTML_INSTRUCTION_RE = ::T.let(nil, ::T.untyped)
  HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_TAG_CLOSE_RE = ::T.let(nil, ::T.untyped)
  HTML_TAG_RE = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Html::ElementConverter
  def convert_a(el); end

  def convert_b(el); end

  def convert_code(el); end

  def convert_em(el); end

  def convert_h1(el); end

  def convert_h2(el); end

  def convert_h3(el); end

  def convert_h4(el); end

  def convert_h5(el); end

  def convert_h6(el); end

  def convert_i(el); end

  def convert_pre(el); end

  def convert_script(el); end

  def convert_strong(el); end

  def convert_table(el); end

  def convert_textarea(el); end

  def extract_text(el, raw); end

  def handle_math_tag(el); end

  def initialize(root); end

  def is_math_tag?(el); end

  def is_simple_table?(el); end

  def process(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil), parent=T.unsafe(nil)); end

  def process_children(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil)); end

  def process_html_element(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil)); end

  def process_text(raw, preserve=T.unsafe(nil)); end

  def remove_text_children(el); end

  def remove_whitespace_children(el); end

  def set_basics(el, type, opts=T.unsafe(nil)); end

  def strip_whitespace(el); end

  def wrap_text_children(el); end
  EMPHASIS_TYPE_MAP = ::T.let(nil, ::T.untyped)
  REMOVE_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
  REMOVE_WHITESPACE_CHILDREN = ::T.let(nil, ::T.untyped)
  SIMPLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  STRIP_WHITESPACE = ::T.let(nil, ::T.untyped)
  WRAP_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Html::ElementConverter
  def self.convert(root, el=T.unsafe(nil)); end
end

module Kramdown::Parser::Html::Parser
  def handle_html_start_tag(line=T.unsafe(nil)); end

  def handle_raw_html_tag(name); end

  def parse_html_attributes(str, line=T.unsafe(nil), in_html_tag=T.unsafe(nil)); end

  def parse_raw_html(el, &block); end
  HTML_RAW_START = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Kramdown
  def add_header(level, text, id); end

  def add_link(el, href, title, alt_text=T.unsafe(nil), ial=T.unsafe(nil)); end

  def after_block_boundary?(); end

  def before_block_boundary?(); end

  def configure_parser(); end

  def correct_abbreviations_attributes(); end

  def handle_extension(name, opts, body, type, line_no=T.unsafe(nil)); end

  def handle_kramdown_html_tag(el, closed, handle_body); end

  def new_block_el(*args); end

  def normalize_link_id(id); end

  def paragraph_end(); end

  def parse_abbrev_definition(); end

  def parse_attribute_list(str, opts); end

  def parse_atx_header(); end

  def parse_autolink(); end

  def parse_blank_line(); end

  def parse_block_extensions(); end

  def parse_block_html(); end

  def parse_block_math(); end

  def parse_blockquote(); end

  def parse_blocks(el, text=T.unsafe(nil)); end

  def parse_codeblock(); end

  def parse_codeblock_fenced(); end

  def parse_codespan(); end

  def parse_definition_list(); end

  def parse_emphasis(); end

  def parse_eob_marker(); end

  def parse_escaped_chars(); end

  def parse_extension_start_tag(type); end

  def parse_first_list_line(indentation, content); end

  def parse_footnote_definition(); end

  def parse_footnote_marker(); end

  def parse_header_contents(); end

  def parse_horizontal_rule(); end

  def parse_html_entity(); end

  def parse_inline_math(); end

  def parse_line_break(); end

  def parse_link(); end

  def parse_link_definition(); end

  def parse_list(); end

  def parse_paragraph(); end

  def parse_setext_header(); end

  def parse_smart_quotes(); end

  def parse_span_extensions(); end

  def parse_span_html(); end

  def parse_spans(el, stop_re=T.unsafe(nil), parsers=T.unsafe(nil), text_type=T.unsafe(nil)); end

  def parse_table(); end

  def parse_typographic_syms(); end

  def replace_abbreviations(el, regexps=T.unsafe(nil)); end

  def reset_env(opts=T.unsafe(nil)); end

  def restore_env(env); end

  def save_env(); end

  def span_parser_regexps(parsers=T.unsafe(nil)); end

  def update_attr_with_ial(attr, ial); end

  def update_ial_with_ial(ial, opts); end

  def update_link_definitions(link_defs); end

  def update_raw_text(item); end

  def update_tree(element); end
  ABBREV_DEFINITION_START = ::T.let(nil, ::T.untyped)
  ACHARS = ::T.let(nil, ::T.untyped)
  ALD_ANY_CHARS = ::T.let(nil, ::T.untyped)
  ALD_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_ID_CHARS = ::T.let(nil, ::T.untyped)
  ALD_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_START = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ANY = ::T.let(nil, ::T.untyped)
  ALD_TYPE_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS_MULTI = ::T.let(nil, ::T.untyped)
  ALD_TYPE_KEY_VALUE_PAIR = ::T.let(nil, ::T.untyped)
  ALD_TYPE_REF = ::T.let(nil, ::T.untyped)
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START_STR = ::T.let(nil, ::T.untyped)
  BLANK_LINE = ::T.let(nil, ::T.untyped)
  BLOCKQUOTE_START = ::T.let(nil, ::T.untyped)
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  BLOCK_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  BLOCK_MATH_START = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  CODESPAN_DELIMITER = ::T.let(nil, ::T.untyped)
  DEFINITION_LIST_START = ::T.let(nil, ::T.untyped)
  EMPHASIS_START = ::T.let(nil, ::T.untyped)
  EOB_MARKER = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_START = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_STOP_STR = ::T.let(nil, ::T.untyped)
  EXT_SPAN_START = ::T.let(nil, ::T.untyped)
  EXT_START_STR = ::T.let(nil, ::T.untyped)
  EXT_STOP_STR = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_DEFINITION_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_MARKER_START = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  HR_START = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_START = ::T.let(nil, ::T.untyped)
  HTML_MARKDOWN_ATTR_MAP = ::T.let(nil, ::T.untyped)
  HTML_SPAN_START = ::T.let(nil, ::T.untyped)
  IAL_BLOCK = ::T.let(nil, ::T.untyped)
  IAL_BLOCK_START = ::T.let(nil, ::T.untyped)
  IAL_CLASS_ATTR = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  INDENT = ::T.let(nil, ::T.untyped)
  INLINE_MATH_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_START = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_STOP = ::T.let(nil, ::T.untyped)
  LINE_BREAK = ::T.let(nil, ::T.untyped)
  LINK_BRACKET_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_DEFINITION_START = ::T.let(nil, ::T.untyped)
  LINK_INLINE_ID_RE = ::T.let(nil, ::T.untyped)
  LINK_INLINE_TITLE_RE = ::T.let(nil, ::T.untyped)
  LINK_PAREN_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_START = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL_CHECK = ::T.let(nil, ::T.untyped)
  LIST_START = ::T.let(nil, ::T.untyped)
  LIST_START_OL = ::T.let(nil, ::T.untyped)
  LIST_START_UL = ::T.let(nil, ::T.untyped)
  OPT_SPACE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
  PARAGRAPH_MATCH = ::T.let(nil, ::T.untyped)
  PARAGRAPH_START = ::T.let(nil, ::T.untyped)
  PARSE_FIRST_LIST_LINE_REGEXP_CACHE = ::T.let(nil, ::T.untyped)
  PATTERN_TAIL = ::T.let(nil, ::T.untyped)
  SETEXT_HEADER_START = ::T.let(nil, ::T.untyped)
  SMART_QUOTES_RE = ::T.let(nil, ::T.untyped)
  SPAN_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  SQ_CLOSE = ::T.let(nil, ::T.untyped)
  SQ_PUNCT = ::T.let(nil, ::T.untyped)
  SQ_RULES = ::T.let(nil, ::T.untyped)
  SQ_SUBSTS = ::T.let(nil, ::T.untyped)
  TABLE_FSEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_HSEP_ALIGN = ::T.let(nil, ::T.untyped)
  TABLE_LINE = ::T.let(nil, ::T.untyped)
  TABLE_PIPE_CHECK = ::T.let(nil, ::T.untyped)
  TABLE_ROW_LINE = ::T.let(nil, ::T.untyped)
  TABLE_SEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_START = ::T.let(nil, ::T.untyped)
  TRAILING_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_RE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_SUBST = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Kramdown::Data
  def method(); end

  def method=(_); end

  def name(); end

  def name=(_); end

  def span_start(); end

  def span_start=(_); end

  def start_re(); end

  def start_re=(_); end
end

class Kramdown::Parser::Kramdown::Data
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Kramdown::Parser::Kramdown
  def self.define_parser(name, start_re, span_start=T.unsafe(nil), meth_name=T.unsafe(nil)); end

  def self.has_parser?(name); end

  def self.parser(name=T.unsafe(nil)); end
end

class Kramdown::Parser::Markdown
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  EXTENDED = ::T.let(nil, ::T.untyped)
  IAL_RAND_CHARS = ::T.let(nil, ::T.untyped)
  IAL_RAND_STRING = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Markdown
end

module Kramdown::Utils::Configurable
  def configurable(name); end
end

module Kramdown::Utils::Entities
  ENTITY_MAP = ::T.let(nil, ::T.untyped)
  ENTITY_TABLE = ::T.let(nil, ::T.untyped)
end

module Kramdown::Utils::Entities
  def self.entity(point_or_name); end
end

module Kramdown::Utils::Html
  def entity_to_str(e, original=T.unsafe(nil)); end

  def escape_html(str, type=T.unsafe(nil)); end

  def fix_cjk_line_break(str); end

  def html_attributes(attr); end
  ESCAPE_ALL_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE_FROM_TYPE = ::T.let(nil, ::T.untyped)
  ESCAPE_TEXT_RE = ::T.let(nil, ::T.untyped)
  REDUNDANT_LINE_BREAK_REGEX = ::T.let(nil, ::T.untyped)
end

class Kramdown::Utils::LRUCache
  def [](key); end

  def []=(key, value); end

  def initialize(size); end
end

class Kramdown::Utils::LRUCache
end

class Kramdown::Utils::StringScanner
  def current_line_number(); end

  def initialize(string, start_line_number=T.unsafe(nil)); end

  def pos=(pos); end

  def revert_pos(data); end

  def save_pos(); end

  def start_line_number(); end
end

class Kramdown::Utils::StringScanner
end

module Kramdown::Utils
  def self.camelize(name); end

  def self.deep_const_get(str); end

  def self.snake_case(name); end
end

module Kramdown
  def self.data_dir(); end
end

module LanguageServer::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionKind
  EMPTY = ::T.let(nil, ::T.untyped)
  QUICK_FIX = ::T.let(nil, ::T.untyped)
  REFACTOR = ::T.let(nil, ::T.untyped)
  REFACTOR_EXTRACT = ::T.let(nil, ::T.untyped)
  REFACTOR_INLINE = ::T.let(nil, ::T.untyped)
  REFACTOR_REWRITE = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
  SOURCE_FIX_ALL = ::T.let(nil, ::T.untyped)
  SOURCE_ORGANIZE_IMPORTS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionTriggerKind
  AUTOMATIC = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemKind
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionTriggerKind
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
  TRIGGER_FOR_INCOMPLETE_COMPLETIONS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticSeverity
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
  UNNECESSARY = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentDiagnosticReportKind
  FULL = ::T.let(nil, ::T.untyped)
  UNCHANGED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentHighlightKind
  READ = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ErrorCodes
  CONTENT_MODIFIED = ::T.let(nil, ::T.untyped)
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  REQUEST_FAILED = ::T.let(nil, ::T.untyped)
  SERVER_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FailureHandlingKind
  ABORT = ::T.let(nil, ::T.untyped)
  TEXT_ONLY_TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  UNDO = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileChangeType
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileOperationPatternKind
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FoldingRangeKind
  COMMENT = ::T.let(nil, ::T.untyped)
  IMPORTS = ::T.let(nil, ::T.untyped)
  REGION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InitializeErrorCodes
  UNKNOWN_PROTOCOL_VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InlayHintKind
  PARAMETER = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextFormat
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextMode
  ADJUST_INDENTATION = ::T.let(nil, ::T.untyped)
  AS_IS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MarkupKind
  MARKDOWN = ::T.let(nil, ::T.untyped)
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MessageType
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MonikerKind
  EXPORT = ::T.let(nil, ::T.untyped)
  IMPORT = ::T.let(nil, ::T.untyped)
  LOCAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::NotebookCellKind
  CODE = ::T.let(nil, ::T.untyped)
  MARKUP = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PositionEncodingKind
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior
  IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ResourceOperationKind
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  RENAME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenModifiers
  ABSTRACT = ::T.let(nil, ::T.untyped)
  ASYNC = ::T.let(nil, ::T.untyped)
  DECLARATION = ::T.let(nil, ::T.untyped)
  DEFAULT_LIBRARY = ::T.let(nil, ::T.untyped)
  DEFINITION = ::T.let(nil, ::T.untyped)
  DEPRECATED = ::T.let(nil, ::T.untyped)
  DOCUMENTATION = ::T.let(nil, ::T.untyped)
  MODIFICATION = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  STATIC = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenTypes
  CLASS = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DECORATOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  MACRO = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PARAMETER = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SignatureHelpTriggerKind
  CONTENT_CHANGE = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolKind
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSaveReason
  AFTER_DELAY = ::T.let(nil, ::T.untyped)
  FOCUS_OUT = ::T.let(nil, ::T.untyped)
  MANUAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSyncKind
  FULL = ::T.let(nil, ::T.untyped)
  INCREMENTAL = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TokenFormat
  RELATIVE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::UniquenessLevel
  DOCUMENT = ::T.let(nil, ::T.untyped)
  GLOBAL = ::T.let(nil, ::T.untyped)
  GROUP = ::T.let(nil, ::T.untyped)
  PROJECT = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::WatchKind
  CHANGE = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
end

class LanguageServer::Protocol::Interface::AnnotatedTextEdit
  def annotation_id(); end

  def attributes(); end

  def initialize(range:, new_text:, annotation_id:); end

  def new_text(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditParams
  def attributes(); end

  def edit(); end

  def initialize(edit:, label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditResult
  def applied(); end

  def attributes(); end

  def failed_change(); end

  def failure_reason(); end

  def initialize(applied:, failure_reason: T.unsafe(nil), failed_change: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCall
  def attributes(); end

  def from(); end

  def from_ranges(); end

  def initialize(from:, from_ranges:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCallsParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyItem
  def attributes(); end

  def data(); end

  def detail(); end

  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCall
  def attributes(); end

  def from_ranges(); end

  def initialize(to:, from_ranges:); end

  def to(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCallsParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyPrepareParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CancelParams
  def attributes(); end

  def id(); end

  def initialize(id:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ChangeAnnotation
  def attributes(); end

  def description(); end

  def initialize(label:, needs_confirmation: T.unsafe(nil), description: T.unsafe(nil)); end

  def label(); end

  def needs_confirmation(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ClientCapabilities
  def attributes(); end

  def experimental(); end

  def general(); end

  def initialize(workspace: T.unsafe(nil), text_document: T.unsafe(nil), notebook_document: T.unsafe(nil), window: T.unsafe(nil), general: T.unsafe(nil), experimental: T.unsafe(nil)); end

  def notebook_document(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def window(); end

  def workspace(); end
end

class LanguageServer::Protocol::Interface::CodeAction
  def attributes(); end

  def command(); end

  def data(); end

  def diagnostics(); end

  def disabled(); end

  def edit(); end

  def initialize(title:, kind: T.unsafe(nil), diagnostics: T.unsafe(nil), is_preferred: T.unsafe(nil), disabled: T.unsafe(nil), edit: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  def is_preferred(); end

  def kind(); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeActionClientCapabilities
  def attributes(); end

  def code_action_literal_support(); end

  def data_support(); end

  def disabled_support(); end

  def dynamic_registration(); end

  def honors_change_annotations(); end

  def initialize(dynamic_registration: T.unsafe(nil), code_action_literal_support: T.unsafe(nil), is_preferred_support: T.unsafe(nil), disabled_support: T.unsafe(nil), data_support: T.unsafe(nil), resolve_support: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  def is_preferred_support(); end

  def resolve_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeActionContext
  def attributes(); end

  def diagnostics(); end

  def initialize(diagnostics:, only: T.unsafe(nil), trigger_kind: T.unsafe(nil)); end

  def only(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::CodeActionOptions
  def attributes(); end

  def code_action_kinds(); end

  def initialize(work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeActionParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CodeActionRegistrationOptions
  def attributes(); end

  def code_action_kinds(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeDescription
  def attributes(); end

  def href(); end

  def initialize(href:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLens
  def attributes(); end

  def command(); end

  def data(); end

  def initialize(range:, command: T.unsafe(nil), data: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeLensParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CodeLensRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeLensWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Color
  def alpha(); end

  def attributes(); end

  def blue(); end

  def green(); end

  def initialize(red:, green:, blue:, alpha:); end

  def red(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorInformation
  def attributes(); end

  def color(); end

  def initialize(range:, color:); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorPresentation
  def additional_text_edits(); end

  def attributes(); end

  def initialize(label:, text_edit: T.unsafe(nil), additional_text_edits: T.unsafe(nil)); end

  def label(); end

  def text_edit(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorPresentationParams
  def attributes(); end

  def color(); end

  def initialize(text_document:, color:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::Command
  def arguments(); end

  def attributes(); end

  def command(); end

  def initialize(title:, command:, arguments: T.unsafe(nil)); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionClientCapabilities
  def attributes(); end

  def completion_item(); end

  def completion_item_kind(); end

  def completion_list(); end

  def context_support(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), completion_item: T.unsafe(nil), completion_item_kind: T.unsafe(nil), context_support: T.unsafe(nil), insert_text_mode: T.unsafe(nil), completion_list: T.unsafe(nil)); end

  def insert_text_mode(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionContext
  def attributes(); end

  def initialize(trigger_kind:, trigger_character: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_character(); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::CompletionItem
  def additional_text_edits(); end

  def attributes(); end

  def command(); end

  def commit_characters(); end

  def data(); end

  def deprecated(); end

  def detail(); end

  def documentation(); end

  def filter_text(); end

  def initialize(label:, label_details: T.unsafe(nil), kind: T.unsafe(nil), tags: T.unsafe(nil), detail: T.unsafe(nil), documentation: T.unsafe(nil), deprecated: T.unsafe(nil), preselect: T.unsafe(nil), sort_text: T.unsafe(nil), filter_text: T.unsafe(nil), insert_text: T.unsafe(nil), insert_text_format: T.unsafe(nil), insert_text_mode: T.unsafe(nil), text_edit: T.unsafe(nil), text_edit_text: T.unsafe(nil), additional_text_edits: T.unsafe(nil), commit_characters: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  def insert_text(); end

  def insert_text_format(); end

  def insert_text_mode(); end

  def kind(); end

  def label(); end

  def label_details(); end

  def preselect(); end

  def sort_text(); end

  def tags(); end

  def text_edit(); end

  def text_edit_text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionItemLabelDetails
  def attributes(); end

  def description(); end

  def detail(); end

  def initialize(detail: T.unsafe(nil), description: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionList
  def attributes(); end

  def initialize(is_incomplete:, items:, item_defaults: T.unsafe(nil)); end

  def is_incomplete(); end

  def item_defaults(); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionOptions
  def all_commit_characters(); end

  def attributes(); end

  def completion_item(); end

  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil), completion_item: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CompletionParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), context: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CompletionRegistrationOptions
  def all_commit_characters(); end

  def attributes(); end

  def completion_item(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil), completion_item: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ConfigurationItem
  def attributes(); end

  def initialize(scope_uri: T.unsafe(nil), section: T.unsafe(nil)); end

  def scope_uri(); end

  def section(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ConfigurationParams
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CreateFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::CreateFileOptions
  def attributes(); end

  def ignore_if_exists(); end

  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  def overwrite(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CreateFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeclarationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeclarationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DeclarationParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DeclarationRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DefinitionClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DefinitionOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DefinitionParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DefinitionRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DeleteFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::DeleteFileOptions
  def attributes(); end

  def ignore_if_not_exists(); end

  def initialize(recursive: T.unsafe(nil), ignore_if_not_exists: T.unsafe(nil)); end

  def recursive(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeleteFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Diagnostic
  def attributes(); end

  def code(); end

  def code_description(); end

  def data(); end

  def initialize(range:, message:, severity: T.unsafe(nil), code: T.unsafe(nil), code_description: T.unsafe(nil), source: T.unsafe(nil), tags: T.unsafe(nil), related_information: T.unsafe(nil), data: T.unsafe(nil)); end

  def message(); end

  def range(); end

  def related_information(); end

  def severity(); end

  def source(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), related_document_support: T.unsafe(nil)); end

  def related_document_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticOptions
  def attributes(); end

  def identifier(); end

  def initialize(inter_file_dependencies:, workspace_diagnostics:, work_done_progress: T.unsafe(nil), identifier: T.unsafe(nil)); end

  def inter_file_dependencies(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end

  def workspace_diagnostics(); end
end

class LanguageServer::Protocol::Interface::DiagnosticRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def identifier(); end

  def initialize(document_selector:, inter_file_dependencies:, workspace_diagnostics:, work_done_progress: T.unsafe(nil), identifier: T.unsafe(nil), id: T.unsafe(nil)); end

  def inter_file_dependencies(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end

  def workspace_diagnostics(); end
end

class LanguageServer::Protocol::Interface::DiagnosticRelatedInformation
  def attributes(); end

  def initialize(location:, message:); end

  def location(); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticServerCancellationData
  def attributes(); end

  def initialize(retrigger_request:); end

  def retrigger_request(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationParams
  def attributes(); end

  def initialize(settings:); end

  def settings(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeNotebookDocumentParams
  def attributes(); end

  def change(); end

  def initialize(notebook_document:, change:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeTextDocumentParams
  def attributes(); end

  def content_changes(); end

  def initialize(text_document:, content_changes:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), relative_pattern_support: T.unsafe(nil)); end

  def relative_pattern_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesParams
  def attributes(); end

  def changes(); end

  def initialize(changes:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesRegistrationOptions
  def attributes(); end

  def initialize(watchers:); end

  def to_hash(); end

  def to_json(*args); end

  def watchers(); end
end

class LanguageServer::Protocol::Interface::DidChangeWorkspaceFoldersParams
  def attributes(); end

  def event(); end

  def initialize(event:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseNotebookDocumentParams
  def attributes(); end

  def cell_text_documents(); end

  def initialize(notebook_document:, cell_text_documents:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseTextDocumentParams
  def attributes(); end

  def initialize(text_document:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenNotebookDocumentParams
  def attributes(); end

  def cell_text_documents(); end

  def initialize(notebook_document:, cell_text_documents:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenTextDocumentParams
  def attributes(); end

  def initialize(text_document:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveNotebookDocumentParams
  def attributes(); end

  def initialize(notebook_document:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveTextDocumentParams
  def attributes(); end

  def initialize(text_document:, text: T.unsafe(nil)); end

  def text(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentColorClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentColorOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentColorParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentColorRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, id: T.unsafe(nil), work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticParams
  def attributes(); end

  def identifier(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), identifier: T.unsafe(nil), previous_result_id: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_id(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticReportPartialResult
  def attributes(); end

  def initialize(related_documents:); end

  def related_documents(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFilter
  def attributes(); end

  def initialize(language: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  def language(); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingParams
  def attributes(); end

  def initialize(text_document:, options:, work_done_token: T.unsafe(nil)); end

  def options(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlight
  def attributes(); end

  def initialize(range:, kind: T.unsafe(nil)); end

  def kind(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentLink
  def attributes(); end

  def data(); end

  def initialize(range:, target: T.unsafe(nil), tooltip: T.unsafe(nil), data: T.unsafe(nil)); end

  def range(); end

  def target(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), tooltip_support: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip_support(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingOptions
  def attributes(); end

  def first_trigger_character(); end

  def initialize(first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  def more_trigger_character(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingParams
  def attributes(); end

  def ch(); end

  def initialize(text_document:, position:, ch:, options:); end

  def options(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def first_trigger_character(); end

  def initialize(document_selector:, first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  def more_trigger_character(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingParams
  def attributes(); end

  def initialize(text_document:, range:, options:, work_done_token: T.unsafe(nil)); end

  def options(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbol
  def attributes(); end

  def children(); end

  def deprecated(); end

  def detail(); end

  def initialize(name:, kind:, range:, selection_range:, detail: T.unsafe(nil), tags: T.unsafe(nil), deprecated: T.unsafe(nil), children: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def hierarchical_document_symbol_support(); end

  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), hierarchical_document_symbol_support: T.unsafe(nil), tag_support: T.unsafe(nil), label_support: T.unsafe(nil)); end

  def label_support(); end

  def symbol_kind(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandOptions
  def attributes(); end

  def commands(); end

  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandParams
  def arguments(); end

  def attributes(); end

  def command(); end

  def initialize(command:, work_done_token: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandRegistrationOptions
  def attributes(); end

  def commands(); end

  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecutionSummary
  def attributes(); end

  def execution_order(); end

  def initialize(execution_order:, success: T.unsafe(nil)); end

  def success(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileCreate
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileDelete
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileEvent
  def attributes(); end

  def initialize(uri:, type:); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileOperationFilter
  def attributes(); end

  def initialize(pattern:, scheme: T.unsafe(nil)); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationPattern
  def attributes(); end

  def glob(); end

  def initialize(glob:, matches: T.unsafe(nil), options: T.unsafe(nil)); end

  def matches(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationPatternOptions
  def attributes(); end

  def ignore_case(); end

  def initialize(ignore_case: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationRegistrationOptions
  def attributes(); end

  def filters(); end

  def initialize(filters:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileRename
  def attributes(); end

  def initialize(old_uri:, new_uri:); end

  def new_uri(); end

  def old_uri(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileSystemWatcher
  def attributes(); end

  def glob_pattern(); end

  def initialize(glob_pattern:, kind: T.unsafe(nil)); end

  def kind(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRange
  def attributes(); end

  def collapsed_text(); end

  def end_character(); end

  def end_line(); end

  def initialize(start_line:, end_line:, start_character: T.unsafe(nil), end_character: T.unsafe(nil), kind: T.unsafe(nil), collapsed_text: T.unsafe(nil)); end

  def kind(); end

  def start_character(); end

  def start_line(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def folding_range(); end

  def folding_range_kind(); end

  def initialize(dynamic_registration: T.unsafe(nil), range_limit: T.unsafe(nil), line_folding_only: T.unsafe(nil), folding_range_kind: T.unsafe(nil), folding_range: T.unsafe(nil)); end

  def line_folding_only(); end

  def range_limit(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::FormattingOptions
  def attributes(); end

  def initialize(tab_size:, insert_spaces:, trim_trailing_whitespace: T.unsafe(nil), insert_final_newline: T.unsafe(nil), trim_final_newlines: T.unsafe(nil)); end

  def insert_final_newline(); end

  def insert_spaces(); end

  def tab_size(); end

  def to_hash(); end

  def to_json(*args); end

  def trim_final_newlines(); end

  def trim_trailing_whitespace(); end
end

class LanguageServer::Protocol::Interface::FullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, result_id: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Hover
  def attributes(); end

  def contents(); end

  def initialize(contents:, range: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::HoverClientCapabilities
  def attributes(); end

  def content_format(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), content_format: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::HoverOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::HoverParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::HoverRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::HoverResult
  def attributes(); end

  def initialize(value:); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::ImplementationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ImplementationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ImplementationParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ImplementationRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InitializeError
  def attributes(); end

  def initialize(retry:); end

  def retry(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializeParams
  def attributes(); end

  def capabilities(); end

  def client_info(); end

  def initialization_options(); end

  def initialize(process_id:, root_uri:, capabilities:, work_done_token: T.unsafe(nil), client_info: T.unsafe(nil), locale: T.unsafe(nil), root_path: T.unsafe(nil), initialization_options: T.unsafe(nil), trace: T.unsafe(nil), workspace_folders: T.unsafe(nil)); end

  def locale(); end

  def process_id(); end

  def root_path(); end

  def root_uri(); end

  def to_hash(); end

  def to_json(*args); end

  def trace(); end

  def work_done_token(); end

  def workspace_folders(); end
end

class LanguageServer::Protocol::Interface::InitializeResult
  def attributes(); end

  def capabilities(); end

  def initialize(capabilities:, server_info: T.unsafe(nil)); end

  def server_info(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializedParams
  def attributes(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlayHint
  def attributes(); end

  def data(); end

  def initialize(position:, label:, kind: T.unsafe(nil), text_edits: T.unsafe(nil), tooltip: T.unsafe(nil), padding_left: T.unsafe(nil), padding_right: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def label(); end

  def padding_left(); end

  def padding_right(); end

  def position(); end

  def text_edits(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end
end

class LanguageServer::Protocol::Interface::InlayHintClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), resolve_support: T.unsafe(nil)); end

  def resolve_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlayHintLabelPart
  def attributes(); end

  def command(); end

  def initialize(value:, tooltip: T.unsafe(nil), location: T.unsafe(nil), command: T.unsafe(nil)); end

  def location(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::InlayHintOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlayHintParams
  def attributes(); end

  def initialize(text_document:, range:, work_done_token: T.unsafe(nil)); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::InlayHintRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil), id: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlayHintWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueContext
  def attributes(); end

  def frame_id(); end

  def initialize(frame_id:, stopped_location:); end

  def stopped_location(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueEvaluatableExpression
  def attributes(); end

  def expression(); end

  def initialize(range:, expression: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlineValueParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil)); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::InlineValueRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlineValueText
  def attributes(); end

  def initialize(range:, text:); end

  def range(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueVariableLookup
  def attributes(); end

  def case_sensitive_lookup(); end

  def initialize(range:, case_sensitive_lookup:, variable_name: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def variable_name(); end
end

class LanguageServer::Protocol::Interface::InlineValueWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InsertReplaceEdit
  def attributes(); end

  def initialize(new_text:, insert:, replace:); end

  def insert(); end

  def new_text(); end

  def replace(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRanges
  def attributes(); end

  def initialize(ranges:, word_pattern: T.unsafe(nil)); end

  def ranges(); end

  def to_hash(); end

  def to_json(*args); end

  def word_pattern(); end
end

class LanguageServer::Protocol::Interface::Location
  def attributes(); end

  def initialize(uri:, range:); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::LocationLink
  def attributes(); end

  def initialize(target_uri:, target_range:, target_selection_range:, origin_selection_range: T.unsafe(nil)); end

  def origin_selection_range(); end

  def target_range(); end

  def target_selection_range(); end

  def target_uri(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LogMessageParams
  def attributes(); end

  def initialize(type:, message:); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::LogTraceParams
  def attributes(); end

  def initialize(message:, verbose: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def verbose(); end
end

class LanguageServer::Protocol::Interface::MarkupContent
  def attributes(); end

  def initialize(kind:, value:); end

  def kind(); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::Message
  def attributes(); end

  def initialize(jsonrpc:); end

  def jsonrpc(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MessageActionItem
  def attributes(); end

  def initialize(title:); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Moniker
  def attributes(); end

  def identifier(); end

  def initialize(scheme:, identifier:, unique:, kind: T.unsafe(nil)); end

  def kind(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end

  def unique(); end
end

class LanguageServer::Protocol::Interface::MonikerClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MonikerOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::MonikerParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::MonikerRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::NotebookCell
  def attributes(); end

  def document(); end

  def execution_summary(); end

  def initialize(kind:, document:, metadata: T.unsafe(nil), execution_summary: T.unsafe(nil)); end

  def kind(); end

  def metadata(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCellArrayChange
  def attributes(); end

  def cells(); end

  def delete_count(); end

  def initialize(start:, delete_count:, cells: T.unsafe(nil)); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCellTextDocumentFilter
  def attributes(); end

  def initialize(notebook:, language: T.unsafe(nil)); end

  def language(); end

  def notebook(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocument
  def attributes(); end

  def cells(); end

  def initialize(uri:, notebook_type:, version:, cells:, metadata: T.unsafe(nil)); end

  def metadata(); end

  def notebook_type(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentChangeEvent
  def attributes(); end

  def cells(); end

  def initialize(metadata: T.unsafe(nil), cells: T.unsafe(nil)); end

  def metadata(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentClientCapabilities
  def attributes(); end

  def initialize(synchronization:); end

  def synchronization(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentFilter
  def attributes(); end

  def initialize(notebook_type: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  def notebook_type(); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentIdentifier
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def execution_summary_support(); end

  def initialize(dynamic_registration: T.unsafe(nil), execution_summary_support: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncOptions
  def attributes(); end

  def initialize(notebook_selector:, save: T.unsafe(nil)); end

  def notebook_selector(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncRegistrationOptions
  def attributes(); end

  def id(); end

  def initialize(notebook_selector:, save: T.unsafe(nil), id: T.unsafe(nil)); end

  def notebook_selector(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotificationMessage
  def attributes(); end

  def initialize(jsonrpc:, method:, params: T.unsafe(nil)); end

  def jsonrpc(); end

  def method(); end

  def params(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier
  def attributes(); end

  def initialize(uri:, version:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::ParameterInformation
  def attributes(); end

  def documentation(); end

  def initialize(label:, documentation: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::PartialResultParams
  def attributes(); end

  def initialize(partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Position
  def attributes(); end

  def character(); end

  def initialize(line:, character:); end

  def line(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::PrepareRenameParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::PreviousResultId
  def attributes(); end

  def initialize(uri:, value:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::ProgressParams
  def attributes(); end

  def initialize(token:, value:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsClientCapabilities
  def attributes(); end

  def code_description_support(); end

  def data_support(); end

  def initialize(related_information: T.unsafe(nil), tag_support: T.unsafe(nil), version_support: T.unsafe(nil), code_description_support: T.unsafe(nil), data_support: T.unsafe(nil)); end

  def related_information(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end

  def version_support(); end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsParams
  def attributes(); end

  def diagnostics(); end

  def initialize(uri:, diagnostics:, version: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::Range
  def attributes(); end

  def end(); end

  def initialize(start:, end:); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceContext
  def attributes(); end

  def include_declaration(); end

  def initialize(include_declaration:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ReferenceParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ReferenceRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::Registration
  def attributes(); end

  def id(); end

  def initialize(id:, method:, register_options: T.unsafe(nil)); end

  def method(); end

  def register_options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RegistrationParams
  def attributes(); end

  def initialize(registrations:); end

  def registrations(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RegularExpressionsClientCapabilities
  def attributes(); end

  def engine(); end

  def initialize(engine:, version: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def version(); end
end

class LanguageServer::Protocol::Interface::RelatedFullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, result_id: T.unsafe(nil), related_documents: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def related_documents(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelatedUnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:, related_documents: T.unsafe(nil)); end

  def kind(); end

  def related_documents(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelativePattern
  def attributes(); end

  def base_uri(); end

  def initialize(base_uri:, pattern:); end

  def pattern(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def honors_change_annotations(); end

  def initialize(dynamic_registration: T.unsafe(nil), prepare_support: T.unsafe(nil), prepare_support_default_behavior: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  def prepare_support(); end

  def prepare_support_default_behavior(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, old_uri:, new_uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def new_uri(); end

  def old_uri(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFileOptions
  def attributes(); end

  def ignore_if_exists(); end

  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  def overwrite(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  def prepare_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::RenameParams
  def attributes(); end

  def initialize(text_document:, position:, new_name:, work_done_token: T.unsafe(nil)); end

  def new_name(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::RenameRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  def prepare_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::RequestMessage
  def attributes(); end

  def id(); end

  def initialize(jsonrpc:, id:, method:, params: T.unsafe(nil)); end

  def jsonrpc(); end

  def method(); end

  def params(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseError
  def attributes(); end

  def code(); end

  def data(); end

  def initialize(code:, message:, data: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseMessage
  def attributes(); end

  def error(); end

  def id(); end

  def initialize(jsonrpc:, id:, result: T.unsafe(nil), error: T.unsafe(nil)); end

  def jsonrpc(); end

  def result(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SaveOptions
  def attributes(); end

  def include_text(); end

  def initialize(include_text: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRange
  def attributes(); end

  def initialize(range:, parent: T.unsafe(nil)); end

  def parent(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeParams
  def attributes(); end

  def initialize(text_document:, positions:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def positions(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokens
  def attributes(); end

  def data(); end

  def initialize(data:, result_id: T.unsafe(nil)); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensClientCapabilities
  def attributes(); end

  def augments_syntax_tokens(); end

  def dynamic_registration(); end

  def formats(); end

  def initialize(requests:, token_types:, token_modifiers:, formats:, dynamic_registration: T.unsafe(nil), overlapping_token_support: T.unsafe(nil), multiline_token_support: T.unsafe(nil), server_cancel_support: T.unsafe(nil), augments_syntax_tokens: T.unsafe(nil)); end

  def multiline_token_support(); end

  def overlapping_token_support(); end

  def requests(); end

  def server_cancel_support(); end

  def to_hash(); end

  def to_json(*args); end

  def token_modifiers(); end

  def token_types(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDelta
  def attributes(); end

  def edits(); end

  def initialize(edits:, result_id: T.unsafe(nil)); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaParams
  def attributes(); end

  def initialize(text_document:, previous_result_id:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_id(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaPartialResult
  def attributes(); end

  def edits(); end

  def initialize(edits:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensEdit
  def attributes(); end

  def data(); end

  def delete_count(); end

  def initialize(start:, delete_count:, data: T.unsafe(nil)); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensLegend
  def attributes(); end

  def initialize(token_types:, token_modifiers:); end

  def to_hash(); end

  def to_json(*args); end

  def token_modifiers(); end

  def token_types(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensOptions
  def attributes(); end

  def full(); end

  def initialize(legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil)); end

  def legend(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensPartialResult
  def attributes(); end

  def data(); end

  def initialize(data:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRangeParams
  def attributes(); end

  def initialize(text_document:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def full(); end

  def id(); end

  def initialize(document_selector:, legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil), id: T.unsafe(nil)); end

  def legend(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ServerCapabilities
  def attributes(); end

  def call_hierarchy_provider(); end

  def code_action_provider(); end

  def code_lens_provider(); end

  def color_provider(); end

  def completion_provider(); end

  def declaration_provider(); end

  def definition_provider(); end

  def diagnostic_provider(); end

  def document_formatting_provider(); end

  def document_highlight_provider(); end

  def document_link_provider(); end

  def document_on_type_formatting_provider(); end

  def document_range_formatting_provider(); end

  def document_symbol_provider(); end

  def execute_command_provider(); end

  def experimental(); end

  def folding_range_provider(); end

  def hover_provider(); end

  def implementation_provider(); end

  def initialize(position_encoding: T.unsafe(nil), text_document_sync: T.unsafe(nil), notebook_document_sync: T.unsafe(nil), completion_provider: T.unsafe(nil), hover_provider: T.unsafe(nil), signature_help_provider: T.unsafe(nil), declaration_provider: T.unsafe(nil), definition_provider: T.unsafe(nil), type_definition_provider: T.unsafe(nil), implementation_provider: T.unsafe(nil), references_provider: T.unsafe(nil), document_highlight_provider: T.unsafe(nil), document_symbol_provider: T.unsafe(nil), code_action_provider: T.unsafe(nil), code_lens_provider: T.unsafe(nil), document_link_provider: T.unsafe(nil), color_provider: T.unsafe(nil), document_formatting_provider: T.unsafe(nil), document_range_formatting_provider: T.unsafe(nil), document_on_type_formatting_provider: T.unsafe(nil), rename_provider: T.unsafe(nil), folding_range_provider: T.unsafe(nil), execute_command_provider: T.unsafe(nil), selection_range_provider: T.unsafe(nil), linked_editing_range_provider: T.unsafe(nil), call_hierarchy_provider: T.unsafe(nil), semantic_tokens_provider: T.unsafe(nil), moniker_provider: T.unsafe(nil), type_hierarchy_provider: T.unsafe(nil), inline_value_provider: T.unsafe(nil), inlay_hint_provider: T.unsafe(nil), diagnostic_provider: T.unsafe(nil), workspace_symbol_provider: T.unsafe(nil), workspace: T.unsafe(nil), experimental: T.unsafe(nil)); end

  def inlay_hint_provider(); end

  def inline_value_provider(); end

  def linked_editing_range_provider(); end

  def moniker_provider(); end

  def notebook_document_sync(); end

  def position_encoding(); end

  def references_provider(); end

  def rename_provider(); end

  def selection_range_provider(); end

  def semantic_tokens_provider(); end

  def signature_help_provider(); end

  def text_document_sync(); end

  def to_hash(); end

  def to_json(*args); end

  def type_definition_provider(); end

  def type_hierarchy_provider(); end

  def workspace(); end

  def workspace_symbol_provider(); end
end

class LanguageServer::Protocol::Interface::SetTraceParams
  def attributes(); end

  def initialize(value:); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::ShowDocumentClientCapabilities
  def attributes(); end

  def initialize(support:); end

  def support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowDocumentParams
  def attributes(); end

  def external(); end

  def initialize(uri:, external: T.unsafe(nil), take_focus: T.unsafe(nil), selection: T.unsafe(nil)); end

  def selection(); end

  def take_focus(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::ShowDocumentResult
  def attributes(); end

  def initialize(success:); end

  def success(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowMessageParams
  def attributes(); end

  def initialize(type:, message:); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestClientCapabilities
  def attributes(); end

  def initialize(message_action_item: T.unsafe(nil)); end

  def message_action_item(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestParams
  def actions(); end

  def attributes(); end

  def initialize(type:, message:, actions: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::SignatureHelp
  def active_parameter(); end

  def active_signature(); end

  def attributes(); end

  def initialize(signatures:, active_signature: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  def signatures(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelpClientCapabilities
  def attributes(); end

  def context_support(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), signature_information: T.unsafe(nil), context_support: T.unsafe(nil)); end

  def signature_information(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelpContext
  def active_signature_help(); end

  def attributes(); end

  def initialize(trigger_kind:, is_retrigger:, trigger_character: T.unsafe(nil), active_signature_help: T.unsafe(nil)); end

  def is_retrigger(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_character(); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  def retrigger_characters(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), context: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  def retrigger_characters(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SignatureInformation
  def active_parameter(); end

  def attributes(); end

  def documentation(); end

  def initialize(label:, documentation: T.unsafe(nil), parameters: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  def label(); end

  def parameters(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::StaticRegistrationOptions
  def attributes(); end

  def id(); end

  def initialize(id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SymbolInformation
  def attributes(); end

  def container_name(); end

  def deprecated(); end

  def initialize(name:, kind:, location:, tags: T.unsafe(nil), deprecated: T.unsafe(nil), container_name: T.unsafe(nil)); end

  def kind(); end

  def location(); end

  def name(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentChangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, sync_kind:); end

  def sync_kind(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentClientCapabilities
  def attributes(); end

  def call_hierarchy(); end

  def code_action(); end

  def code_lens(); end

  def color_provider(); end

  def completion(); end

  def declaration(); end

  def definition(); end

  def diagnostic(); end

  def document_highlight(); end

  def document_link(); end

  def document_symbol(); end

  def folding_range(); end

  def formatting(); end

  def hover(); end

  def implementation(); end

  def initialize(synchronization: T.unsafe(nil), completion: T.unsafe(nil), hover: T.unsafe(nil), signature_help: T.unsafe(nil), declaration: T.unsafe(nil), definition: T.unsafe(nil), type_definition: T.unsafe(nil), implementation: T.unsafe(nil), references: T.unsafe(nil), document_highlight: T.unsafe(nil), document_symbol: T.unsafe(nil), code_action: T.unsafe(nil), code_lens: T.unsafe(nil), document_link: T.unsafe(nil), color_provider: T.unsafe(nil), formatting: T.unsafe(nil), range_formatting: T.unsafe(nil), on_type_formatting: T.unsafe(nil), rename: T.unsafe(nil), publish_diagnostics: T.unsafe(nil), folding_range: T.unsafe(nil), selection_range: T.unsafe(nil), linked_editing_range: T.unsafe(nil), call_hierarchy: T.unsafe(nil), semantic_tokens: T.unsafe(nil), moniker: T.unsafe(nil), type_hierarchy: T.unsafe(nil), inline_value: T.unsafe(nil), inlay_hint: T.unsafe(nil), diagnostic: T.unsafe(nil)); end

  def inlay_hint(); end

  def inline_value(); end

  def linked_editing_range(); end

  def moniker(); end

  def on_type_formatting(); end

  def publish_diagnostics(); end

  def range_formatting(); end

  def references(); end

  def rename(); end

  def selection_range(); end

  def semantic_tokens(); end

  def signature_help(); end

  def synchronization(); end

  def to_hash(); end

  def to_json(*args); end

  def type_definition(); end

  def type_hierarchy(); end
end

class LanguageServer::Protocol::Interface::TextDocumentContentChangeEvent
  def attributes(); end

  def initialize(text:, range: T.unsafe(nil), range_length: T.unsafe(nil)); end

  def range(); end

  def range_length(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentEdit
  def attributes(); end

  def edits(); end

  def initialize(text_document:, edits:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentIdentifier
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::TextDocumentItem
  def attributes(); end

  def initialize(uri:, language_id:, version:, text:); end

  def language_id(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::TextDocumentPositionParams
  def attributes(); end

  def initialize(text_document:, position:); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentSaveRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def include_text(); end

  def initialize(document_selector:, include_text: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncClientCapabilities
  def attributes(); end

  def did_save(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), did_save: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def will_save(); end

  def will_save_wait_until(); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncOptions
  def attributes(); end

  def change(); end

  def initialize(open_close: T.unsafe(nil), change: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), save: T.unsafe(nil)); end

  def open_close(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end

  def will_save(); end

  def will_save_wait_until(); end
end

class LanguageServer::Protocol::Interface::TextEdit
  def attributes(); end

  def initialize(range:, new_text:); end

  def new_text(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyItem
  def attributes(); end

  def data(); end

  def detail(); end

  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyPrepareParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchySubtypesParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchySupertypesParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::UnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Unregistration
  def attributes(); end

  def id(); end

  def initialize(id:, method:); end

  def method(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::UnregistrationParams
  def attributes(); end

  def initialize(unregisterations:); end

  def to_hash(); end

  def to_json(*args); end

  def unregisterations(); end
end

class LanguageServer::Protocol::Interface::VersionedNotebookDocumentIdentifier
  def attributes(); end

  def initialize(version:, uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::VersionedTextDocumentIdentifier
  def attributes(); end

  def initialize(uri:, version:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::WillSaveTextDocumentParams
  def attributes(); end

  def initialize(text_document:, reason:); end

  def reason(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressBegin
  def attributes(); end

  def cancellable(); end

  def initialize(kind:, title:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def percentage(); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCancelParams
  def attributes(); end

  def initialize(token:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCreateParams
  def attributes(); end

  def initialize(token:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressEnd
  def attributes(); end

  def initialize(kind:, message: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressParams
  def attributes(); end

  def initialize(work_done_token: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressReport
  def attributes(); end

  def cancellable(); end

  def initialize(kind:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def percentage(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticParams
  def attributes(); end

  def identifier(); end

  def initialize(previous_result_ids:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), identifier: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_ids(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReport
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReportPartialResult
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEdit
  def attributes(); end

  def change_annotations(); end

  def changes(); end

  def document_changes(); end

  def initialize(changes: T.unsafe(nil), document_changes: T.unsafe(nil), change_annotations: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEditClientCapabilities
  def attributes(); end

  def change_annotation_support(); end

  def document_changes(); end

  def failure_handling(); end

  def initialize(document_changes: T.unsafe(nil), resource_operations: T.unsafe(nil), failure_handling: T.unsafe(nil), normalizes_line_endings: T.unsafe(nil), change_annotation_support: T.unsafe(nil)); end

  def normalizes_line_endings(); end

  def resource_operations(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFolder
  def attributes(); end

  def initialize(uri:, name:); end

  def name(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersChangeEvent
  def added(); end

  def attributes(); end

  def initialize(added:, removed:); end

  def removed(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersServerCapabilities
  def attributes(); end

  def change_notifications(); end

  def initialize(supported: T.unsafe(nil), change_notifications: T.unsafe(nil)); end

  def supported(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, uri:, version:, result_id: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbol
  def attributes(); end

  def container_name(); end

  def data(); end

  def initialize(name:, kind:, location:, tags: T.unsafe(nil), container_name: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def location(); end

  def name(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), tag_support: T.unsafe(nil), resolve_support: T.unsafe(nil)); end

  def resolve_support(); end

  def symbol_kind(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolParams
  def attributes(); end

  def initialize(query:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def query(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolRegistrationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkspaceUnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:, uri:, version:); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Transport::Io::Reader
  def initialize(io); end

  def read(&block); end
end

class LanguageServer::Protocol::Transport::Io::Writer
  def initialize(io); end

  def io(); end

  def write(response); end
end

class LanguageServer::Protocol::Transport::Stdio::Reader
  def initialize(); end
end

class LanguageServer::Protocol::Transport::Stdio::Writer
  def initialize(); end
end

module Launchy
  VERSION = ::T.let(nil, ::T.untyped)
end

class Launchy::Application
  def find_executable(bin, *paths); end

  def host_os_family(); end

  def ruby_engine(); end

  def run(cmd, *args); end

  def runner(); end
end

class Launchy::Application::Browser
  def app_list(); end

  def browser_cmdline(); end

  def browser_env(); end

  def cmd_and_args(uri, options=T.unsafe(nil)); end

  def cygwin_app_list(); end

  def darwin_app_list(); end

  def nix_app_list(); end

  def open(uri, options=T.unsafe(nil)); end

  def windows_app_list(); end
end

class Launchy::Application::Browser
  def self.handles?(uri); end

  def self.schemes(); end
end

class Launchy::Application
  def self.find_executable(bin, *paths); end

  def self.handling(uri); end
end

class Launchy::Argv
  def ==(other); end

  def [](idx); end

  def argv(); end

  def executable?(); end

  def initialize(*args); end

  def to_str(); end

  def valid?(); end
end

class Launchy::Browser
  def visit(url); end
end

class Launchy::Browser
  def self.run(*args); end
end

class Launchy::Cli
  def error_output(error); end

  def good_run(argv, env); end

  def options(); end

  def parse(argv, env); end

  def parser(); end

  def run(argv=T.unsafe(nil), env=T.unsafe(nil)); end
end

module Launchy::DescendantTracker
  def children(); end

  def find_child(method, *args); end

  def inherited(klass); end
end

class Launchy::Detect::HostOs
  def default_host_os(); end

  def host_os(); end

  def initialize(host_os=T.unsafe(nil)); end

  def override_host_os(); end

  def to_str(); end
end

class Launchy::Detect::HostOsFamily
  def cygwin?(); end

  def darwin?(); end

  def host_os(); end

  def initialize(host_os=T.unsafe(nil)); end

  def nix?(); end

  def windows?(); end
end

class Launchy::Detect::HostOsFamily::Cygwin
  def app_list(app); end
end

class Launchy::Detect::HostOsFamily::Cygwin
  def self.matching_regex(); end
end

class Launchy::Detect::HostOsFamily::Darwin
  def app_list(app); end
end

class Launchy::Detect::HostOsFamily::Darwin
  def self.matching_regex(); end
end

class Launchy::Detect::HostOsFamily::Nix
  def app_list(app); end
end

class Launchy::Detect::HostOsFamily::Nix
  def self.matching_regex(); end
end

class Launchy::Detect::HostOsFamily::Windows
  def app_list(app); end
end

class Launchy::Detect::HostOsFamily::Windows
  def self.matching_regex(); end
end

class Launchy::Detect::HostOsFamily
  def self.cygwin?(); end

  def self.darwin?(); end

  def self.detect(host_os=T.unsafe(nil)); end

  def self.matches?(host_os); end

  def self.nix?(); end

  def self.windows?(); end
end

class Launchy::Detect::NixDesktopEnvironment::Gnome
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment::Kde
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment::NotFound
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment::Xdg
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment::Xfce
  def self.browser(); end

  def self.is_current_desktop_environment?(); end
end

class Launchy::Detect::NixDesktopEnvironment
  def self.browsers(); end

  def self.detect(); end

  def self.fallback_browsers(); end
end

class Launchy::Detect::RubyEngine
  def initialize(ruby_engine=T.unsafe(nil)); end

  def ruby_engine(); end
end

class Launchy::Detect::RubyEngine::Jruby
  def self.engine_name(); end
end

class Launchy::Detect::RubyEngine::MacRuby
  def self.engine_name(); end
end

class Launchy::Detect::RubyEngine::Mri
  def self.engine_name(); end
end

class Launchy::Detect::RubyEngine::Rbx
  def self.engine_name(); end
end

class Launchy::Detect::RubyEngine
  def self.detect(ruby_engine=T.unsafe(nil)); end

  def self.is_current_engine?(ruby_engine); end

  def self.jruby?(); end

  def self.macruby?(); end

  def self.mri?(); end

  def self.rbx?(); end

  def self.ruby_engine_error_message(ruby_engine); end
end

class Launchy::Detect::Runner
  def commandline_normalize(cmdline); end

  def dry_run(cmd, *args); end

  def run(cmd, *args); end

  def shell_commands(cmd, args); end
end

class Launchy::Detect::Runner::Forkable
  def child_pid(); end

  def wet_run(cmd, *args); end
end

class Launchy::Detect::Runner::Jruby
  def wet_run(cmd, *args); end
end

class Launchy::Detect::Runner::Windows
  def all_args(cmd, *args); end

  def shell_commands(cmd, *args); end

  def wet_run(cmd, *args); end
end

class Launchy::Detect::Runner
  def self.detect(); end
end

module Launchy::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
end

module Launchy::Version
  def self.to_a(); end
end

module Launchy
  def self.app_for_uri(uri); end

  def self.app_for_uri_string(s); end

  def self.application(); end

  def self.application=(app); end

  def self.bug_report_message(); end

  def self.debug=(d); end

  def self.debug?(); end

  def self.dry_run=(dry_run); end

  def self.dry_run?(); end

  def self.extract_global_options(options); end

  def self.host_os(); end

  def self.host_os=(host_os); end

  def self.log(msg); end

  def self.open(uri_s, options=T.unsafe(nil), &error_block); end

  def self.path(); end

  def self.path=(path); end

  def self.reset_global_options(); end

  def self.ruby_engine(); end

  def self.ruby_engine=(ruby_engine); end

  def self.string_to_uri(s); end
end

class Letter::Import
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def model_name(&block); end

  def param_delimiter=(param_delimiter); end

  def validation_context(); end
end

class Letter::Import
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.param_delimiter(); end

  def self.param_delimiter=(value); end

  def self.param_delimiter?(); end
end

class LetterOpener::Configuration
  def file_uri_scheme(); end

  def file_uri_scheme=(file_uri_scheme); end

  def location(); end

  def location=(location); end

  def message_template(); end

  def message_template=(message_template); end
end

class LetterOpener::Configuration
end

class LetterOpener::DeliveryMethod
  def deliver!(mail); end

  def initialize(options=T.unsafe(nil)); end

  def settings(); end

  def settings=(settings); end
end

class LetterOpener::Message
  def attachment_filename(attachment); end

  def auto_link(text); end

  def bcc(); end

  def body(); end

  def cc(); end

  def content_type(); end

  def encoding(); end

  def filepath(); end

  def from(); end

  def h(content); end

  def initialize(mail, options=T.unsafe(nil)); end

  def mail(); end

  def render(); end

  def reply_to(); end

  def sender(); end

  def subject(); end

  def template(); end

  def to(); end

  def type(); end
  ERROR_MSG = ::T.let(nil, ::T.untyped)
end

class LetterOpener::Message
  def self.rendered_messages(mail, options=T.unsafe(nil)); end
end

module LetterOpener
  def self.configuration(); end

  def self.configure(); end
end

module LetterOpenerWeb
  VERSION = ::T.let(nil, ::T.untyped)
end

class LetterOpenerWeb::Config
  def letters_location(); end

  def letters_location=(letters_location); end
end

class LetterOpenerWeb::Letter
  def attachments(); end

  def default_style(); end

  def delete(); end

  def headers(); end

  def id(); end

  def initialize(params); end

  def plain_text(); end

  def rich_text(); end

  def sent_at(); end

  def valid?(); end
end

class LetterOpenerWeb::Letter
  def self.destroy_all(); end

  def self.find(id); end

  def self.letters_location(); end

  def self.letters_location=(directory); end

  def self.search(); end
end

class LetterOpenerWeb::LettersController
  def attachment(); end

  def clear(); end

  def destroy(); end

  def index(); end

  def show(); end
end

module LetterOpenerWeb
  def self.config(); end

  def self.configure(); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.reset!(); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class Link
  include ::Link::GeneratedAttributeMethods
  include ::Link::GeneratedAssociationMethods
end

module Link::GeneratedAssociationMethods
end

module Link::GeneratedAssociationMethods
end

module Link::GeneratedAttributeMethods
end

module Link::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  def config(); end

  def configure(); end

  def initialize(config); end

  def options(); end

  def start(); end

  def started?(); end

  def stop(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  def self.usable?(); end
end

class Listen::Adapter::Config
  def adapter_options(); end

  def directories(); end

  def initialize(directories, queue, silencer, adapter_options); end

  def queue(); end

  def silencer(); end
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  README_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  def self.select(options=T.unsafe(nil)); end
end

class Listen::Backend
  def initialize(directories, queue, silencer, config); end

  def min_delay_between_events(); end

  def start(*args, **arg, &block); end

  def stop(*args, **arg, &block); end
end

class Listen::Change
  def initialize(config, record); end

  def invalidate(type, rel_path, options); end

  def record(); end
end

class Listen::Change::Config
  def initialize(queue, silencer); end

  def queue(*args); end

  def silenced?(path, type); end
end

class Listen::Directory
  def self._async_changes(snapshot, path, previous, options); end

  def self._change(snapshot, type, path, options); end

  def self._children(path); end

  def self.ascendant_of?(base, other); end

  def self.scan(snapshot, rel_path, options); end
end

class Listen::Event::Config
  def call(*args); end

  def callable?(); end

  def event_queue(); end

  def initialize(listener, event_queue, queue_optimizer, wait_for_delay, &block); end

  def listener(); end

  def min_delay_between_events(); end

  def optimize_changes(changes); end

  def sleep(seconds); end
end

class Listen::Event::Loop
  def initialize(config); end

  def pause(); end

  def start(); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def wakeup_on_event(); end
  MAX_STARTUP_SECONDS = ::T.let(nil, ::T.untyped)
end

Listen::Event::Loop::Error = Listen::Error

Listen::Event::Loop::NotStarted = Listen::Error::NotStarted

class Listen::Event::Processor
  def initialize(config, reasons); end

  def loop_for(latency); end
end

class Listen::Event::Queue
  def <<(args); end

  def close(*args, **arg, &block); end

  def empty?(*args, **arg, &block); end

  def initialize(config); end

  def pop(*args, **arg, &block); end
end

class Listen::Event::Queue::Config
  def initialize(relative); end

  def relative?(); end
end

module Listen::FSM
  def initialize_fsm(); end

  def state(); end

  def wait_for_state(*wait_for_states, timeout: T.unsafe(nil)); end
end

module Listen::FSM::ClassMethods
  def start_state(new_start_state=T.unsafe(nil)); end

  def state(state_name, to: T.unsafe(nil), &block); end

  def states(); end
end

class Listen::FSM::State
  def call(obj); end

  def initialize(name, transitions, &block); end

  def name(); end

  def transitions(); end

  def valid_transition?(new_state); end
end

module Listen::FSM
  def self.included(klass); end
end

class Listen::File
  def self.change(record, rel_path); end

  def self.inaccurate_mac_time?(stat); end
end

class Listen::Listener
  def ignore(regexps); end

  def ignore!(regexps); end

  def initialize(*dirs, &block); end

  def only(regexps); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def start(); end

  def stop(); end

  def stopped?(); end
end

class Listen::Listener::Config
  def adapter_instance_options(klass); end

  def adapter_select_options(); end

  def initialize(opts); end

  def min_delay_between_events(); end

  def relative?(); end

  def silencer_rules(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

module Listen::MonotonicTime
  def self.now(); end
end

class Listen::Options
  def initialize(opts, defaults); end

  def method_missing(name, *_); end
end

class Listen::QueueOptimizer
  def initialize(config); end

  def smoosh_changes(changes); end
end

class Listen::QueueOptimizer::Config
  def debug(*args, &block); end

  def exist?(path); end

  def initialize(adapter_class, silencer); end

  def silenced?(path, type); end
end

class Listen::Record
  def add_dir(rel_path); end

  def build(); end

  def dir_entries(rel_path); end

  def file_data(rel_path); end

  def initialize(directory, silencer); end

  def root(); end

  def unset_path(rel_path); end

  def update_file(rel_path, data); end
end

class Listen::Record::Entry
  def children(); end

  def initialize(root, relative, name=T.unsafe(nil)); end

  def meta(); end

  def name(); end

  def real_path(); end

  def record_dir_key(); end

  def relative(); end

  def root(); end

  def sys_path(); end
end

class Listen::Record::SymlinkDetector
  def verify_unwatched!(entry); end

  def warn(message); end
  README_URL = ::T.let(nil, ::T.untyped)
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
end

Listen::Record::SymlinkDetector::Error = Listen::Error

class Listen::Silencer
  def configure(options); end

  def ignore_patterns(); end

  def ignore_patterns=(ignore_patterns); end

  def initialize(**options); end

  def only_patterns(); end

  def only_patterns=(only_patterns); end

  def silenced?(relative_path, type); end
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_FILES = ::T.let(nil, ::T.untyped)
end

class Listen::Silencer::Controller
  def append_ignores(*regexps); end

  def initialize(silencer, default_options); end

  def replace_with_bang_ignores(regexps); end

  def replace_with_only(regexps); end
end

module Listen::Thread
  def self.new(name, &block); end

  def self.rescue_and_log(method_name, *args, caller_stack: T.unsafe(nil)); end
end

module Listen
  def self.adapter_warn(message); end

  def self.adapter_warn_behavior(); end

  def self.adapter_warn_behavior=(adapter_warn_behavior); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.stop(); end

  def self.to(*args, &block); end
end

class LoadError
  include ::DidYouMean::Correctable
  def is_missing?(location); end
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end

  def with_level(severity); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  DatetimeFormat = ::T.let(nil, ::T.untyped)
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Logger::Severity
  def self.coerce(severity); end
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  INLINE_LINE_BREAK = ::T.let(nil, ::T.untyped)
  LINEBREAKERS = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

Loofah::HTML = Loofah::HTML4

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_COLORS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_EXTENDED_COLORS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ARIA_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_IMPORTANT = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
  CSS_PROPERTY_STRING_WITHOUT_EMBEDDED_QUOTES = ::T.let(nil, ::T.untyped)
  CSS_WHITESPACE = ::T.let(nil, ::T.untyped)
  DATA_ATTRIBUTE_NAME = ::T.let(nil, ::T.untyped)
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

module Lumberjack
  LINE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Context
  def [](key); end

  def []=(key, value); end

  def initialize(parent_context=T.unsafe(nil)); end

  def reset(); end

  def tag(tags); end

  def tags(); end
end

class Lumberjack::Device
  def cleanup_files!(); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(format); end

  def do_once(file); end

  def flush(); end

  def reopen(logdev=T.unsafe(nil)); end

  def write(entry); end
end

class Lumberjack::Device::LogFile
  def initialize(path, options=T.unsafe(nil)); end

  def path(); end
  EXTERNAL_ENCODING = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Device::Multi
  def initialize(*devices); end
end

class Lumberjack::Device::Null
  def initialize(*args); end
end

class Lumberjack::Device::RollingLogFile
  def after_roll(); end

  def archive_file_suffix(); end

  def before_flush(); end

  def keep(); end

  def keep=(keep); end

  def roll_file!(); end

  def roll_file?(); end
end

class Lumberjack::Device::SizeRollingLogFile
  def max_size(); end

  def next_archive_number(); end
end

class Lumberjack::Device::Writer
  def buffer_size(); end

  def buffer_size=(value); end

  def initialize(stream, options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end
  DEFAULT_ADDITIONAL_LINES_TEMPLATE = ::T.let(nil, ::T.untyped)
  DEFAULT_FIRST_LINE_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Device::Writer::Buffer
  def <<(string); end

  def clear(); end

  def empty?(); end

  def pop!(); end

  def size(); end
end

class Lumberjack::Formatter
  def add(klass, formatter=T.unsafe(nil), *args, &block); end

  def call(severity, timestamp, progname, msg); end

  def clear(); end

  def format(message); end

  def remove(klass); end
end

class Lumberjack::Formatter::DateTimeFormatter
  def call(obj); end

  def format(); end

  def initialize(format=T.unsafe(nil)); end
end

class Lumberjack::Formatter::ExceptionFormatter
  def backtrace_cleaner(); end

  def backtrace_cleaner=(backtrace_cleaner); end

  def call(exception); end

  def initialize(backtrace_cleaner=T.unsafe(nil)); end
end

class Lumberjack::Formatter::IdFormatter
  def call(obj); end

  def initialize(id_attribute=T.unsafe(nil)); end
end

class Lumberjack::Formatter::InspectFormatter
  def call(obj); end
end

class Lumberjack::Formatter::ObjectFormatter
  def call(obj); end
end

class Lumberjack::Formatter::PrettyPrintFormatter
  def call(obj); end

  def initialize(width=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class Lumberjack::Formatter::StringFormatter
  def call(obj); end
end

class Lumberjack::Formatter::StripFormatter
  def call(obj); end
end

class Lumberjack::Formatter::StructuredFormatter
  def call(obj); end

  def initialize(formatter=T.unsafe(nil)); end
end

class Lumberjack::Formatter::TruncateFormatter
  def call(obj); end

  def initialize(length=T.unsafe(nil)); end
end

class Lumberjack::Formatter
  def self.empty(); end
end

class Lumberjack::LogEntry
  def initialize(time, severity, message, progname, pid, tags); end

  def message(); end

  def message=(message); end

  def pid(); end

  def pid=(pid); end

  def progname(); end

  def progname=(progname); end

  def severity(); end

  def severity=(severity); end

  def severity_label(); end

  def tag(name); end

  def tags(); end

  def tags=(tags); end

  def time(); end

  def time=(time); end

  def unit_of_work_id(); end

  def unit_of_work_id=(value); end
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
  UNIT_OF_WORK_ID = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Logger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def add_entry(severity, message, progname=T.unsafe(nil), tags=T.unsafe(nil)); end

  def close(); end

  def closed?(); end

  def datetime_format(); end

  def datetime_format=(format); end

  def debug(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def debug!(); end

  def debug?(); end

  def device(); end

  def device=(device); end

  def error(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def error!(); end

  def error?(); end

  def fatal(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def fatal!(); end

  def fatal?(); end

  def flush(); end

  def formatter(); end

  def formatter=(value); end

  def info(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def info!(); end

  def info?(); end

  def initialize(device=T.unsafe(nil), options=T.unsafe(nil)); end

  def last_flushed_at(); end

  def level(); end

  def level=(value); end

  def log(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def progname(); end

  def progname=(progname); end

  def remove_tag(*tag_names); end

  def reopen(logdev=T.unsafe(nil)); end

  def set_progname(value, &block); end

  def sev_threshold(); end

  def sev_threshold=(value); end

  def silence(temporary_level=T.unsafe(nil), &block); end

  def silencer(); end

  def silencer=(silencer); end

  def tag(tags, &block); end

  def tag_formatter(); end

  def tag_formatter=(tag_formatter); end

  def tagged_logger!(); end

  def tags(); end

  def unknown(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def untagged(&block); end

  def warn(message_or_progname_or_tags=T.unsafe(nil), progname_or_tags=T.unsafe(nil), &block); end

  def warn!(); end

  def warn?(); end

  def with_level(severity, &block); end
end

class Lumberjack::Rack::Context
  def call(env); end

  def initialize(app); end
end

class Lumberjack::Rack::RequestId
  def call(env); end

  def initialize(app, abbreviated=T.unsafe(nil)); end
  REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class Lumberjack::Rack::UnitOfWork
  def call(env); end

  def initialize(app); end
end

module Lumberjack::Severity
  DEBUG = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FATAL = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  SEVERITY_LABELS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  WARN = ::T.let(nil, ::T.untyped)
end

module Lumberjack::Severity
  def self.coerce(value); end

  def self.label_to_level(label); end

  def self.level_to_label(severity); end
end

class Lumberjack::TagFormatter
  def add(names, formatter=T.unsafe(nil), &block); end

  def clear(); end

  def default(formatter=T.unsafe(nil), &block); end

  def format(tags); end

  def remove(names); end

  def remove_default(); end
end

module Lumberjack::TaggedLoggerSupport
  def clear_tags!(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags, &block); end
end

class Lumberjack::TaggedLoggerSupport::Formatter
  def __formatter(); end

  def clear_tags!(*args, **arg, &block); end

  def current_tags(); end

  def initialize(formatter:, logger:); end

  def pop_tags(*args, **arg, &block); end

  def push_tags(*args, **arg, &block); end

  def tagged(*args, **arg, &block); end

  def tags_text(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Lumberjack::TaggedLogging
  def self.included(base); end
end

class Lumberjack::Tags
  def self.expand_runtime_values(hash); end

  def self.stringify_keys(hash); end
end

class Lumberjack::Template
  def call(entry); end

  def datetime_format(); end

  def datetime_format=(format); end

  def initialize(first_line, options=T.unsafe(nil)); end
  MICROSECOND_TIME_FORMAT = ::T.let(nil, ::T.untyped)
  MILLISECOND_TIME_FORMAT = ::T.let(nil, ::T.untyped)
  PLACEHOLDER_PATTERN = ::T.let(nil, ::T.untyped)
  TEMPLATE_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
end

module Lumberjack
  def self.context(&block); end

  def self.context?(); end

  def self.context_tags(); end

  def self.tag(tags); end

  def self.unit_of_work(id=T.unsafe(nil)); end

  def self.unit_of_work_id(); end

  def self.use_context(context, &block); end
end

class MIME::Type
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Types
  VERSION = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Columnar
  LOAD_MUTEX = ::T.let(nil, ::T.untyped)
end

module MIME::Types::Data
  PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MIME::Types
  extend ::Enumerable
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::BccField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommonField
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LAX_CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  UNFOLD_WS = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Envelope
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::FileDelivery
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::FromField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::LoggerDelivery
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

class Mail::Message
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
  def self.parse(string); end
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte::Unicode
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

module Mail::Parsers::ContentDispositionParser
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def disposition_type(); end

  def disposition_type=(_); end

  def error(); end

  def error=(_); end

  def parameters(); end

  def parameters=(_); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentDispositionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentLocationParser
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def error(); end

  def error=(_); end

  def location(); end

  def location=(_); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentLocationParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTransferEncodingParser
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def encoding(); end

  def encoding=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentTransferEncodingParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTypeParser
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def error(); end

  def error=(_); end

  def main_type(); end

  def main_type=(_); end

  def parameters(); end

  def parameters=(_); end

  def sub_type(); end

  def sub_type=(_); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ContentTypeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::EnvelopeFromParser
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def address(); end

  def address=(_); end

  def ctime_date(); end

  def ctime_date=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::EnvelopeFromParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MessageIdsParser
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def error(); end

  def error=(_); end

  def message_ids(); end

  def message_ids=(_); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::MessageIdsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MimeVersionParser
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def error(); end

  def error=(_); end

  def major(); end

  def major=(_); end

  def minor(); end

  def minor=(_); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::MimeVersionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::Parsers::PhraseListsParser
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def error(); end

  def error=(_); end

  def phrases(); end

  def phrases=(_); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ReceivedParser
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def date(); end

  def date=(_); end

  def error(); end

  def error=(_); end

  def info(); end

  def info=(_); end

  def time(); end

  def time=(_); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Mail::Parsers::ReceivedParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::PartsList
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SMTP
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  def deliver!(mail); end

  def destinations_for(envelope); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SmtpEnvelope
  def from(); end

  def from=(addr); end

  def initialize(mail); end

  def message(); end

  def message=(message); end

  def to(); end

  def to=(addr); end
  MAX_ADDRESS_BYTESIZE = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::TestMailer
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::TestMailer
  def self.deliveries(); end

  def self.deliveries=(val); end
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Marcel
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  MAGIC = ::T.let(nil, ::T.untyped)
  TYPE_EXTS = ::T.let(nil, ::T.untyped)
  TYPE_PARENTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class MarriageTalk
  include ::MarriageTalk::GeneratedAttributeMethods
  include ::MarriageTalk::GeneratedAssociationMethods
end

module MarriageTalk::GeneratedAssociationMethods
end

module MarriageTalk::GeneratedAssociationMethods
end

module MarriageTalk::GeneratedAttributeMethods
end

module MarriageTalk::GeneratedAttributeMethods
  extend ::Mutex_m
end

class MatchData
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def match(arg); end

  def match_length(arg); end
end

class Matrix
  def *(m); end

  def **(exp); end

  def +(m); end

  def +@(); end

  def -(m); end

  def -@(); end

  def /(other); end

  def ==(other); end

  def [](i, j); end

  def []=(i, j, v); end

  def abs(); end

  def adjoint(); end

  def adjugate(); end

  def antisymmetric?(); end

  def coerce(other); end

  def cofactor(row, column); end

  def cofactor_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def collect(which=T.unsafe(nil), &block); end

  def collect!(which=T.unsafe(nil)); end

  def column(j); end

  def column_count(); end

  def column_size(); end

  def column_vectors(); end

  def combine(*matrices, &block); end

  def component(i, j); end

  def conj(); end

  def conjugate(); end

  def det(); end

  def det_e(); end

  def determinant(); end

  def determinant_e(); end

  def diagonal?(); end

  def each_with_index(which=T.unsafe(nil)); end

  def eigen(); end

  def eigensystem(); end

  def element(i, j); end

  def elements_to_f(); end

  def elements_to_i(); end

  def elements_to_r(); end

  def empty?(); end

  def entrywise_product(m); end

  def eql?(other); end

  def find_index(*args); end

  def first_minor(row, column); end

  def hadamard_product(m); end

  def hermitian?(); end

  def hstack(*matrices); end

  def imag(); end

  def imaginary(); end

  def index(*args); end

  def initialize(rows, column_count=T.unsafe(nil)); end

  def inv(); end

  def inverse(); end

  def laplace_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def lower_triangular?(); end

  def lup(); end

  def lup_decomposition(); end

  def map(which=T.unsafe(nil), &block); end

  def map!(which=T.unsafe(nil)); end

  def minor(*param); end

  def normal?(); end

  def orthogonal?(); end

  def permutation?(); end

  def power_int(exp); end

  def rank(); end

  def rank_e(); end

  def real(); end

  def real?(); end

  def rect(); end

  def rectangular(); end

  def regular?(); end

  def rotate_entries(rotation=T.unsafe(nil)); end

  def round(ndigits=T.unsafe(nil)); end

  def row(i, &block); end

  def row_count(); end

  def row_size(); end

  def row_vectors(); end

  def rows(); end

  def singular?(); end

  def skew_symmetric?(); end

  def square?(); end

  def symmetric?(); end

  def t(); end

  def to_a(); end

  def to_matrix(); end

  def tr(); end

  def trace(); end

  def transpose(); end

  def unitary?(); end

  def upper_triangular?(); end

  def vstack(*matrices); end

  def zero?(); end
  SELECTORS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Matrix::CoercionHelper
  def self.check_int(val, count, kind); end

  def self.check_range(val, count, kind); end

  def self.coerce_to(obj, cls, meth); end

  def self.coerce_to_int(obj); end

  def self.coerce_to_matrix(obj); end
end

class Matrix::EigenvalueDecomposition
  def initialize(a); end
end

class Matrix::LUPDecomposition
  include ::Matrix::ConversionHelper
  def det(); end

  def determinant(); end

  def initialize(a); end

  def l(); end

  def p(); end

  def pivots(); end

  def singular?(); end

  def solve(b); end

  def to_a(); end

  def to_ary(); end

  def u(); end
end

class Matrix::LUPDecomposition
end

class Matrix::Scalar
  def *(other); end

  def **(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def initialize(value); end
end

class Meditation
  include ::Meditation::GeneratedAttributeMethods
  include ::Meditation::GeneratedAssociationMethods
end

module Meditation::GeneratedAssociationMethods
end

module Meditation::GeneratedAssociationMethods
end

module Meditation::GeneratedAttributeMethods
end

module Meditation::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Member
  include ::Member::GeneratedAttributeMethods
  include ::Member::GeneratedAssociationMethods
  def birthday_age(); end

  def birthday_today?(); end
end

module Member::GeneratedAssociationMethods
end

module Member::GeneratedAssociationMethods
end

module Member::GeneratedAttributeMethods
end

module Member::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Member
  def self.birthday_today(*args, **arg); end

  def self.find_birthdays_for(*args, **arg); end
end

class MessagePack::HeldBuffer
end

class MessagePack::HeldBuffer
end

module MessagePack::Time
  Packer = ::T.let(nil, ::T.untyped)
  TIME_AT_3_AVAILABLE = ::T.let(nil, ::T.untyped)
  Unpacker = ::T.let(nil, ::T.untyped)
end

class MessagePack::Timestamp
  TIMESTAMP32_MAX_SEC = ::T.let(nil, ::T.untyped)
  TIMESTAMP64_MAX_SEC = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers
  def comment_describing(file, line_number); end

  def complete_expression?(str); end

  def expression_at(file, line_number, options=T.unsafe(nil)); end
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  def self.===(ex); end

  def self.rbx?(); end
end

module MethodSource::MethodExtensions
  def class_comment(); end

  def comment(); end

  def module_comment(); end

  def source(); end
end

module MethodSource::MethodExtensions
  def self.included(klass); end
end

module MethodSource::ReeSourceLocation
  def source_location(); end
end

module MethodSource::SourceLocation::MethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::ProcExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  def source_location(); end
end

module MethodSource
  def self.clear_cache(); end

  def self.comment_helper(source_location, name=T.unsafe(nil)); end

  def self.extract_code(source_location); end

  def self.lines_for(file_name, name=T.unsafe(nil)); end

  def self.source_helper(source_location, name=T.unsafe(nil)); end

  def self.valid_expression?(str); end
end

module MiniMagick::Configuration
  CLI_DETECTION = ::T.let(nil, ::T.untyped)
end

class MiniMagick::Image::Info
  ASCII_ENCODED_EXIF_KEYS = ::T.let(nil, ::T.untyped)
end

class MiniMagick::Tool
  CREATION_OPERATORS = ::T.let(nil, ::T.untyped)
end

module MiniMagick::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

MiniMime::Db::PReadFile = File

class MiniMime::Db::RandomAccessDb
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Minitest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
  RE = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def _synchronize(); end

  def _where(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_pattern(); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_pattern(); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil), include_all: T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), _ignored=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end

  def initialize(regexp=T.unsafe(nil)); end

  def regexp(); end

  def regexp=(regexp); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

module Minitest::Compress
  def compress(orig); end
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
  BASE_DIR = ::T.let(nil, ::T.untyped)
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Result
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def metadata(); end

  def metadata=(metadata); end

  def metadata?(); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.test_order(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::Test
  def capture_exceptions(); end

  def neuter_exception(e); end

  def new_exception(klass, msg, bt, kill=T.unsafe(nil)); end

  def sanitize_exception(e); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  SETUP_METHODS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

class Minitest::Test
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
  BASE_RE = ::T.let(nil, ::T.untyped)
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.allow_fork(); end

  def self.allow_fork=(allow_fork); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.cattr_accessor(name); end

  def self.clock_time(); end

  def self.empty_run!(options); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run_one_method(klass, method_name); end

  def self.seed(); end

  def self.seed=(seed); end
end

module Mocktail
  BASE_PATH = ::T.let(nil, ::T.untyped)
  TYPED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Mocktail::Bind
  def self.call(mock, method_name, *args, **kwargs, &blk); end
end

class Mocktail::Cabinet
  def calls(); end

  def calls_for_double(double); end

  def demonstration_in_progress=(demonstration_in_progress); end

  def demonstration_in_progress?(); end

  def double_for_instance(thing); end

  def reset!(); end

  def store_call(call); end

  def store_double(double); end

  def store_stubbing(stubbing); end

  def store_unsatisfying_call(unsatisfying_call); end

  def stubbings(); end

  def stubbings_for_double(double); end

  def unsatisfying_calls(); end
end

class Mocktail::Call
  def ==(other); end

  def args(); end

  def block(); end

  def double(); end

  def dry_type(); end

  def eql?(other); end

  def kwargs(); end

  def method(); end

  def original_method(); end

  def original_type(); end

  def singleton(); end
end

class Mocktail::Call
  def self.inherited(grandchild); end
end

class Mocktail::CleansBacktrace
  def clean(error); end
end

class Mocktail::CollectsCalls
  def collect(double, method_name); end
end

class Mocktail::CreatesIdentifier
  def create(s, default: T.unsafe(nil), max_length: T.unsafe(nil)); end
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Mocktail::DSL
  def stubs(ignore_block: T.unsafe(nil), ignore_extra_args: T.unsafe(nil), ignore_arity: T.unsafe(nil), times: T.unsafe(nil), &demo); end

  def verify(ignore_block: T.unsafe(nil), ignore_extra_args: T.unsafe(nil), ignore_arity: T.unsafe(nil), times: T.unsafe(nil), &demo); end
end

module Mocktail::Debug
  def self.guard_against_mocktail_accidentally_calling_mocks_if_debugging!(); end
end

class Mocktail::DeclaresDryClass
  def declare(type, instance_methods); end
  DEFAULT_ANCESTORS = ::T.let(nil, ::T.untyped)
end

class Mocktail::DemoConfig
  def ignore_arity(); end

  def ignore_block(); end

  def ignore_extra_args(); end

  def times(); end
end

class Mocktail::DemoConfig
  def self.inherited(grandchild); end
end

class Mocktail::DescribesUnsatisfiedStubbing
  def describe(dry_call); end
end

class Mocktail::DeterminesMatchingCalls
  def determine(real_call, demo_call, demo_config); end
end

class Mocktail::Double
  def dry_instance(); end

  def dry_methods(); end

  def dry_type(); end

  def original_type(); end
end

class Mocktail::Double
  def self.inherited(grandchild); end
end

class Mocktail::DoubleData
  def double(); end

  def type(); end
end

class Mocktail::DoubleData
  def self.inherited(grandchild); end
end

class Mocktail::EnsuresImitationSupport
  def ensure(type); end
end

class Mocktail::ExplainsNils
  def explain(); end
end

class Mocktail::ExplainsThing
  def explain(thing); end
end

class Mocktail::Explanation
  def initialize(reference, message); end

  def message(); end

  def reference(); end

  def type(); end
end

module Mocktail::ExplanationData
  include ::DEBUGGER__::TrapInterceptor
  def calls(); end

  def stubbings(); end
end

class Mocktail::FakeMethodData
  def receiver(); end
end

class Mocktail::FakeMethodData
  def self.inherited(grandchild); end
end

class Mocktail::FindsSatisfaction
  def find(dry_call); end
end

class Mocktail::FindsVerifiableCalls
  def find(recording, demo_config); end
end

class Mocktail::FulfillsStubbing
  def fulfill(dry_call); end

  def satisfaction(dry_call); end
end

class Mocktail::GathersCallsOfMethod
  def gather(dry_call); end
end

class Mocktail::GathersFakeableInstanceMethods
  def gather(type); end

  def ignore?(type, method_name); end

  def ignored_ancestors(); end
end

class Mocktail::GrabsOriginalMethodParameters
  def grab(method); end
end

class Mocktail::HandlesDryCall
  def handle(dry_call); end
end

class Mocktail::HandlesDryNewCall
  def handle(type, args, kwargs, block); end
end

class Mocktail::ImitatesType
  def imitate(type); end
end

class Mocktail::InitializesMocktail
  def init(); end
end

class Mocktail::LogsCall
  def log(dry_call); end
end

class Mocktail::MakesDouble
  def make(type); end
end

class Mocktail::MatcherPresentation
  def method_missing(name, *args, **kwargs, &blk); end
end

class Mocktail::MatcherRegistry
  def add(matcher_type); end

  def get(name); end
end

class Mocktail::MatcherRegistry
  def self.instance(); end
end

class Mocktail::Matchers::Any
  def initialize(); end
end

class Mocktail::Matchers::Base
  def initialize(expected); end

  def is_mocktail_matcher?(); end

  def match?(actual); end
end

class Mocktail::Matchers::Base
  def self.matcher_name(); end
end

class Mocktail::Matchers::Captor
  def capture(); end

  def captured?(); end

  def value(); end
end

class Mocktail::Matchers::Captor::Capture
  def captured?(); end

  def initialize(); end

  def value(); end
end

class Mocktail::Matchers::Includes
  def initialize(*expecteds); end
end

class Mocktail::Matchers::Numeric
  def initialize(); end
end

class Mocktail::Matchers::That
  def initialize(&blk); end
end

class Mocktail::NoExplanationData
  def thing(); end
end

class Mocktail::NoExplanationData
  def self.inherited(grandchild); end
end

class Mocktail::Params
  def all(); end

  def all=(all); end

  def allowed(); end

  def optional(); end

  def optional=(optional); end

  def required(); end

  def required=(required); end

  def rest(); end

  def rest=(rest); end

  def rest?(); end
end

class Mocktail::Params
  def self.inherited(grandchild); end
end

class Mocktail::RaisesNeatoNoMethodError
  def call(call); end
end

class Mocktail::RaisesVerificationError
  def raise(recording, verifiable_calls, demo_config); end
end

class Mocktail::ReconcilesArgsWithParams
  def reconcile(signature); end
end

class Mocktail::ReconstructsCall
  def reconstruct(double:, call_binding:, default_args:, dry_class:, type:, method:, original_method:, signature:); end
end

class Mocktail::RecordsDemonstration
  def record(demonstration, demo_config); end
end

class Mocktail::RecreatesMessage
  def recreate(signature); end
end

class Mocktail::RedefinesNew
  def redefine(type); end
end

class Mocktail::RedefinesSingletonMethods
  def declare_singleton_method_missing_errors!(type); end

  def redefine(type); end
end

class Mocktail::RegistersMatcher
  def register(matcher_type); end
end

class Mocktail::RegistersStubbing
  def register(demonstration, demo_config); end
end

class Mocktail::ReplacesNext
  def replace(type, count); end

  def replace_once(type); end
end

class Mocktail::ReplacesType
  def replace(type); end
end

class Mocktail::ResetsState
  def reset(); end
end

class Mocktail::RunsSorbetSigBlocksBeforeReplacement
  def run(type); end
end

class Mocktail::Signature
  def block_arg(); end

  def block_param(); end

  def keyword_args(); end

  def keyword_params(); end

  def positional_args(); end

  def positional_params(); end
  DEFAULT_BLOCK_PARAM = ::T.let(nil, ::T.untyped)
  DEFAULT_REST_ARGS = ::T.let(nil, ::T.untyped)
  DEFAULT_REST_KWARGS = ::T.let(nil, ::T.untyped)
end

class Mocktail::Signature
  def self.inherited(grandchild); end
end

class Mocktail::SimulatesArgumentError
  def simulate(dry_call); end
end

class Mocktail::StringifiesCall
  def stringify(call, anonymous_blocks: T.unsafe(nil), always_parens: T.unsafe(nil)); end

  def stringify_multiple(calls, nonzero_message:, zero_message:, anonymous_blocks: T.unsafe(nil), always_parens: T.unsafe(nil)); end
end

class Mocktail::StringifiesMethodName
  def stringify(call); end
end

class Mocktail::StringifiesMethodSignature
  def stringify(signature); end
end

class Mocktail::Stubbing
  def demo_config(); end

  def demonstration(); end

  def effect(); end

  def effect=(effect); end

  def recording(); end

  def satisfaction_count(); end

  def satisfaction_count=(satisfaction_count); end

  def satisfied!(); end

  def with(&block); end
  MethodReturnType = ::T.let(nil, ::T.untyped)
end

class Mocktail::Stubbing
  def self.inherited(grandchild); end
end

class Mocktail::TopShelf
  def new_replaced?(type); end

  def of_next_registered?(type); end

  def register_new_replacement!(type); end

  def register_of_next_replacement!(type); end

  def register_singleton_method_replacement!(type); end

  def reset_current_thread!(); end

  def singleton_methods_replaced?(type); end

  def type_replacement_for(type); end

  def type_replacement_if_exists_for(type); end

  def unregister_of_next_replacement!(type); end
end

class Mocktail::TopShelf
  def self.instance(); end
end

class Mocktail::TransformsParams
  def transform(dry_call, params: T.unsafe(nil)); end
end

class Mocktail::TypeReplacement
  def original_methods(); end

  def original_methods=(original_methods); end

  def original_new(); end

  def original_new=(original_new); end

  def replacement_methods(); end

  def replacement_methods=(replacement_methods); end

  def replacement_new(); end

  def replacement_new=(replacement_new); end

  def type(); end
end

class Mocktail::TypeReplacement
  def self.inherited(grandchild); end
end

class Mocktail::TypeReplacementData
  def double(); end

  def replaced_method_names(); end

  def type(); end
end

class Mocktail::TypeReplacementData
  def self.inherited(grandchild); end
end

class Mocktail::UnsatisfyingCall
  def backtrace(); end

  def call(); end

  def other_stubbings(); end
end

class Mocktail::UnsatisfyingCall
  def self.inherited(grandchild); end
end

class Mocktail::UnsatisfyingCallExplanation
  def initialize(reference, message); end

  def message(); end

  def reference(); end

  def type(); end
end

class Mocktail::ValidatesArguments
  def validate(dry_call); end
end

class Mocktail::ValidatesArguments
  def self.disable!(); end

  def self.disabled?(); end

  def self.enable!(); end

  def self.optional(disable, &blk); end
end

class Mocktail::VerifiesCall
  def verify(demo, demo_config); end
end

module Mocktail
  def self.cabinet(); end

  def self.calls(double, method_name=T.unsafe(nil)); end

  def self.captor(); end

  def self.explain(thing); end

  def self.explain_nils(); end

  def self.matchers(); end

  def self.of(type); end

  def self.of_next(type, count: T.unsafe(nil)); end

  def self.of_next_with_count(type, count); end

  def self.register_matcher(matcher); end

  def self.replace(type); end

  def self.reset(); end
end

class Module
  def class_name(); end

  def context(*a, &b); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def set_temporary_name(arg); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def undefined_instance_methods(); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module MultiJson
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::OptionsCache
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

module MultiXml
  CONTENT_ROOT = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class MultiXml::DisallowedTypeError
  def initialize(type); end
end

module MultiXml
  def self.default_parser(); end

  def self.parse(xml, options=T.unsafe(nil)); end

  def self.parser(); end

  def self.parser=(new_parser); end
end

module Multipart::Post::Parts
end

class Multipart::Post::Parts::EpiloguePart
  include ::Multipart::Post::Parts::Part
  def initialize(boundary); end
end

class Multipart::Post::Parts::EpiloguePart
end

class Multipart::Post::Parts::FilePart
  include ::Multipart::Post::Parts::Part
  def build_head(boundary, name, filename, type, content_len, opts=T.unsafe(nil)); end

  def initialize(boundary, name, io, headers=T.unsafe(nil)); end
end

class Multipart::Post::Parts::FilePart
end

class Multipart::Post::Parts::ParamPart
  include ::Multipart::Post::Parts::Part
  def build_part(boundary, name, value, headers=T.unsafe(nil)); end

  def initialize(boundary, name, value, headers=T.unsafe(nil)); end
end

class Multipart::Post::Parts::ParamPart
end

module Multipart::Post::Parts::Part
  def length(); end

  def to_io(); end
end

module Multipart::Post::Parts::Part
  def self.file?(value); end

  def self.new(boundary, name, value, headers=T.unsafe(nil)); end
end

module Multipart::Post::Parts
end

class Multipart::Post::UploadIO
  def content_type(); end

  def initialize(filename_or_io, content_type, filename=T.unsafe(nil), opts=T.unsafe(nil)); end

  def io(); end

  def local_path(); end

  def method_missing(*args); end

  def opts(); end

  def original_filename(); end

  def respond_to?(meth, include_all=T.unsafe(nil)); end
end

class Multipart::Post::UploadIO
  def self.convert!(io, content_type, original_filename, local_path); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

module NIO
  ENGINE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class NIO::ByteBuffer
  include ::Enumerable
  def <<(arg); end

  def [](arg); end

  def capacity(); end

  def clear(); end

  def each(&blk); end

  def flip(); end

  def full?(); end

  def get(*arg); end

  def initialize(arg); end

  def limit(); end

  def limit=(limit); end

  def mark(); end

  def position(); end

  def position=(position); end

  def read_from(arg); end

  def remaining(); end

  def reset(); end

  def rewind(); end

  def size(); end

  def write_to(arg); end
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer
end

class NIO::Monitor
  def add_interest(arg); end

  def close(*arg); end

  def closed?(); end

  def initialize(arg, arg1, arg2); end

  def interests(); end

  def interests=(interests); end

  def io(); end

  def readable?(); end

  def readiness(); end

  def remove_interest(arg); end

  def selector(); end

  def value(); end

  def value=(value); end

  def writable?(); end

  def writeable?(); end
end

class NIO::Monitor
end

class NIO::Selector
  def backend(); end

  def close(); end

  def closed?(); end

  def deregister(arg); end

  def empty?(); end

  def initialize(*arg); end

  def register(arg, arg1); end

  def registered?(arg); end

  def wakeup(); end
end

class NIO::Selector
  def self.backends(); end
end

module NIO
  def self.engine(); end

  def self.pure?(env=T.unsafe(nil)); end
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

module Nenv
  VERSION = ::T.let(nil, ::T.untyped)
end

class Nenv::AutoEnvironment
  def method_missing(meth, *args); end
end

module Nenv::Builder
  def self.build(&block); end
end

class Nenv::Environment
  def create_method(meth, &block); end

  def initialize(namespace=T.unsafe(nil)); end
end

class Nenv::Environment
  def self._create_env_accessor(klass, meth, &block); end

  def self.create_method(meth, &block); end
end

module Nenv
  def self.instance(); end

  def self.method_missing(meth, *args); end

  def self.reset(); end

  def self.respond_to?(meth); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def write_timeout(); end

  def write_timeout=(sec); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGenericRequest
  include ::Seahorse::Client::NetHttp::Patches::PatchDefaultContentType
end

module Net::HTTPHeader
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse
  def body_encoding(); end

  def body_encoding=(value); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end
end

class Net::HTTPResponse::Inflater
  def bytes_inflated(); end
end

Net::HTTPResponseReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

class Net::HTTPSuccess
end

Net::HTTPSuccessCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
end

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  include ::Net::IMAP::DeprecatedClientOptions
  def auth_capable?(mechanism); end

  def auth_mechanisms(); end

  def capabilities(); end

  def capabilities_cached?(); end

  def capability?(capability); end

  def capable?(capability); end

  def clear_cached_capabilities(); end

  def clear_responses(type=T.unsafe(nil)); end

  def enable(*capabilities); end

  def host(); end

  def id(client_id=T.unsafe(nil)); end

  def idle_response_timeout(); end

  def logout!(); end

  def namespace(); end

  def open_timeout(); end

  def port(); end

  def ssl_ctx(); end

  def ssl_ctx_params(); end

  def tls_verified?(); end

  def uid_expunge(uid_set); end

  def unselect(); end
  ALL = ::T.let(nil, ::T.untyped)
  ARCHIVE = ::T.let(nil, ::T.untyped)
  DRAFTS = ::T.let(nil, ::T.untyped)
  ENABLE_ALIASES = ::T.let(nil, ::T.untyped)
  HASCHILDREN = ::T.let(nil, ::T.untyped)
  HASNOCHILDREN = ::T.let(nil, ::T.untyped)
  HAS_CHILDREN = ::T.let(nil, ::T.untyped)
  HAS_NO_CHILDREN = ::T.let(nil, ::T.untyped)
  JUNK = ::T.let(nil, ::T.untyped)
  NONEXISTENT = ::T.let(nil, ::T.untyped)
  NO_INFERIORS = ::T.let(nil, ::T.untyped)
  NO_SELECT = ::T.let(nil, ::T.untyped)
  REMOTE = ::T.let(nil, ::T.untyped)
  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
  SENT = ::T.let(nil, ::T.untyped)
  STRFDATE = ::T.let(nil, ::T.untyped)
  STRFTIME = ::T.let(nil, ::T.untyped)
  SUBSCRIBED = ::T.let(nil, ::T.untyped)
  TRASH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::Authenticators
  def add_authenticator(*arg, **arg1, &arg2); end

  def authenticator(*arg, **arg1, &arg2); end
end

module Net::IMAP::Authenticators
end

module Net::IMAP::BodyStructure
end

module Net::IMAP::BodyStructure
end

class Net::IMAP::BodyTypeBasic
  include ::Net::IMAP::BodyStructure
end

class Net::IMAP::BodyTypeMessage
  include ::Net::IMAP::BodyStructure
end

class Net::IMAP::BodyTypeMultipart
  include ::Net::IMAP::BodyStructure
end

class Net::IMAP::BodyTypeText
  include ::Net::IMAP::BodyStructure
end

class Net::IMAP::ClientID
  def initialize(data); end

  def send_data(imap, tag); end

  def validate(); end
end

class Net::IMAP::ClientID
end

module Net::IMAP::DeprecatedClientOptions
  def initialize(host, port_or_options=T.unsafe(nil), *deprecated, **options); end

  def starttls(*deprecated, **options); end
end

module Net::IMAP::DeprecatedClientOptions
end

class Net::IMAP::ExtensionData
end

class Net::IMAP::ExtensionData
end

class Net::IMAP::FetchData
  def attr_upcase(); end

  def binary(*part_nums, offset: T.unsafe(nil)); end

  def binary_size(*part_nums); end

  def body(); end

  def body_structure(); end

  def bodystructure(); end

  def emailid(); end

  def envelope(); end

  def flags(); end

  def header(*part_nums, fields: T.unsafe(nil), except: T.unsafe(nil), offset: T.unsafe(nil)); end

  def header_fields(first, *rest, part: T.unsafe(nil), offset: T.unsafe(nil)); end

  def header_fields_not(first, *rest, part: T.unsafe(nil), offset: T.unsafe(nil)); end

  def internal_date(); end

  def internaldate(); end

  def message(offset: T.unsafe(nil)); end

  def mime(part, *subparts, offset: T.unsafe(nil)); end

  def modseq(); end

  def part(index, *subparts, offset: T.unsafe(nil)); end

  def rfc822(); end

  def rfc822_header(); end

  def rfc822_size(); end

  def rfc822_text(); end

  def text(*part, offset: T.unsafe(nil)); end

  def threadid(); end

  def uid(); end
end

class Net::IMAP::IgnoredResponse
end

class Net::IMAP::IgnoredResponse
end

class Net::IMAP::InvalidResponseError
end

class Net::IMAP::InvalidResponseError
end

class Net::IMAP::Namespace
end

class Net::IMAP::Namespace
end

class Net::IMAP::Namespaces
end

class Net::IMAP::Namespaces
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

class Net::IMAP::ResponseParser
  include ::Net::IMAP::ResponseParser::ParserUtils
  include ::Net::IMAP::ResponseParser::ResponseConditions
  def CRLF!(); end

  def CRLF?(); end

  def EOF!(); end

  def EOF?(); end

  def NIL!(); end

  def NIL?(); end

  def PLUS!(); end

  def PLUS?(); end

  def SP!(); end

  def SP?(); end

  def STAR!(); end

  def STAR?(); end

  def body_fld_enc(); end

  def body_fld_lines(); end

  def body_fld_octets(); end

  def case_insensitive__string(); end

  def case_insensitive__string?(); end

  def date_time(); end

  def lbra(); end

  def lbra?(); end

  def lookahead_CRLF!(); end

  def lookahead_EOF!(); end

  def lookahead_NIL!(); end

  def lookahead_PLUS?(); end

  def lookahead_SP?(); end

  def lookahead_STAR?(); end

  def lookahead_body?(); end

  def lookahead_case_insensitive__string!(); end

  def lookahead_lbra?(); end

  def lookahead_lpar?(); end

  def lookahead_number!(); end

  def lookahead_quoted!(); end

  def lookahead_rbra?(); end

  def lookahead_rpar?(); end

  def lookahead_string!(); end

  def lookahead_string8!(); end

  def lookahead_tagged_ext_label!(); end

  def lookahead_thread_list?(); end

  def lookahead_thread_nested?(); end

  def lpar(); end

  def lpar?(); end

  def media_subtype(); end

  def mod_sequence_value(); end

  def mod_sequence_valzer(); end

  def number(); end

  def number64(); end

  def number64?(); end

  def number?(); end

  def nz_number(); end

  def nz_number64(); end

  def nz_number?(); end

  def peek_PLUS?(); end

  def peek_SP?(); end

  def peek_STAR?(); end

  def peek_lbra?(); end

  def peek_lpar?(); end

  def peek_rbra?(); end

  def peek_rpar?(); end

  def permsg_modsequence(); end

  def quirky_SP?(); end

  def quoted(); end

  def quoted?(); end

  def rbra(); end

  def rbra?(); end

  def rpar(); end

  def rpar?(); end

  def string(); end

  def string8(); end

  def string8?(); end

  def string?(); end

  def tagged_ext_label(); end

  def tagged_ext_label?(); end

  def uniqueid(); end

  def x_gm_id(); end
  ASTRING_CHARS_TOKENS = ::T.let(nil, ::T.untyped)
  ASTRING_TOKENS = ::T.let(nil, ::T.untyped)
  RE_RESPONSE_TYPE = ::T.let(nil, ::T.untyped)
  SEQUENCE_SET_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_TOKENS = ::T.let(nil, ::T.untyped)
  T_LITERAL8 = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::ParserUtils
end

module Net::IMAP::ResponseParser::ParserUtils::Generator
  def def_char_matchers(name, char, token); end

  def def_token_matchers(name, *token_symbols, coerce: T.unsafe(nil), send: T.unsafe(nil)); end
  LOOKAHEAD = ::T.let(nil, ::T.untyped)
  SHIFT_TOKEN = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::ParserUtils::Generator
end

module Net::IMAP::ResponseParser::ParserUtils
end

module Net::IMAP::ResponseParser::Patterns
  include ::Net::IMAP::ResponseParser::Patterns::RFC5234
  include ::Net::IMAP::ResponseParser::Patterns::RFC3629
  ASTRING_CHAR = ::T.let(nil, ::T.untyped)
  ASTRING_CHARS = ::T.let(nil, ::T.untyped)
  ASTRING_SPECIALS = ::T.let(nil, ::T.untyped)
  ATOM = ::T.let(nil, ::T.untyped)
  ATOMISH = ::T.let(nil, ::T.untyped)
  ATOM_CHAR = ::T.let(nil, ::T.untyped)
  ATOM_SPECIALS = ::T.let(nil, ::T.untyped)
  CHAR8 = ::T.let(nil, ::T.untyped)
  CODE_TEXT = ::T.let(nil, ::T.untyped)
  CODE_TEXT_CHAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  FLAG_EXTENSION = ::T.let(nil, ::T.untyped)
  FLAG_KEYWORD = ::T.let(nil, ::T.untyped)
  FLAG_LIST = ::T.let(nil, ::T.untyped)
  FLAG_PERM = ::T.let(nil, ::T.untyped)
  FLAG_PERM_LIST = ::T.let(nil, ::T.untyped)
  LIST_WILDCARDS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  LITERAL8 = ::T.let(nil, ::T.untyped)
  MBX_FLAG = ::T.let(nil, ::T.untyped)
  MBX_LIST_FLAGS = ::T.let(nil, ::T.untyped)
  NZ_NUMBER = ::T.let(nil, ::T.untyped)
  QUIRKY_FLAG = ::T.let(nil, ::T.untyped)
  QUIRKY_FLAGS_LIST = ::T.let(nil, ::T.untyped)
  QUOTED_CHAR_esc = ::T.let(nil, ::T.untyped)
  QUOTED_CHAR_rev1 = ::T.let(nil, ::T.untyped)
  QUOTED_CHAR_rev2 = ::T.let(nil, ::T.untyped)
  QUOTED_CHAR_safe = ::T.let(nil, ::T.untyped)
  QUOTED_SPECIALS = ::T.let(nil, ::T.untyped)
  QUOTED_rev1 = ::T.let(nil, ::T.untyped)
  QUOTED_rev2 = ::T.let(nil, ::T.untyped)
  RESP_SPECIALS = ::T.let(nil, ::T.untyped)
  SEQUENCE_SET = ::T.let(nil, ::T.untyped)
  SEQUENCE_SET_ITEM = ::T.let(nil, ::T.untyped)
  SEQUENCE_SET_STR = ::T.let(nil, ::T.untyped)
  SEQ_NUMBER = ::T.let(nil, ::T.untyped)
  SEQ_RANGE = ::T.let(nil, ::T.untyped)
  TAG = ::T.let(nil, ::T.untyped)
  TAGGED_EXT_LABEL = ::T.let(nil, ::T.untyped)
  TAGGED_LABEL_CHAR = ::T.let(nil, ::T.untyped)
  TAGGED_LABEL_FCHAR = ::T.let(nil, ::T.untyped)
  TEXT_CHAR = ::T.let(nil, ::T.untyped)
  TEXT_rev1 = ::T.let(nil, ::T.untyped)
  TEXT_rev2 = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::Patterns::CharClassSubtraction
end

module Net::IMAP::ResponseParser::Patterns::CharClassSubtraction
end

module Net::IMAP::ResponseParser::Patterns::RFC3629
  UTF8_1 = ::T.let(nil, ::T.untyped)
  UTF8_2 = ::T.let(nil, ::T.untyped)
  UTF8_3 = ::T.let(nil, ::T.untyped)
  UTF8_4 = ::T.let(nil, ::T.untyped)
  UTF8_CHAR = ::T.let(nil, ::T.untyped)
  UTF8_OCTETS = ::T.let(nil, ::T.untyped)
  UTF8_TAIL = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::Patterns::RFC3629
end

module Net::IMAP::ResponseParser::Patterns::RFC5234
  ALPHA = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CTL = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DQUOTE = ::T.let(nil, ::T.untyped)
  HEXDIG = ::T.let(nil, ::T.untyped)
  OCTET = ::T.let(nil, ::T.untyped)
  SP = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::Patterns::RFC5234
end

module Net::IMAP::ResponseParser::Patterns
  def self.unescape_quoted(quoted); end

  def self.unescape_quoted!(quoted); end
end

module Net::IMAP::ResponseParser::ResponseConditions
  AUTH_CONDS = ::T.let(nil, ::T.untyped)
  BAD = ::T.let(nil, ::T.untyped)
  BYE = ::T.let(nil, ::T.untyped)
  GREETING_CONDS = ::T.let(nil, ::T.untyped)
  NO = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  PREAUTH = ::T.let(nil, ::T.untyped)
  RESP_CONDS = ::T.let(nil, ::T.untyped)
  RESP_COND_STATES = ::T.let(nil, ::T.untyped)
  RESP_DATA_CONDS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::ResponseParser::ResponseConditions
end

class Net::IMAP::ResponseParser::Token
  def self.keyword_init?(); end
end

class Net::IMAP::ResponseParser
  extend ::Net::IMAP::ResponseParser::ParserUtils::Generator
end

class Net::IMAP::ResponseText
  EMPTY = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::SASL
end

class Net::IMAP::SASL::AnonymousAuthenticator
  def anonymous_message(); end

  def done?(); end

  def initial_response?(); end

  def initialize(anon_msg=T.unsafe(nil), anonymous_message: T.unsafe(nil), **arg); end

  def process(_server_challenge_string); end
end

class Net::IMAP::SASL::AnonymousAuthenticator
end

class Net::IMAP::SASL::AuthenticationCanceled
end

class Net::IMAP::SASL::AuthenticationCanceled
end

class Net::IMAP::SASL::AuthenticationError
end

class Net::IMAP::SASL::AuthenticationError
end

class Net::IMAP::SASL::AuthenticationExchange
  def authenticate(); end

  def authenticator(); end

  def done?(); end

  def initialize(client, mechanism, authenticator, sasl_ir: T.unsafe(nil)); end

  def mechanism(); end

  def send_initial_response?(); end
end

class Net::IMAP::SASL::AuthenticationExchange
  def self.authenticate(*arg, **arg1, &arg2); end

  def self.build(client, mechanism, *args, sasl_ir: T.unsafe(nil), **kwargs, &block); end
end

class Net::IMAP::SASL::AuthenticationFailed
end

class Net::IMAP::SASL::AuthenticationFailed
end

class Net::IMAP::SASL::AuthenticationIncomplete
  def initialize(response, message=T.unsafe(nil)); end

  def response(); end
end

class Net::IMAP::SASL::AuthenticationIncomplete
end

class Net::IMAP::SASL::Authenticators
  def add_authenticator(name, authenticator=T.unsafe(nil)); end

  def authenticator(mechanism, *arg, **arg1, &arg2); end

  def initialize(use_defaults: T.unsafe(nil), use_deprecated: T.unsafe(nil)); end

  def mechanism?(name); end

  def names(); end

  def new(mechanism, *arg, **arg1, &arg2); end

  def remove_authenticator(name); end
end

class Net::IMAP::SASL::Authenticators
end

Net::IMAP::SASL::BidiStringError = Net::IMAP::StringPrep::BidiStringError

class Net::IMAP::SASL::ClientAdapter
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  def auth_capable?(mechanism); end

  def authenticate(*arg, **arg1, &arg2); end

  def client(); end

  def command_proc(); end

  def drop_connection(); end

  def drop_connection!(); end

  def initialize(client, &command_proc); end

  def response_errors(); end

  def run_command(mechanism, initial_response=T.unsafe(nil), &block); end

  def sasl_ir_capable?(); end
end

class Net::IMAP::SASL::ClientAdapter
end

class Net::IMAP::SASL::CramMD5Authenticator
  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), pass=T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **arg); end

  def process(challenge); end
end

class Net::IMAP::SASL::CramMD5Authenticator
end

class Net::IMAP::SASL::DigestMD5Authenticator
  def authcid(); end

  def authzid(); end

  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), pass=T.unsafe(nil), authz=T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), authzid: T.unsafe(nil), authcid: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **arg); end

  def password(); end

  def process(challenge); end

  def username(); end
end

class Net::IMAP::SASL::DigestMD5Authenticator
end

class Net::IMAP::SASL::Error
end

class Net::IMAP::SASL::Error
end

class Net::IMAP::SASL::ExternalAuthenticator
  def authzid(); end

  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), authzid: T.unsafe(nil), username: T.unsafe(nil), **arg); end

  def process(_); end

  def username(); end
end

class Net::IMAP::SASL::ExternalAuthenticator
end

module Net::IMAP::SASL::GS2Header
  def gs2_authzid(); end

  def gs2_cb_flag(); end

  def gs2_header(); end
  NO_NULL_CHARS = ::T.let(nil, ::T.untyped)
  RFC5801_SASLNAME = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::SASL::GS2Header
  def self.gs2_saslname_encode(str); end
end

class Net::IMAP::SASL::LoginAuthenticator
  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), pass=T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), warn_deprecation: T.unsafe(nil), **arg); end

  def process(data); end
end

class Net::IMAP::SASL::LoginAuthenticator
end

class Net::IMAP::SASL::OAuthAuthenticator
  include ::Net::IMAP::SASL::GS2Header
  def authorization(); end

  def authzid(); end

  def done?(); end

  def host(); end

  def initial_client_response(); end

  def initialize(authzid: T.unsafe(nil), host: T.unsafe(nil), port: T.unsafe(nil), username: T.unsafe(nil), query: T.unsafe(nil), mthd: T.unsafe(nil), path: T.unsafe(nil), post: T.unsafe(nil), qs: T.unsafe(nil), **arg); end

  def last_server_response(); end

  def mthd(); end

  def path(); end

  def port(); end

  def post(); end

  def process(data); end

  def qs(); end

  def query(); end

  def username(); end
end

class Net::IMAP::SASL::OAuthAuthenticator
end

class Net::IMAP::SASL::OAuthBearerAuthenticator
  def initial_response?(); end

  def initialize(arg1=T.unsafe(nil), arg2=T.unsafe(nil), oauth2_token: T.unsafe(nil), secret: T.unsafe(nil), **args, &blk); end

  def oauth2_token(); end

  def secret(); end
end

class Net::IMAP::SASL::OAuthBearerAuthenticator
end

class Net::IMAP::SASL::PlainAuthenticator
  def authcid(); end

  def authzid(); end

  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), pass=T.unsafe(nil), authcid: T.unsafe(nil), secret: T.unsafe(nil), username: T.unsafe(nil), password: T.unsafe(nil), authzid: T.unsafe(nil), **arg); end

  def password(); end

  def process(data); end

  def secret(); end

  def username(); end
end

class Net::IMAP::SASL::PlainAuthenticator
end

Net::IMAP::SASL::ProhibitedCodepoint = Net::IMAP::StringPrep::ProhibitedCodepoint

module Net::IMAP::SASL::ProtocolAdapters
end

module Net::IMAP::SASL::ProtocolAdapters::Generic
  def cancel_response(); end

  def command_name(); end

  def decode(string); end

  def encode(string); end

  def encode_ir(string); end

  def host(); end

  def port(); end

  def service(); end
end

module Net::IMAP::SASL::ProtocolAdapters::Generic
end

module Net::IMAP::SASL::ProtocolAdapters::IMAP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  def service(); end
end

module Net::IMAP::SASL::ProtocolAdapters::IMAP
end

module Net::IMAP::SASL::ProtocolAdapters::POP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  def command_name(); end

  def service(); end
end

module Net::IMAP::SASL::ProtocolAdapters::POP
end

module Net::IMAP::SASL::ProtocolAdapters::SMTP
  include ::Net::IMAP::SASL::ProtocolAdapters::Generic
  def command_name(); end

  def service(); end
end

module Net::IMAP::SASL::ProtocolAdapters::SMTP
end

module Net::IMAP::SASL::ProtocolAdapters
end

Net::IMAP::SASL::SASLprep = Net::IMAP::StringPrep::SASLprep

module Net::IMAP::SASL::ScramAlgorithm
  def H(str); end

  def HMAC(key, data); end

  def Hi(str, salt, iterations); end

  def Normalize(str); end

  def XOR(str1, str2); end

  def auth_message(); end

  def client_key(); end

  def client_proof(); end

  def client_signature(); end

  def salted_password(); end

  def server_key(); end

  def server_signature(); end

  def stored_key(); end
end

module Net::IMAP::SASL::ScramAlgorithm
end

class Net::IMAP::SASL::ScramAuthenticator
  include ::Net::IMAP::SASL::GS2Header
  include ::Net::IMAP::SASL::ScramAlgorithm
  def authcid(); end

  def authzid(); end

  def cbind_input(); end

  def cnonce(); end

  def digest(); end

  def done?(); end

  def initial_client_response(); end

  def initialize(username_arg=T.unsafe(nil), password_arg=T.unsafe(nil), authcid: T.unsafe(nil), username: T.unsafe(nil), authzid: T.unsafe(nil), password: T.unsafe(nil), secret: T.unsafe(nil), min_iterations: T.unsafe(nil), cnonce: T.unsafe(nil), **options); end

  def iterations(); end

  def min_iterations(); end

  def password(); end

  def process(challenge); end

  def salt(); end

  def secret(); end

  def server_error(); end

  def snonce(); end

  def username(); end
end

class Net::IMAP::SASL::ScramAuthenticator
end

class Net::IMAP::SASL::ScramSHA1Authenticator
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::SASL::ScramSHA1Authenticator
end

class Net::IMAP::SASL::ScramSHA256Authenticator
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::SASL::ScramSHA256Authenticator
end

Net::IMAP::SASL::StringPrep = Net::IMAP::StringPrep

Net::IMAP::SASL::StringPrepError = Net::IMAP::StringPrep::StringPrepError

class Net::IMAP::SASL::XOAuth2Authenticator
  def authzid(); end

  def done?(); end

  def initial_response?(); end

  def initialize(user=T.unsafe(nil), token=T.unsafe(nil), username: T.unsafe(nil), oauth2_token: T.unsafe(nil), authzid: T.unsafe(nil), secret: T.unsafe(nil), **arg); end

  def oauth2_token(); end

  def process(_data); end

  def secret(); end

  def username(); end
end

class Net::IMAP::SASL::XOAuth2Authenticator
end

module Net::IMAP::SASL
  def self.add_authenticator(*arg, **arg1, &arg2); end

  def self.authenticator(*args, registry: T.unsafe(nil), **kwargs, &block); end

  def self.authenticators(); end

  def self.saslprep(string, **opts); end
end

class Net::IMAP::SASLAdapter
  include ::Net::IMAP::SASL::ProtocolAdapters::IMAP
  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::SASLAdapter
end

class Net::IMAP::SearchResult
  def ==(other); end

  def eql?(other); end

  def initialize(seq_nums, modseq: T.unsafe(nil)); end

  def modseq(); end

  def pretty_print(pp); end

  def to_s(type=T.unsafe(nil)); end

  def to_sequence_set(); end
end

class Net::IMAP::SearchResult
  def self.[](*seq_nums, modseq: T.unsafe(nil)); end
end

class Net::IMAP::SequenceSet
  def &(other); end

  def +(other); end

  def -(other); end

  def <<(object); end

  def ==(other); end

  def ===(other); end

  def [](index, length=T.unsafe(nil)); end

  def ^(other); end

  def add(object); end

  def add?(object); end

  def append(object); end

  def at(index); end

  def clear(); end

  def complement(); end

  def complement!(); end

  def count(); end

  def cover?(other); end

  def delete(object); end

  def delete?(object); end

  def delete_at(index); end

  def difference(other); end

  def disjoint?(other); end

  def each_element(); end

  def each_entry(&block); end

  def each_number(&block); end

  def each_range(); end

  def elements(); end

  def empty?(); end

  def entries(); end

  def eql?(other); end

  def find_index(number); end

  def full?(); end

  def include?(element); end

  def include_star?(); end

  def initialize(input=T.unsafe(nil)); end

  def intersect?(other); end

  def intersection(other); end

  def limit(max:); end

  def limit!(max:); end

  def max(star: T.unsafe(nil)); end

  def member?(element); end

  def merge(*inputs); end

  def min(star: T.unsafe(nil)); end

  def minmax(star: T.unsafe(nil)); end

  def normalize(); end

  def normalize!(); end

  def normalized_string(); end

  def numbers(); end

  def overlap?(other); end

  def ranges(); end

  def replace(other); end

  def send_data(imap, tag); end

  def size(); end

  def slice(index, length=T.unsafe(nil)); end

  def slice!(index, length=T.unsafe(nil)); end

  def string(); end

  def string=(str); end

  def subtract(*objects); end

  def to_a(); end

  def to_sequence_set(); end

  def to_set(); end

  def tuples(); end

  def union(other); end

  def valid?(); end

  def valid_string(); end

  def validate(); end

  def xor(other); end

  def |(other); end

  def ~(); end
  UINT32_MAX = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::SequenceSet
  def self.[](first, *rest); end

  def self.empty(); end

  def self.full(); end

  def self.try_convert(obj); end
end

module Net::IMAP::StringFormatter
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringFormatter
  def self.nstring(str); end

  def self.string(str); end

  def self.valid_nstring?(str); end

  def self.valid_string?(str); end
end

module Net::IMAP::StringPrep
end

class Net::IMAP::StringPrep::BidiStringError
end

class Net::IMAP::StringPrep::BidiStringError
end

module Net::IMAP::StringPrep::NamePrep
  CHECK_BIDI = ::T.let(nil, ::T.untyped)
  MAPPING_TABLES = ::T.let(nil, ::T.untyped)
  NORMALIZATION = ::T.let(nil, ::T.untyped)
  PROHIBITED_TABLES = ::T.let(nil, ::T.untyped)
  STRINGPREP_PROFILE = ::T.let(nil, ::T.untyped)
  UNASSIGNED_TABLE = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringPrep::NamePrep
  def self.nameprep(string, **opts); end
end

class Net::IMAP::StringPrep::ProhibitedCodepoint
  def initialize(table, *args, **kwargs); end

  def table(); end
end

class Net::IMAP::StringPrep::ProhibitedCodepoint
end

module Net::IMAP::StringPrep::SASLprep
  ASCII_NO_CTRLS = ::T.let(nil, ::T.untyped)
  BIDI_FAILURE = ::T.let(nil, ::T.untyped)
  MAP_TO_NOTHING = ::T.let(nil, ::T.untyped)
  MAP_TO_SPACE = ::T.let(nil, ::T.untyped)
  PROHIBITED = ::T.let(nil, ::T.untyped)
  PROHIBITED_OUTPUT = ::T.let(nil, ::T.untyped)
  PROHIBITED_OUTPUT_STORED = ::T.let(nil, ::T.untyped)
  PROHIBITED_STORED = ::T.let(nil, ::T.untyped)
  TABLES_PROHIBITED = ::T.let(nil, ::T.untyped)
  TABLES_PROHIBITED_STORED = ::T.let(nil, ::T.untyped)
  UNASSIGNED = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringPrep::SASLprep
  def self.saslprep(str, stored: T.unsafe(nil), exception: T.unsafe(nil)); end
end

class Net::IMAP::StringPrep::StringPrepError
  def initialize(*args, string: T.unsafe(nil), profile: T.unsafe(nil)); end

  def profile(); end

  def string(); end
end

class Net::IMAP::StringPrep::StringPrepError
end

module Net::IMAP::StringPrep::Tables
  BIDI_DESC_REQ2 = ::T.let(nil, ::T.untyped)
  BIDI_DESC_REQ3 = ::T.let(nil, ::T.untyped)
  BIDI_FAILS_REQ2 = ::T.let(nil, ::T.untyped)
  BIDI_FAILS_REQ3 = ::T.let(nil, ::T.untyped)
  BIDI_FAILURE = ::T.let(nil, ::T.untyped)
  IN_A_1 = ::T.let(nil, ::T.untyped)
  IN_B_1 = ::T.let(nil, ::T.untyped)
  IN_B_2 = ::T.let(nil, ::T.untyped)
  IN_B_3 = ::T.let(nil, ::T.untyped)
  IN_C_1_1 = ::T.let(nil, ::T.untyped)
  IN_C_1_2 = ::T.let(nil, ::T.untyped)
  IN_C_2_1 = ::T.let(nil, ::T.untyped)
  IN_C_2_2 = ::T.let(nil, ::T.untyped)
  IN_C_3 = ::T.let(nil, ::T.untyped)
  IN_C_4 = ::T.let(nil, ::T.untyped)
  IN_C_5 = ::T.let(nil, ::T.untyped)
  IN_C_6 = ::T.let(nil, ::T.untyped)
  IN_C_7 = ::T.let(nil, ::T.untyped)
  IN_C_8 = ::T.let(nil, ::T.untyped)
  IN_C_9 = ::T.let(nil, ::T.untyped)
  IN_D_1 = ::T.let(nil, ::T.untyped)
  IN_D_1_NEGATED = ::T.let(nil, ::T.untyped)
  IN_D_2 = ::T.let(nil, ::T.untyped)
  MAPPINGS = ::T.let(nil, ::T.untyped)
  MAP_B_1 = ::T.let(nil, ::T.untyped)
  MAP_B_2 = ::T.let(nil, ::T.untyped)
  MAP_B_3 = ::T.let(nil, ::T.untyped)
  REGEXPS = ::T.let(nil, ::T.untyped)
  TITLES = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringPrep::Tables
end

module Net::IMAP::StringPrep::Trace
  CHECK_BIDI = ::T.let(nil, ::T.untyped)
  MAPPING_TABLES = ::T.let(nil, ::T.untyped)
  NORMALIZATION = ::T.let(nil, ::T.untyped)
  PROHIBITED_TABLES = ::T.let(nil, ::T.untyped)
  STRINGPREP_PROFILE = ::T.let(nil, ::T.untyped)
  UNASSIGNED_TABLE = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::StringPrep::Trace
  def self.stringprep_trace(string, **opts); end
end

module Net::IMAP::StringPrep
  def self.[](table); end

  def self.check_bidi!(string, c_8: T.unsafe(nil), profile: T.unsafe(nil)); end

  def self.check_prohibited!(string, *tables, bidi: T.unsafe(nil), unassigned: T.unsafe(nil), stored: T.unsafe(nil), profile: T.unsafe(nil)); end

  def self.map_tables!(string, *tables); end

  def self.stringprep(string, maps:, normalization:, prohibited:, **opts); end
end

class Net::IMAP::ThreadMember
  def all_seqnos(node=T.unsafe(nil)); end

  def to_sequence_set(); end
end

class Net::IMAP::UIDPlusData
  def uid_mapping(); end
end

class Net::IMAP::UIDPlusData
end

class Net::IMAP::UnknownResponseError
end

class Net::IMAP::UnknownResponseError
end

class Net::IMAP::UnparsedData
end

class Net::IMAP::UnparsedData
end

class Net::IMAP::UnparsedNumericResponseData
end

class Net::IMAP::UnparsedNumericResponseData
end

Net::IMAP::XOauth2Authenticator = Net::IMAP::SASL::XOAuth2Authenticator

class Net::IMAP
  extend ::Net::IMAP::Authenticators
  def self.decode_date(string); end

  def self.decode_datetime(string); end

  def self.decode_time(string); end

  def self.encode_date(date); end

  def self.encode_datetime(time); end

  def self.encode_time(time); end

  def self.format_time(time); end

  def self.parse_date(string); end

  def self.parse_datetime(string); end

  def self.parse_time(string); end

  def self.saslprep(string, **opts); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::SMTP
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::SMTP::AuthCramMD5
  CRAM_BUFSIZE = ::T.let(nil, ::T.untyped)
  IMASK = ::T.let(nil, ::T.untyped)
  OMASK = ::T.let(nil, ::T.untyped)
end

Net::SMTPSession = Net::SMTP

class Net::SSH::Authentication::Agent
  def lock(password); end

  def unlock(password); end
  SSH2_AGENT_LOCK = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_UNLOCK = ::T.let(nil, ::T.untyped)
end

module Net::SSH::Authentication::ED25519Loader
  ERROR = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Authentication::KeyManager
  def add_keycert(keycert_file); end

  def add_keycert_data(keycert_data_); end

  def keycert_data(); end

  def keycert_files(); end
end

class Net::SSH::Authentication::Methods::Abstract
  def pubkey_algorithms(); end
end

class Net::SSH::HostKeyEntries::CertAuthority
  def initialize(key, comment: T.unsafe(nil)); end

  def matches_key?(server_key); end

  def ssh_types(); end
end

class Net::SSH::HostKeyEntries::PubKey
  def initialize(key, comment: T.unsafe(nil)); end

  def matches_key?(server_key); end

  def ssh_type(); end

  def ssh_types(); end

  def to_blob(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Net::SSH::KnownHosts
  def match(host, pattern); end
end

class Net::SSH::Proxy::Command
  def close_on_error(io); end

  def command_line(); end

  def command_line_template(); end

  def initialize(command_line_template); end

  def open(host, port, connection_options=T.unsafe(nil)); end

  def timeout(); end

  def timeout=(timeout); end
end

class Net::SSH::Service::Forward::Remote
  def self.keyword_init?(); end
end

class Net::SSH::Transport::Algorithms
  DEFAULT_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

module Net::SSH::Transport::ChaCha20Poly1305CipherLoader
  ERROR = ::T.let(nil, ::T.untyped)
  LOADED = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Transport::CipherFactory
  SSH_TO_CLASS = ::T.let(nil, ::T.untyped)
end

module Net::SSH::Transport::Constants
  KEXDH_GEX_GROUP = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_INIT = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_REPLY = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_REQUEST = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Transport::HMAC::Abstract
  def etm(); end
end

class Net::SSH::Transport::HMAC::Abstract
  def self.etm(*v); end
end

class Net::SSH::Transport::IdentityCipher
  def self.implicit_mac?(); end

  def self.key_length(); end
end

class Net::SSH::Transport::Kex::Abstract
  def algorithms(); end

  def connection(); end

  def data(); end

  def dh(); end

  def digester(); end

  def exchange_keys(); end

  def initialize(algorithms, connection, data); end
end

class Net::SSH::Transport::Kex::Abstract5656
  def curve_name(); end

  def ecdh(); end
end

module Net::SSH::Transport::Kex::Curve25519Sha256Loader
  ERROR = ::T.let(nil, ::T.untyped)
  LOADED = ::T.let(nil, ::T.untyped)
end

module Net::SSH::Transport::Kex::Curve25519Sha256Loader
  def self.dependenciesRequiredForX25519(); end

  def self.raiseUnlessLoaded(message); end
end

class Net::SSH::Transport::OpenSSLAESCTR
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Net::SSH::Transport::OpenSSLCipherExtensions
  def implicit_mac?(); end
end

class Net::SSH::Version
  PRE = ::T.let(nil, ::T.untyped)
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Netrc
  def [](k); end

  def []=(k, info); end

  def delete(key); end

  def each(&block); end

  def initialize(path, data); end

  def length(); end

  def new_item(m, l, p); end

  def new_item_prefix(); end

  def new_item_prefix=(new_item_prefix); end

  def save(); end

  def unparse(); end
  CYGWIN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Netrc::Entry
  def login(); end

  def login=(_); end

  def password(); end

  def password=(_); end

  def to_ary(); end
end

class Netrc::Entry
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Netrc::TokenArray
  def readto(); end

  def take(); end
end

class Netrc
  def self.check_permissions(path); end

  def self.config(); end

  def self.configure(); end

  def self.default_path(); end

  def self.home_path(); end

  def self.lex(lines); end

  def self.netrc_filename(); end

  def self.parse(ts); end

  def self.read(path=T.unsafe(nil)); end

  def self.skip?(s); end
end

class NilClass
  def =~(arg); end
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NoMatchingPatternKeyError
end

module Nokogiri
  LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  LIBXML_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_MEMORY_MANAGEMENT = ::T.let(nil, ::T.untyped)
  LIBXSLT_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_DATETIME_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXSLT_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  OTHER_LIBRARY_VERSIONS = ::T.let(nil, ::T.untyped)
  PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  PRECOMPILED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  CACHE_SWITCH_NAME = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::XPathVisitor
  WILDCARD_NAMESPACES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS::XPathVisitor::BuiltinsConfig
  ALWAYS = ::T.let(nil, ::T.untyped)
  NEVER = ::T.let(nil, ::T.untyped)
  OPTIMAL = ::T.let(nil, ::T.untyped)
  VALUES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS::XPathVisitor::DoctypeConfig
  HTML4 = ::T.let(nil, ::T.untyped)
  HTML5 = ::T.let(nil, ::T.untyped)
  VALUES = ::T.let(nil, ::T.untyped)
  XML = ::T.let(nil, ::T.untyped)
end

module Nokogiri::ClassResolver
  VALID_NAMESPACES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

class Nokogiri::EncodingHandler
  USEFUL_ALIASES = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Gumbo
  DEFAULT_MAX_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_ERRORS = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_TREE_DEPTH = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML = Nokogiri::HTML4

module Nokogiri::HTML4
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML4::ElementDescription
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML4::ElementDescription::Desc = Struct::HTMLElementDescription

module Nokogiri::HTML5::QuirksMode
  LIMITED_QUIRKS = ::T.let(nil, ::T.untyped)
  NO_QUIRKS = ::T.let(nil, ::T.untyped)
  QUIRKS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Builder
  DEFAULT_DOCUMENT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
  include ::Nokogiri::HTML5::Node
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DECONSTRUCT_KEYS = ::T.let(nil, ::T.untyped)
  DECONSTRUCT_METHODS = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::PP::Node
  COLLECTIONS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
  BIG_LINES = ::T.let(nil, ::T.untyped)
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEMA = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DEFAULT_XSLT = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::XPath
  CURRENT_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  ROOT_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
  SUBTREE_SEARCH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Notiffany
  VERSION = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier
  def active?(); end

  def available(); end

  def config(); end

  def disconnect(); end

  def enabled?(); end

  def initialize(opts); end

  def notify(message, message_opts=T.unsafe(nil)); end

  def turn_off(); end

  def turn_on(options=T.unsafe(nil)); end
  NOTIFICATIONS_DISABLED = ::T.let(nil, ::T.untyped)
  ONLY_NOTIFY = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
  USING_NOTIFIER = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Base
  def _image_path(image); end

  def initialize(opts=T.unsafe(nil)); end

  def name(); end

  def notify(message, opts=T.unsafe(nil)); end

  def options(); end

  def title(); end
  ERROR_ADD_GEM_AND_RUN_BUNDLE = ::T.let(nil, ::T.untyped)
  HOSTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Base::RequireFailed
  def initialize(gem_name); end
end

class Notiffany::Notifier::Base::UnavailableError
  def initialize(reason); end
end

class Notiffany::Notifier::Base::UnsupportedPlatform
  def initialize(); end
end

class Notiffany::Notifier::Config
  def env_namespace(); end

  def initialize(opts); end

  def logger(); end

  def notifiers(); end

  def notify?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Detected
  def add(name, opts); end

  def available(); end

  def detect(); end

  def initialize(supported, env_namespace, logger); end

  def reset(); end
  NO_SUPPORTED_NOTIFIERS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Detected::UnknownNotifier
  def initialize(name); end

  def name(); end
end

class Notiffany::Notifier::Emacs
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_ELISP_ERB = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Emacs::Client
  def available?(); end

  def elisp_erb(); end

  def initialize(options); end

  def notify(color, bgcolor, message=T.unsafe(nil)); end
end

class Notiffany::Notifier::Emacs::Client::Elisp
  def bgcolor(); end

  def color(); end

  def initialize(code, color, bgcolor, message); end

  def message(); end

  def result(); end
end

class Notiffany::Notifier::Env
  def notify?(); end

  def notify_active=(raw_value); end

  def notify_active?(); end

  def notify_pid(); end

  def notify_pid=(raw_value); end
end

class Notiffany::Notifier::File
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::GNTP
  def _check_available(_opts); end

  def _perform_notify(message, opts=T.unsafe(nil)); end
  CLIENT_DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Growl
  def _check_available(_opts=T.unsafe(nil)); end

  def _perform_notify(message, opts=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INSTALL_GROWLNOTIFY = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Libnotify
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Notifu
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::NotifySend
  DEFAULTS = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::TerminalNotifier
  def _check_available(_opts=T.unsafe(nil)); end

  def _perform_notify(message, opts=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ERROR_ONLY_OSX10 = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::TerminalTitle
  def turn_off(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Tmux
  def turn_off(); end

  def turn_on(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ERROR_ANCIENT_TMUX = ::T.let(nil, ::T.untyped)
  ERROR_NOT_INSIDE_TMUX = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Tmux::Client
  def clients(); end

  def display_message(message); end

  def display_time=(time); end

  def initialize(client); end

  def message_bg=(color); end

  def message_fg=(color); end

  def parse_options(); end

  def set(key, value); end

  def title=(string); end

  def unset(key, value); end
  CLIENT = ::T.let(nil, ::T.untyped)
end

class Notiffany::Notifier::Tmux::Client
  def self._capture(*args); end

  def self._run(*args); end

  def self.version(); end
end

class Notiffany::Notifier::Tmux::Notification
  def colorize(locations); end

  def display_message(title, message); end

  def display_title(title, message); end

  def initialize(type, options); end
end

class Notiffany::Notifier::Tmux::Session
  def close(); end
end

class Notiffany::Notifier::Tmux
  def self._end_session(); end

  def self._session(); end

  def self._start_session(); end
end

class Notiffany::Notifier::YamlEnvStorage
  def notifiers(); end

  def notifiers=(raw_value); end
end

module Notiffany
  def self.connect(options=T.unsafe(nil)); end
end

class Numeric
  ZETTABYTE = ::T.let(nil, ::T.untyped)
end

module OTNetstring
  def self.encode(obj, string_sep=T.unsafe(nil)); end

  def self.parse(io, encoding=T.unsafe(nil), fallback_encoding=T.unsafe(nil)); end
end

class Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::RequireDependency
  include ::DEBUGGER__::TrapInterceptor
  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::InternalObjectWrapper
  def internal_object_id(); end

  def type(); end
end

class ObjectSpace::InternalObjectWrapper
end

class ObjectSpace::WeakMap
  def delete(arg); end
end

module ObjectSpace
  def self.allocation_class_path(arg); end

  def self.allocation_generation(arg); end

  def self.allocation_method_id(arg); end

  def self.allocation_sourcefile(arg); end

  def self.allocation_sourceline(arg); end

  def self.count_nodes(*arg); end

  def self.count_symbols(*arg); end

  def self.dump(obj, output: T.unsafe(nil)); end

  def self.dump_all(output: T.unsafe(nil), full: T.unsafe(nil), since: T.unsafe(nil), shapes: T.unsafe(nil)); end

  def self.dump_shapes(output: T.unsafe(nil), since: T.unsafe(nil)); end

  def self.internal_class_of(arg); end

  def self.internal_super_of(arg); end

  def self.reachable_objects_from(arg); end

  def self.reachable_objects_from_root(); end

  def self.trace_object_allocations(); end

  def self.trace_object_allocations_debug_start(); end
end

module Observable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Open3
  VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def abs(); end

  def get_flags(arg); end

  def mod_sqrt(arg); end

  def negative?(); end

  def set_flags(arg); end
  CONSTTIME = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def getbyte(); end
end

class OpenSSL::Buffering::Buffer
  def <<(string); end

  def concat(string); end

  def initialize(); end
  BINARY = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Buffering::Buffer
end

class OpenSSL::Cipher
  def ccm_data_len=(ccm_data_len); end
end

class OpenSSL::HMAC
  def ==(other); end
end

module OpenSSL::Marshal
  def _dump(_level); end
end

module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end

module OpenSSL::Marshal::ClassMethods
end

module OpenSSL::Marshal
  def self.included(base); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::DH
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DH
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::DSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::EC
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::EC::Point
  def add(arg); end

  def ssh_signature_type(); end

  def to_octet_string(arg); end
end

class OpenSSL::PKey::EC
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::PKey::PKey
  def compare?(arg); end

  def decrypt(*arg); end

  def derive(*arg); end

  def encrypt(*arg); end

  def oid(); end

  def private_to_der(*arg); end

  def private_to_pem(*arg); end

  def public_to_der(); end

  def public_to_pem(); end

  def raw_private_key(); end

  def raw_public_key(); end

  def sign_raw(*arg); end

  def to_text(); end

  def verify_raw(*arg); end

  def verify_recover(*arg); end
end

class OpenSSL::PKey::RSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::RSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

module OpenSSL::PKey
  def self.generate_key(*arg); end

  def self.generate_parameters(*arg); end

  def self.new_raw_private_key(arg, arg1); end

  def self.new_raw_public_key(arg, arg1); end
end

class OpenSSL::Provider
  def name(); end

  def unload(); end
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider
  def self.load(arg); end

  def self.provider_names(); end
end

module OpenSSL::SSL
  OP_ALLOW_CLIENT_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CLEANSE_PLAINTEXT = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_DISABLE_TLSEXT_CA_NAMES = ::T.let(nil, ::T.untyped)
  OP_ENABLE_KTLS = ::T.let(nil, ::T.untyped)
  OP_ENABLE_MIDDLEBOX_COMPAT = ::T.let(nil, ::T.untyped)
  OP_IGNORE_UNEXPECTED_EOF = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ANTI_REPLAY = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_PRIORITIZE_CHACHA = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Timestamp
end

class OpenSSL::Timestamp::Factory
  def additional_certs(); end

  def additional_certs=(additional_certs); end

  def allowed_digests(); end

  def allowed_digests=(allowed_digests); end

  def create_timestamp(arg, arg1, arg2); end

  def default_policy_id(); end

  def default_policy_id=(default_policy_id); end

  def gen_time(); end

  def gen_time=(gen_time); end

  def serial_number(); end

  def serial_number=(serial_number); end
end

class OpenSSL::Timestamp::Factory
end

class OpenSSL::Timestamp::Request
  def algorithm(); end

  def algorithm=(algorithm); end

  def cert_requested=(cert_requested); end

  def cert_requested?(); end

  def initialize(*arg); end

  def message_imprint(); end

  def message_imprint=(message_imprint); end

  def nonce(); end

  def nonce=(nonce); end

  def policy_id(); end

  def policy_id=(policy_id); end

  def to_der(); end

  def version(); end

  def version=(version); end
end

class OpenSSL::Timestamp::Request
end

class OpenSSL::Timestamp::Response
  def failure_info(); end

  def initialize(arg); end

  def status(); end

  def status_text(); end

  def to_der(); end

  def token(); end

  def token_info(); end

  def tsa_certificate(); end

  def verify(*arg); end
  GRANTED = ::T.let(nil, ::T.untyped)
  GRANTED_WITH_MODS = ::T.let(nil, ::T.untyped)
  REJECTION = ::T.let(nil, ::T.untyped)
  REVOCATION_NOTIFICATION = ::T.let(nil, ::T.untyped)
  REVOCATION_WARNING = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Timestamp::Response
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TokenInfo
  def algorithm(); end

  def gen_time(); end

  def initialize(arg); end

  def message_imprint(); end

  def nonce(); end

  def ordering(); end

  def policy_id(); end

  def serial_number(); end

  def to_der(); end

  def version(); end
end

class OpenSSL::Timestamp::TokenInfo
end

module OpenSSL::Timestamp
end

module OpenSSL::X509
  V_ERR_CA_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_CA_MD_TOO_WEAK = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_PATH_VALIDATION_ERROR = ::T.let(nil, ::T.untyped)
  V_ERR_DANE_NO_MATCH = ::T.let(nil, ::T.untyped)
  V_ERR_DIFFERENT_CRL_SCOPE = ::T.let(nil, ::T.untyped)
  V_ERR_EE_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_EMAIL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_EXCLUDED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_HOSTNAME_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CALL = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_NON_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_POLICY_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_IP_ADDRESS_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CRL_SIGN = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_NO_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_ERR_NO_VALID_SCTS = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_CERT_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_FAILED = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_NEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LOOP = ::T.let(nil, ::T.untyped)
  V_ERR_PERMITTED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_SUBJECT_NAME_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_STORE_LOOKUP = ::T.let(nil, ::T.untyped)
  V_ERR_SUBTREE_MINMAX = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_CURVE = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_VERSION = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_LOS_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL_ISSUER = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNNESTED_RESOURCE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_EXTENSION_FEATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_NAME_SYNTAX = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_PARTIAL_CHAIN = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS_ONLY = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_192_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_CHECK_TIME = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::CRL
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Certificate
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
end

class OpenSSL::X509::Certificate
  extend ::OpenSSL::Marshal::ClassMethods
  def self.load(arg); end

  def self.load_file(path); end
end

class OpenSSL::X509::Extension
  include ::OpenSSL::Marshal
  def ==(other); end

  def value_der(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def ca_issuer_uris(); end

  def ocsp_uris(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def authority_key_identifier(); end
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
end

module OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::Helpers
  def crl_uris(); end
end

module OpenSSL::X509::Extension::CRLDistributionPoints
end

module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end

module OpenSSL::X509::Extension::Helpers
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def subject_key_identifier(); end
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
end

class OpenSSL::X509::Extension
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Name
  include ::OpenSSL::Marshal
  def to_utf8(); end
end

class OpenSSL::X509::Name
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Request
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  def __id__!(); end

  def __send__!(*arg); end

  def ai!(options=T.unsafe(nil)); end

  def amazing_print!(object, options=T.unsafe(nil)); end

  def as_json!(options=T.unsafe(nil)); end

  def at_exit!(&block); end

  def awesome_inspect!(options=T.unsafe(nil)); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def deep_dup!(); end

  def define_singleton_method!(*arg); end

  def delete_field!(name, &block); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def exit!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_values!(); end

  def instance_variable_get!(arg); end

  def instance_variable_names!(); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*args); end

  def object_id!(); end

  def presence!(); end

  def presence_in!(another_object); end

  def private_methods!(*args); end

  def protected_methods!(*args); end

  def public_method!(arg); end

  def public_methods!(*args); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def require_dependency!(filename); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*args); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_json!(options=T.unsafe(nil)); end

  def to_param!(); end

  def to_query!(key); end

  def to_s!(); end

  def to_yaml!(options=T.unsafe(nil)); end

  def with!(**attributes); end

  def with_options!(options, &block); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module OpenURI
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end
end

module OpenURI::Meta
  def content_type_parse(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end
end

module OpenURI::Meta
  def self.init(obj, src=T.unsafe(nil)); end
end

class OpenURI::TooManyRedirects
end

class OpenURI::TooManyRedirects
end

module OpenURI
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

class Opportunity
  include ::Opportunity::GeneratedAttributeMethods
  include ::Opportunity::GeneratedAssociationMethods
  def autosave_associated_records_for_user(*args); end
end

module Opportunity::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Opportunity::GeneratedAssociationMethods
end

module Opportunity::GeneratedAttributeMethods
end

module Opportunity::GeneratedAttributeMethods
  extend ::Mutex_m
end

class OptionParser
  def additional_message(typ, opt); end

  def raise_unknown(); end

  def raise_unknown=(raise_unknown); end

  def require_exact(); end

  def require_exact=(require_exact); end
  Version = ::T.let(nil, ::T.untyped)
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class OptionParser::Switch
  def pretty_print_contents(q); end
end

class OptionParser::Switch::NoArgument
  def pretty_head(); end
end

class OptionParser::Switch::OptionalArgument
  def pretty_head(); end
end

class OptionParser::Switch::PlacedArgument
  def pretty_head(); end
end

class OptionParser::Switch::RequiredArgument
  def pretty_head(); end
end

module OrmAdapter
  VERSION = ::T.let(nil, ::T.untyped)
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  POSTGRESQL_LIB_PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapBasedOnResult
  include ::PG::BasicTypeRegistry::Checker
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil)); end
end

class PG::BasicTypeMapBasedOnResult
end

class PG::BasicTypeMapForQueries
  include ::PG::BasicTypeRegistry::Checker
  def encode_array_as(); end

  def encode_array_as=(pg_type); end

  def initialize(connection_or_coder_maps, registry: T.unsafe(nil), if_undefined: T.unsafe(nil)); end
end

class PG::BasicTypeMapForQueries::BinaryData
end

class PG::BasicTypeMapForQueries::BinaryData
end

class PG::BasicTypeMapForQueries::UndefinedEncoder
end

class PG::BasicTypeMapForQueries::UndefinedEncoder
end

class PG::BasicTypeMapForQueries
end

class PG::BasicTypeMapForResults
  include ::PG::BasicTypeRegistry::Checker
  def initialize(connection_or_coder_maps, registry: T.unsafe(nil)); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
  def initialize(typenames); end

  def typecast_result_value(result, _tuple, field); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
end

class PG::BasicTypeMapForResults
end

class PG::BasicTypeRegistry
  include ::PG::BasicTypeRegistry::Checker
  def alias_type(format, new, old); end

  def coders_for(format, direction); end

  def define_default_types(); end

  def register_coder(coder); end

  def register_default_types(); end

  def register_type(format, name, encoder_class, decoder_class); end
end

module PG::BasicTypeRegistry::Checker
  def build_coder_maps(conn_or_maps, registry: T.unsafe(nil)); end

  def check_format_and_direction(format, direction); end
end

module PG::BasicTypeRegistry::Checker
end

class PG::BasicTypeRegistry::CoderMap
  def coder_by_name(name); end

  def coder_by_oid(oid); end

  def coders(); end

  def coders_by_name(); end

  def coders_by_oid(); end

  def initialize(result, coders_by_name, format, arraycoder); end
end

class PG::BasicTypeRegistry::CoderMap
end

class PG::BasicTypeRegistry::CoderMapsBundle
  def each_format(direction); end

  def initialize(connection, registry: T.unsafe(nil)); end

  def map_for(format, direction); end

  def typenames_by_oid(); end
end

class PG::BasicTypeRegistry::CoderMapsBundle
end

class PG::BasicTypeRegistry
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::CopyRow
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Date
  include ::PG::Coder::BinaryFormatting
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Date
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::CopyRow
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Date
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Float4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Float8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::TimestampLocal
end

class PG::BinaryEncoder::TimestampLocal
end

class PG::BinaryEncoder::TimestampUtc
end

class PG::BinaryEncoder::TimestampUtc
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_STANDBY = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_TARGET = ::T.let(nil, ::T.untyped)
  CONNECTION_CHECK_WRITABLE = ::T.let(nil, ::T.untyped)
  CONNECTION_CONSUME = ::T.let(nil, ::T.untyped)
  CONNECTION_GSS_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  DEF_PGPORT = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_PIPELINE_ABORTED = ::T.let(nil, ::T.untyped)
  PGRES_PIPELINE_SYNC = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY_NONLOCALIZED = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_SQLSTATE = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ALWAYS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ERRORS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_NEVER = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_ABORTED = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_OFF = ::T.let(nil, ::T.untyped)
  PQ_PIPELINE_ON = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

module PG::Constants
end

class PG::CopyDecoder
end

class PG::CopyDecoder
end

class PG::CopyEncoder
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleSessionTimeout
end

class PG::IdleSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForSqlJsonDatetimeFunction
end

class PG::InvalidArgumentForSqlJsonDatetimeFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidJsonText
end

class PG::InvalidJsonText
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NoSqlJsonItem
end

class PG::NoSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::RecordDecoder
end

class PG::RecordDecoder
end

class PG::RecordEncoder
end

class PG::RecordEncoder
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonItemCannotBeCastToTargetType
end

class PG::SqlJsonItemCannotBeCastToTargetType
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonScalarRequired
end

class PG::SqlJsonScalarRequired
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

class PG::TextDecoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Date
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::Date
end

class PG::TextDecoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
end

class PG::TextDecoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::JSON
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  def decode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Numeric
end

class PG::TextDecoder::Record
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
  CFUNC = ::T.let(nil, ::T.untyped)
end

PG::TextDecoder::TimestampWithTimeZone = PG::TextDecoder::Timestamp

PG::TextDecoder::TimestampWithoutTimeZone = PG::TextDecoder::TimestampLocal

class PG::TextEncoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Date
  def encode(value); end
end

class PG::TextEncoder::Date
end

class PG::TextEncoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Inet
  def encode(value); end
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::JSON
  def encode(value); end
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
  def encode(*arg); end
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Numeric
end

class PG::TextEncoder::QuotedLiteral
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Record
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampUtc
  def encode(value); end
end

class PG::TextEncoder::TimestampUtc
end

class PG::TextEncoder::TimestampWithTimeZone
  def encode(value); end
end

class PG::TextEncoder::TimestampWithTimeZone
end

class PG::TextEncoder::TimestampWithoutTimeZone
  def encode(value); end
end

class PG::TextEncoder::TimestampWithoutTimeZone
end

class PG::TextEncoder::ToBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

class PP
  VERSION = ::T.let(nil, ::T.untyped)
end

class PP
  def self.width_for(out); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
  def initialize(value=T.unsafe(nil)); end

  def value(); end
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

module Parallel
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.filter_map(*args, &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_find_pattern(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forwarded_kwrestarg(node); end

  def on_forwarded_restarg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwargs(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def lexer(); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def find_pattern(lbrack_t, elements, rbrack_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_arg(dots_t); end

  def forward_only_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def forwarded_kwrestarg(dstar_t); end

  def forwarded_restarg(star_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_pattern(lhs, match_t, rhs); end

  def match_pattern_p(lhs, match_t, rhs); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_label(key_t); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_forward_arg(); end

  def self.emit_forward_arg=(emit_forward_arg); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_kwargs(); end

  def self.emit_kwargs=(emit_kwargs); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_match_pattern(); end

  def self.emit_match_pattern=(emit_match_pattern); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

class Parser::Context
  def in_argdef(); end

  def in_argdef=(in_argdef); end

  def in_block(); end

  def in_block=(in_block); end

  def in_class(); end

  def in_class=(in_class); end

  def in_def(); end

  def in_def=(in_def); end

  def in_defined(); end

  def in_defined=(in_defined); end

  def in_dynamic_block?(); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def in_lambda(); end

  def in_lambda=(in_lambda); end

  def reset(); end
  FLAGS = ::T.let(nil, ::T.untyped)
end

class Parser::CurrentArgStack
  def empty?(); end

  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def check_ambiguous_slash(tm); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def cmdarg_stack(); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def cond_stack(); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def e_lbrace(); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_class_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_colon_with_digits(p, tm, diag_msg); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment_from_range(p, pe); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_global_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_instance_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_rbrace_rparen_rbrack(); end

  def emit_singleton_class(); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encoding(); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def initialize(version); end

  def lambda_stack(); end

  def numeric_literal_int(); end

  def on_newline(p); end

  def paren_nest(); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def push_cmdarg(); end

  def push_cond(); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version(); end

  def version?(*versions); end
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TAB = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_inside_string(); end

  def self.lex_en_inside_string=(lex_en_inside_string); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::LexerStrings
  def advance(p); end

  def check_ambiguous_slash(tm); end

  def check_invalid_escapes(p); end

  def close_interp_on_current_literal(p); end

  def cond(); end

  def continue_lexing(current_literal); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_character_constant(); end

  def emit_interp_var(interp_var_kind); end

  def emit_invalid_escapes?(); end

  def encode_escape(ord); end

  def encode_escaped_char(p); end

  def eof_codepoint?(point); end

  def extend_interp_code(current_literal); end

  def extend_interp_digit_var(); end

  def extend_interp_var(current_literal); end

  def extend_string_eol_check_eof(current_literal, pe); end

  def extend_string_eol_heredoc_intertwined(p); end

  def extend_string_eol_heredoc_line(); end

  def extend_string_eol_words(current_literal, p); end

  def extend_string_escaped(); end

  def extend_string_for_token_range(current_literal, string); end

  def extend_string_slice_end(lookahead); end

  def herebody_s(); end

  def herebody_s=(herebody_s); end

  def initialize(lexer, version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def on_newline(p); end

  def pop_literal(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def read_character_constant(p); end

  def read_post_meta_or_ctrl_char(p); end

  def reset(); end

  def slash_c_char(); end

  def slash_m_char(); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def source_pts(); end

  def source_pts=(source_pts); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def unescape_char(p); end

  def unicode_points(p); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::LexerStrings
  def self.lex_en_character(); end

  def self.lex_en_character=(lex_en_character); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_en_unknown(); end

  def self.lex_en_unknown=(lex_en_unknown); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def empty?(); end

  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(static:); end

  def register(numparam); end

  def stack(); end

  def top(); end
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

module Parser::Messages
  def self.compile(reason, arguments); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*arg); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def local_pop(); end

  def local_push(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil), source: T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(start, length=T.unsafe(nil)); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_by_identity(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_by_identity(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::MethodDefinition
  def assignment(); end

  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Range
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def to_range(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def as_nested_actions(); end

  def as_replacements(); end

  def diagnostics(); end

  def empty?(); end

  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def contract(); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def moved(source_buffer, offset); end

  def nested_actions(); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_anonymous_blockarg(); end

  def declare_anonymous_kwrestarg(); end

  def declare_anonymous_restarg(); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_anonymous_blockarg?(); end

  def declared_anonymous_blockarg_in_current_scpe?(); end

  def declared_anonymous_kwrestarg?(); end

  def declared_anonymous_kwrestarg_in_current_scope?(); end

  def declared_anonymous_restarg?(); end

  def declared_anonymous_restarg_in_current_scope?(); end

  def declared_forward_args?(); end

  def empty?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def parent_has_anonymous_blockarg?(); end

  def parent_has_anonymous_kwrestarg?(); end

  def parent_has_anonymous_restarg?(); end

  def reset(); end

  def unextend(); end
  ANONYMOUS_BLOCKARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_BLOCKARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def empty?(); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Pathname
  def existence(); end

  def lutime(arg, arg1); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pathway
  include ::Pathway::GeneratedAttributeMethods
  include ::Pathway::GeneratedAssociationMethods
end

module Pathway::GeneratedAssociationMethods
end

module Pathway::GeneratedAssociationMethods
end

module Pathway::GeneratedAttributeMethods
end

module Pathway::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Plan
  include ::Plan::GeneratedAttributeMethods
  include ::Plan::GeneratedAssociationMethods
end

module Plan::GeneratedAssociationMethods
end

module Plan::GeneratedAssociationMethods
end

module Plan::GeneratedAttributeMethods
end

module Plan::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Pledge
  include ::Pledge::GeneratedAttributeMethods
  include ::Pledge::GeneratedAssociationMethods
  def autosave_associated_records_for_user(*args); end
end

module Pledge::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Pledge::GeneratedAssociationMethods
end

module Pledge::GeneratedAttributeMethods
end

module Pledge::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Post
  include ::Post::GeneratedAttributeMethods
  include ::Post::GeneratedAssociationMethods
  def autosave_associated_records_for_comments(*args); end

  def autosave_associated_records_for_photos_attachments(*args); end

  def autosave_associated_records_for_photos_blobs(*args); end

  def autosave_associated_records_for_picture_attachment(*args); end

  def autosave_associated_records_for_picture_blob(*args); end

  def autosave_associated_records_for_rich_text_content(*args); end

  def autosave_associated_records_for_user(*args); end

  def content(); end

  def content=(body); end

  def content?(); end

  def validate_associated_records_for_comments(*args); end

  def validate_associated_records_for_photos_attachments(*args); end

  def validate_associated_records_for_photos_blobs(*args); end

  def validate_associated_records_for_rich_text_content(*args); end
end

module Post::GeneratedAssociationMethods
  def build_picture_attachment(*args, &block); end

  def build_picture_blob(*args, &block); end

  def build_rich_text_content(*args, &block); end

  def build_user(*args, &block); end

  def comment_ids(); end

  def comment_ids=(ids); end

  def comments(); end

  def comments=(value); end

  def create_picture_attachment(*args, &block); end

  def create_picture_attachment!(*args, &block); end

  def create_picture_blob(*args, &block); end

  def create_picture_blob!(*args, &block); end

  def create_rich_text_content(*args, &block); end

  def create_rich_text_content!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def photos(); end

  def photos=(attachables); end

  def photos_attachment_ids(); end

  def photos_attachment_ids=(ids); end

  def photos_attachments(); end

  def photos_attachments=(value); end

  def photos_blob_ids(); end

  def photos_blob_ids=(ids); end

  def photos_blobs(); end

  def photos_blobs=(value); end

  def picture(); end

  def picture=(attachable); end

  def picture_attachment(); end

  def picture_attachment=(value); end

  def picture_blob(); end

  def picture_blob=(value); end

  def reload_picture_attachment(); end

  def reload_picture_blob(); end

  def reload_rich_text_content(); end

  def reload_user(); end

  def reset_picture_attachment(); end

  def reset_picture_blob(); end

  def reset_rich_text_content(); end

  def reset_user(); end

  def rich_text_content(); end

  def rich_text_content=(value); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Post::GeneratedAssociationMethods
end

module Post::GeneratedAttributeMethods
end

module Post::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Post
  def self.with_attached_photos(*args, **arg); end

  def self.with_attached_picture(*args, **arg); end

  def self.with_rich_text_content(*args, **arg); end

  def self.with_rich_text_content_and_embeds(*args, **arg); end
end

class PrayFor
  include ::PrayFor::GeneratedAttributeMethods
  include ::PrayFor::GeneratedAssociationMethods
end

module PrayFor::GeneratedAssociationMethods
end

module PrayFor::GeneratedAssociationMethods
end

module PrayFor::GeneratedAttributeMethods
end

module PrayFor::GeneratedAttributeMethods
  extend ::Mutex_m
end

class PrettyPrint
  VERSION = ::T.let(nil, ::T.untyped)
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

module Process
  CLOCK_TAI = ::T.let(nil, ::T.untyped)
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  extend ::RedisClient::PIDCache::CoreExt
  extend ::ConnectionPool::ForkTracker
  extend ::DEBUGGER__::ForkInterceptor
  extend ::DEBUGGER__::ForkInterceptor::DaemonInterceptor
  extend ::ActiveSupport::ForkTracker::ModernCoreExt
  def self.exit(*arg); end

  def self.warmup(); end
end

class Profile
  include ::Profile::GeneratedAttributeMethods
  include ::Profile::GeneratedAssociationMethods
  def autosave_associated_records_for_user(*args); end
end

module Profile::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Profile::GeneratedAssociationMethods
end

module Profile::GeneratedAttributeMethods
end

module Profile::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar_component(); end

  def bar_component=(bar_component); end

  def clear(*args, **arg, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, **arg, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage_component(); end

  def percentage_component=(percentage_component); end

  def progress(*args, **arg, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def projector(); end

  def projector=(projector); end

  def rate_component(); end

  def rate_component=(rate_component); end

  def refresh(*args, **arg, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time_component(); end

  def time_component=(time_component); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_component(); end

  def title_component=(title_component); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, **arg, &block); end

  def total=(new_total); end

  def update_progress(*args); end
  RUNNING_AVERAGE_RATE_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  SMOOTHING_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Components::Bar
  def bar(length); end

  def bar_with_percentage(length); end

  def complete_bar(length); end

  def complete_bar_with_percentage(length); end

  def incomplete_space(length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def justified_percentage(); end

  def justified_percentage_with_precision(); end

  def percentage(); end

  def percentage_with_precision(); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_of_change(format_string=T.unsafe(nil)); end

  def rate_of_change_with_precision(); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_wall_clock(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(out_of_bounds_time_format=T.unsafe(nil)); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def projector(); end

  def projector=(projector); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TEXT_TO_FORMAT = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
  WALL_CLOCK_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*arg); end

  def resolve_format(*arg); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Projector
  NAME_TO_PROJECTOR_MAP = ::T.let(nil, ::T.untyped)
end

ProgressBar::Projector::DEFAULT_PROJECTOR = ProgressBar::Projectors::SmoothedAverage

class ProgressBar::Projector
  def self.from_type(name); end
end

class ProgressBar::Projectors::SmoothedAverage
  def decrement(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def progress(); end

  def progress=(new_progress); end

  def projection(); end

  def projection=(projection); end

  def reset(); end

  def samples(); end

  def samples=(samples); end

  def start(options=T.unsafe(nil)); end

  def strength(); end

  def strength=(strength); end

  def total=(_new_total); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRENGTH = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Projectors::SmoothedAverage
  def self.calculate(current_projection, new_value, rate); end
end

module ProgressBar::Refinements::Enumerator
  ARITY_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def now(); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar
  def self.create(*args); end
end

class Propshaft::Compiler::CssAssetUrls
  ASSET_URL_PATTERN = ::T.let(nil, ::T.untyped)
end

class Propshaft::Compiler::SourceMappingUrls
  SOURCE_MAPPING_PATTERN = ::T.let(nil, ::T.untyped)
end

class Propshaft::Processor
  MANIFEST_FILENAME = ::T.let(nil, ::T.untyped)
end

class Propshaft::Server
  VARY = ::T.let(nil, ::T.untyped)
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(*args, **arg, &block); end

  def color=(*args, **arg, &block); end

  def commands(*args, **arg, &block); end

  def commands=(*args, **arg, &block); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(*args, **arg, &block); end

  def editor=(*args, **arg, &block); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(*args, **arg, &block); end

  def exception_handler=(*args, **arg, &block); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(*args, **arg, &block); end

  def extra_sticky_locals=(*args, **arg, &block); end

  def hooks(*args, **arg, &block); end

  def hooks=(*args, **arg, &block); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, binding); end

  def inject_sticky_locals!(); end

  def input(*args, **arg, &block); end

  def input=(*args, **arg, &block); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(exception); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(*args, **arg, &block); end

  def output_ring(); end

  def pager(); end

  def pager=(*args, **arg, &block); end

  def pop_prompt(); end

  def print(*args, **arg, &block); end

  def print=(*args, **arg, &block); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::DEBUGGER__::TrapInterceptor
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::BlockCommand
  def call(*args); end

  def help(); end
end

module Pry::Byebug::Breakpoints
  def add_file(file, line, expression=T.unsafe(nil)); end

  def add_method(method, expression=T.unsafe(nil)); end

  def breakpoints(); end

  def change(id, expression=T.unsafe(nil)); end

  def delete(id); end

  def delete_all(); end

  def disable(id); end

  def disable_all(); end

  def each(&block); end

  def enable(id); end

  def find_by_id(id); end

  def last(); end

  def size(); end

  def to_a(); end
end

class Pry::Byebug::Breakpoints::FileBreakpoint
  def source_code(); end

  def to_s(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Pry::Byebug::Breakpoints::MethodBreakpoint
  def initialize(byebug_bp, method); end

  def source_code(); end

  def to_s(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code
  def <<(line); end

  def ==(other); end

  def after(lineno, lines=T.unsafe(nil)); end

  def alter(&block); end

  def around(lineno, lines=T.unsafe(nil)); end

  def before(lineno, lines=T.unsafe(nil)); end

  def between(start_line, end_line=T.unsafe(nil)); end

  def code_type(); end

  def code_type=(code_type); end

  def comment_describing(line_number); end

  def expression_at(line_number, consume=T.unsafe(nil)); end

  def grep(pattern); end

  def highlighted(); end

  def initialize(lines=T.unsafe(nil), start_line=T.unsafe(nil), code_type=T.unsafe(nil)); end

  def length(); end

  def max_lineno_width(); end

  def method_missing(method_name, *args, &block); end

  def nesting_at(line_number); end

  def print_to_output(output, color=T.unsafe(nil)); end

  def push(line); end

  def raw(); end

  def reject(&block); end

  def select(&block); end

  def take_lines(start_line, num_lines); end

  def with_indentation(spaces=T.unsafe(nil)); end

  def with_line_numbers(y_n=T.unsafe(nil)); end

  def with_marker(lineno=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::LOC
  def ==(other); end

  def add_line_number(max_width=T.unsafe(nil), color=T.unsafe(nil)); end

  def add_marker(marker_lineno); end

  def colorize(code_type); end

  def handle_multiline_entries_from_edit_command(line, max_width); end

  def indent(distance); end

  def initialize(line, lineno); end

  def line(); end

  def lineno(); end

  def tuple(); end
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
  def self.from_file(filename, code_type=T.unsafe(nil)); end

  def self.from_method(meth, start_line=T.unsafe(nil)); end

  def self.from_module(mod, candidate_rank=T.unsafe(nil), start_line=T.unsafe(nil)); end
end

class Pry::CodeFile
  def code(); end

  def code_type(); end

  def initialize(filename, code_type=T.unsafe(nil)); end
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::CodeObject
  def command_lookup(); end

  def default_lookup(); end

  def empty_lookup(); end

  def initialize(str, pry_instance, options=T.unsafe(nil)); end

  def method_or_class_lookup(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def str(); end

  def str=(str); end

  def super_level(); end

  def super_level=(super_level); end

  def target(); end

  def target=(target); end
end

module Pry::CodeObject::Helpers
  def c_method?(); end

  def c_module?(); end

  def command?(); end

  def module_with_yard_docs?(); end

  def real_method_object?(); end
end

class Pry::CodeObject
  def self.lookup(str, pry_instance, options=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def pp(object); end

  def text(str, max_width=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def self.default(_output, value, pry_instance); end

  def self.pp(obj, output=T.unsafe(nil), max_width=T.unsafe(nil)); end
end

class Pry::Command
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def tokenize(val); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::ExceptionFormatter
  def ex(); end

  def format(); end

  def initialize(exception, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::FileFormatter
  def file_and_line(); end

  def file_with_embedded_line(); end

  def format(); end

  def initialize(file_with_embedded_line, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::InputExpressionFormatter
  def format(); end

  def initialize(input_expressions, opts); end

  def input_expressions(); end

  def input_expressions=(input_expressions); end

  def opts(); end

  def opts=(opts); end
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::CodeCollector
  def args(); end

  def code_object(); end

  def content(); end

  def file(); end

  def file=(file); end

  def initialize(args, opts, pry_instance); end

  def line_range(); end

  def obj_name(); end

  def opts(); end

  def pry_input_content(); end

  def pry_instance(); end

  def pry_output_content(); end

  def restrict_to_lines(content, range); end
end

class Pry::Command::CodeCollector
  def self.inject_options(opt); end

  def self.input_expression_ranges(); end

  def self.input_expression_ranges=(input_expression_ranges); end

  def self.output_result_ranges(); end

  def self.output_result_ranges=(output_result_ranges); end
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Edit::ExceptionPatcher
  def file_and_line(); end

  def file_and_line=(file_and_line); end

  def initialize(pry_instance, state, exception_file_and_line); end

  def perform_patch(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def state(); end

  def state=(state); end
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end

  def self.from_code_object(code_object, filename_argument); end

  def self.from_exception(exception, backtrace_level); end

  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Help
  def command_groups(); end

  def display_command(command); end

  def display_filtered_commands(search); end

  def display_filtered_search_results(search); end

  def display_index(groups); end

  def display_search(search); end

  def group_sort_key(group_name); end

  def help_text_for_commands(name, commands); end

  def normalize(key); end

  def search_hash(search, hash); end

  def sorted_commands(commands); end

  def sorted_group_names(groups); end

  def visible_commands(); end
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::JumpTo
  def process(break_level); end
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Formatter
  def grep=(grep); end

  def initialize(pry_instance); end

  def pry_instance(); end

  def write_out(); end
end

class Pry::Command::Ls::Globals
  def initialize(opts, pry_instance); end
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp(); end
end

class Pry::Command::Ls::InstanceVars
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::LocalNames
  def initialize(no_user_opts, args, pry_instance); end
end

class Pry::Command::Ls::LocalVars
  def initialize(opts, pry_instance); end
end

class Pry::Command::Ls::LsEntity
  def entities_table(); end

  def initialize(opts); end

  def pry_instance(); end
end

class Pry::Command::Ls::Methods
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::SelfMethods
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShowDoc
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowInfo
  def code_object_header(code_object, line_num); end

  def code_object_with_accessible_source(code_object); end

  def complete(input); end

  def content_and_header_for_code_object(code_object); end

  def content_and_headers_for_all_module_candidates(mod); end

  def file_and_line_for(code_object); end

  def header(code_object); end

  def header_options(); end

  def initialize(*arg); end

  def method_header(code_object, line_num); end

  def method_sections(code_object); end

  def module_header(code_object, line_num); end

  def no_definition_message(); end

  def obj_name(); end

  def show_all_modules?(code_object); end

  def start_line_for(code_object); end

  def use_line_numbers?(); end

  def valid_superclass?(code_object); end
end

class Pry::Command::ShowSource
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::SwitchTo
  def process(selection); end
end

class Pry::Command::ToggleColor
  def color_toggle(); end
end

class Pry::Command::WatchExpression::Expression
  def changed?(); end

  def eval!(); end

  def initialize(pry_instance, target, source); end

  def previous_value(); end

  def pry_instance(); end

  def source(); end

  def target(); end

  def value(); end
end

class Pry::Command::Whereami
  def bad_option_combination?(); end

  def code(); end

  def code?(); end

  def initialize(*arg); end

  def location(); end
end

class Pry::Command::Whereami
  def self.method_size_cutoff(); end

  def self.method_size_cutoff=(method_size_cutoff); end
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

class Pry::Command
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.state(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandSet
  def [](pattern); end

  def []=(pattern, command); end

  def add_command(command); end

  def alias_command(match, action, options=T.unsafe(nil)); end

  def block_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def complete(search, context=T.unsafe(nil)); end

  def create_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*searches); end

  def desc(search, description=T.unsafe(nil)); end

  def each(&block); end

  def find_command(pattern); end

  def find_command_by_match_or_listing(match_or_listing); end

  def find_command_for_help(search); end

  def helper_module(); end

  def import(*sets); end

  def import_from(set, *matches); end

  def initialize(*imported_sets, &block); end

  def keys(); end

  def list_commands(); end

  def process_line(val, context=T.unsafe(nil)); end

  def rename_command(new_match, search, options=T.unsafe(nil)); end

  def to_h(); end

  def to_hash(); end

  def valid_command?(val); end
end

class Pry::CommandState
  def reset(command_name); end

  def state_for(command_name); end
end

class Pry::CommandState
  def self.default(); end
end

class Pry::Config
  def [](attr); end

  def []=(attr, value); end

  def auto_indent(); end

  def auto_indent=(auto_indent); end

  def collision_warning(); end

  def collision_warning=(collision_warning); end

  def color(); end

  def color=(color); end

  def command_completions(); end

  def command_completions=(command_completions); end

  def command_prefix(); end

  def command_prefix=(command_prefix); end

  def commands(); end

  def commands=(commands); end

  def completer(); end

  def completer=(completer); end

  def control_d_handler(); end

  def control_d_handler=(value); end

  def correct_indent(); end

  def correct_indent=(correct_indent); end

  def default_window_size(); end

  def default_window_size=(default_window_size); end

  def disable_auto_reload(); end

  def disable_auto_reload=(disable_auto_reload); end

  def editor(); end

  def editor=(editor); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def exception_whitelist(); end

  def exception_whitelist=(exception_whitelist); end

  def exec_string(); end

  def exec_string=(exec_string); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(extra_sticky_locals); end

  def file_completions(); end

  def file_completions=(file_completions); end

  def history(); end

  def history=(history); end

  def history_file(); end

  def history_file=(history_file); end

  def history_ignorelist(); end

  def history_ignorelist=(history_ignorelist); end

  def history_load(); end

  def history_load=(history_load); end

  def history_save(); end

  def history_save=(history_save); end

  def hooks(); end

  def hooks=(hooks); end

  def input(); end

  def input=(input); end

  def ls(); end

  def ls=(ls); end

  def memory_size(); end

  def memory_size=(memory_size); end

  def merge(config_hash); end

  def merge!(config_hash); end

  def method_missing(method_name, *args, &_block); end

  def output(); end

  def output=(output); end

  def output_prefix(); end

  def output_prefix=(output_prefix); end

  def pager(); end

  def pager=(pager); end

  def print(); end

  def print=(print); end

  def prompt(); end

  def prompt=(prompt); end

  def prompt_name(); end

  def prompt_name=(prompt_name); end

  def prompt_safe_contexts(); end

  def prompt_safe_contexts=(prompt_safe_contexts); end

  def quiet(); end

  def quiet=(quiet); end

  def rc_file(); end

  def rc_file=(rc_file); end

  def requires(); end

  def requires=(requires); end

  def should_load_local_rc(); end

  def should_load_local_rc=(should_load_local_rc); end

  def should_load_rc(); end

  def should_load_rc=(should_load_rc); end

  def should_load_requires(); end

  def should_load_requires=(should_load_requires); end

  def should_trap_interrupts(); end

  def should_trap_interrupts=(should_trap_interrupts); end

  def system(); end

  def system=(system); end

  def unrescued_exceptions(); end

  def unrescued_exceptions=(unrescued_exceptions); end

  def windows_console_warning(); end

  def windows_console_warning=(windows_console_warning); end
end

module Pry::Config::Attributable
  def attribute(attr_name); end
end

class Pry::Config::LazyValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::MemoizedValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::Value
  def call(); end

  def initialize(value); end
end

module Pry::ControlDHandler
  def self.default(pry_instance); end
end

class Pry::Editor
  def build_editor_invocation_string(file, line, blocking); end

  def edit_tempfile_with_content(initial_content, line=T.unsafe(nil)); end

  def initialize(pry_instance); end

  def invoke_editor(file, line, blocking=T.unsafe(nil)); end

  def pry_instance(); end
end

class Pry::Editor
  def self.default(); end
end

module Pry::Env
  def self.[](key); end
end

module Pry::ExceptionHandler
  def self.handle_exception(output, exception, _pry_instance); end
end

module Pry::Forwardable
  def def_private_delegators(target, *private_delegates); end
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

module Pry::Helpers::BaseHelpers
  def colorize_code(code); end

  def find_command(name, set=T.unsafe(nil)); end

  def heading(text); end

  def highlight(string, regexp, highlight_color=T.unsafe(nil)); end

  def not_a_real_file?(file); end

  def safe_send(obj, method, *args, &block); end

  def silence_warnings(); end

  def stagger_output(text, _out=T.unsafe(nil)); end

  def use_ansi_codes?(); end
end

module Pry::Helpers::CommandHelpers
  def absolute_index_number(line_number, array_length); end

  def absolute_index_range(range_or_number, array_length); end

  def get_method_or_raise(method_name, context, opts=T.unsafe(nil)); end

  def internal_binding?(context); end

  def one_index_number(line_number); end

  def one_index_range(range); end

  def one_index_range_or_number(range_or_number); end

  def restrict_to_lines(content, lines); end

  def set_file_and_dir_locals(file_name, pry=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def temp_file(ext=T.unsafe(nil)); end

  def unindent(dirty_text, left_padding=T.unsafe(nil)); end
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  def self.get_comment_content(comment); end

  def self.process_comment_markup(comment); end

  def self.process_rdoc(comment); end

  def self.process_yardoc(comment); end

  def self.process_yardoc_tag(comment, tag); end

  def self.strip_comments_from_c_code(code); end

  def self.strip_leading_whitespace(text); end
end

module Pry::Helpers::OptionsHelpers
  def self.method_object(); end

  def self.method_options(opt); end
end

module Pry::Helpers::Platform
  def self.jruby?(); end

  def self.jruby_19?(); end

  def self.linux?(); end

  def self.mac_osx?(); end

  def self.mri?(); end

  def self.mri_2?(); end

  def self.windows?(); end

  def self.windows_ansi?(); end
end

class Pry::Helpers::Table
  def ==(other); end

  def column_count(); end

  def column_count=(count); end

  def columns(); end

  def fits_on_line?(line_length); end

  def initialize(items, args, pry_instance=T.unsafe(nil)); end

  def items(); end

  def items=(items); end

  def rows_to_s(style=T.unsafe(nil)); end

  def to_a(); end
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bold(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def default(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def indent(text, chars); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def no_color(); end

  def no_pager(); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def strip_color(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def with_line_numbers(text, offset, color=T.unsafe(nil)); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers
  def self.tablify(things, line_length, pry_instance=T.unsafe(nil)); end

  def self.tablify_or_one_line(heading, things, pry_instance=T.unsafe(nil)); end

  def self.tablify_to_screen_width(things, options, pry_instance=T.unsafe(nil)); end
end

class Pry::History
  def <<(line); end

  def clear(); end

  def filter(history); end

  def history_line_count(); end

  def initialize(options=T.unsafe(nil)); end

  def load(); end

  def loader(); end

  def loader=(loader); end

  def original_lines(); end

  def push(line); end

  def saver(); end

  def saver=(saver); end

  def session_line_count(); end

  def to_a(); end
end

class Pry::History
  def self.default_file(); end
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
  def self.default(); end
end

class Pry::Indent
  def correct_indentation(prompt, code, overhang=T.unsafe(nil)); end

  def current_prefix(); end

  def end_of_statement?(last_token, last_kind); end

  def in_string?(); end

  def indent(input); end

  def indent_level(); end

  def indentation_delta(tokens); end

  def initialize(pry_instance=T.unsafe(nil)); end

  def module_nesting(); end

  def open_delimiters(); end

  def open_delimiters_line(); end

  def reset(); end

  def stack(); end

  def tokenize(string); end

  def track_delimiter(token); end

  def track_module_nesting(token, kind); end

  def track_module_nesting_end(token, kind=T.unsafe(nil)); end
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent
  def self.indent(str); end

  def self.nesting_at(str, line_number); end
end

class Pry::InputCompleter
  def build_path(input); end

  def call(str, options=T.unsafe(nil)); end

  def ignored_modules(); end

  def initialize(input, pry=T.unsafe(nil)); end

  def select_message(path, receiver, message, candidates); end
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::InputLock
  def __with_ownership(); end

  def enter_interruptible_region(); end

  def interruptible_region(); end

  def leave_interruptible_region(); end

  def with_ownership(&block); end
end

class Pry::InputLock
  def self.for(input); end

  def self.global_lock(); end

  def self.global_lock=(global_lock); end

  def self.input_locks(); end

  def self.input_locks=(input_locks); end
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(exception); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::Method
  def ==(other); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def owner(*args, **arg, &block); end

  def parameters(*args, **arg, &block); end

  def pry_method?(); end

  def receiver(*args, **arg, &block); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def find_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, binding); end

  def self.weird_method?(method, binding); end
end

class Pry::Method
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(binding); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::NoCommandError
  def initialize(match, owner); end
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::Output
  def <<(*objs); end

  def decolorize_maybe(str); end

  def height(); end

  def initialize(pry_instance); end

  def method_missing(method_name, *args, &block); end

  def print(*objs); end

  def pry_instance(); end

  def puts(*objs); end

  def size(); end

  def tty?(); end

  def width(); end

  def write(*objs); end
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::Pager
  def initialize(pry_instance); end

  def open(); end

  def page(text); end

  def pry_instance(); end
end

class Pry::Pager::NullPager
  def <<(str); end

  def close(); end

  def initialize(out); end

  def print(str); end

  def puts(str); end

  def write(str); end
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?(); end

  def record(str); end

  def reset(); end
end

class Pry::Pager::SimplePager
  def initialize(*arg); end
end

class Pry::Pager::SystemPager
  def initialize(*arg); end
end

class Pry::Pager::SystemPager
  def self.available?(); end

  def self.default_pager(); end
end

class Pry::Prompt
  def [](key); end

  def description(); end

  def incomplete_proc(); end

  def initialize(name, description, prompt_procs); end

  def name(); end

  def prompt_procs(); end

  def wait_proc(); end
end

class Pry::Prompt
  def self.[](name); end

  def self.add(name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def initialize(pry, options=T.unsafe(nil)); end

  def input(*args, **arg, &block); end

  def output(*args, **arg, &block); end

  def pry(); end

  def pry=(pry); end

  def start(); end
end

class Pry::REPL
  def self.start(options=T.unsafe(nil)); end

  def self.start_with_pry_byebug(options=T.unsafe(nil)); end

  def self.start_without_pry_byebug(options); end
end

class Pry::REPLFileLoader
  def define_additional_commands(); end

  def initialize(file_name); end

  def interactive_mode(pry_instance); end

  def load(); end

  def non_interactive_mode(pry_instance, content); end
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def command?(); end

  def initialize(is_command, retval=T.unsafe(nil)); end

  def retval(); end

  def void_command?(); end
end

class Pry::Ring
  def <<(value); end

  def [](index); end

  def clear(); end

  def count(); end

  def initialize(max_size); end

  def max_size(); end

  def size(); end

  def to_a(); end
end

class Pry::Slop
  def [](key); end

  def add_callback(label, &block); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def command(command, options=T.unsafe(nil), &block); end

  def config(); end

  def description(desc=T.unsafe(nil)); end

  def description=(desc); end

  def each(&block); end

  def fetch_command(command); end

  def fetch_option(key); end

  def get(key); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def missing(); end

  def on(*objects, &block); end

  def opt(*objects, &block); end

  def option(*objects, &block); end

  def options(); end

  def parse(items=T.unsafe(nil), &block); end

  def parse!(items=T.unsafe(nil), &block); end

  def present?(*keys); end

  def run(callable=T.unsafe(nil), &block); end

  def separator(text); end

  def strict?(); end

  def to_h(include_commands=T.unsafe(nil)); end

  def to_hash(include_commands=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Commands
  def [](key); end

  def arguments(); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def commands(); end

  def config(); end

  def default(config=T.unsafe(nil), &block); end

  def each(&block); end

  def get(key); end

  def global(config=T.unsafe(nil), &block); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def on(command, config=T.unsafe(nil), &block); end

  def parse(items=T.unsafe(nil)); end

  def parse!(items=T.unsafe(nil)); end

  def present?(key); end

  def to_hash(); end
end

class Pry::Slop::Option
  def accepts_optional_argument?(); end

  def argument_in_value(); end

  def argument_in_value=(argument_in_value); end

  def call(*objects); end

  def config(); end

  def count(); end

  def count=(count); end

  def description(); end

  def expects_argument?(); end

  def help(); end

  def initialize(slop, short, long, description, config=T.unsafe(nil), &block); end

  def key(); end

  def long(); end

  def short(); end

  def types(); end

  def value(); end

  def value=(new_value); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop
  def self.optspec(string, config=T.unsafe(nil)); end

  def self.parse(items=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.parse!(items=T.unsafe(nil), config=T.unsafe(nil), &block); end
end

class Pry::SyntaxHighlighter
  def self.highlight(code, language=T.unsafe(nil)); end

  def self.keyword_token_color(); end

  def self.overwrite_coderay_comment_token!(); end

  def self.tokenize(code, language=T.unsafe(nil)); end
end

module Pry::SystemCommandHandler
  def self.default(output, command, _pry_instance); end
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::Warning
  def self.warn(message); end
end

class Pry::WrappedModule
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  def class?(*args, **arg, &block); end

  def doc(); end

  def file(); end

  def initialize(wrapper, rank); end

  def line(); end

  def module?(*args, **arg, &block); end

  def nonblank_name(*args, **arg, &block); end

  def number_of_candidates(*args, **arg, &block); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def wrapped(*args, **arg, &block); end
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  def self.Code(obj); end

  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(*args, **arg, &block); end

  def self.color=(*args, **arg, &block); end

  def self.commands(*args, **arg, &block); end

  def self.commands=(*args, **arg, &block); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.editor(*args, **arg, &block); end

  def self.editor=(*args, **arg, &block); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(*args, **arg, &block); end

  def self.exception_handler=(*args, **arg, &block); end

  def self.extra_sticky_locals(*args, **arg, &block); end

  def self.extra_sticky_locals=(*args, **arg, &block); end

  def self.final_session_setup(); end

  def self.history(*args, **arg, &block); end

  def self.history=(*args, **arg, &block); end

  def self.hooks(*args, **arg, &block); end

  def self.hooks=(*args, **arg, &block); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(*args, **arg, &block); end

  def self.input=(*args, **arg, &block); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.main(); end

  def self.memory_size(*args, **arg, &block); end

  def self.memory_size=(*args, **arg, &block); end

  def self.output(*args, **arg, &block); end

  def self.output=(*args, **arg, &block); end

  def self.pager(*args, **arg, &block); end

  def self.pager=(*args, **arg, &block); end

  def self.print(*args, **arg, &block); end

  def self.print=(*args, **arg, &block); end

  def self.prompt(*args, **arg, &block); end

  def self.prompt=(*args, **arg, &block); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(toplevel_binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

module PryByebug
  def current_remote_server(); end

  def current_remote_server=(current_remote_server); end
end

module PryByebug::Helpers::Breakpoints
  def bold_puts(msg); end

  def breakpoints(); end

  def max_width(); end

  def print_breakpoints_header(); end

  def print_full_breakpoint(breakpoint); end

  def print_short_breakpoint(breakpoint); end
end

module PryByebug::Helpers::Location
  def self.current_file(source=T.unsafe(nil)); end
end

module PryByebug::Helpers::Multiline
  def check_multiline_context(); end
end

module PryByebug::Helpers::Navigation
  def breakout_navigation(action, options=T.unsafe(nil)); end
end

module PryByebug
  def self.check_file_context(target, msg=T.unsafe(nil)); end

  def self.file_context?(target); end
end

module PryRails
  Commands = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PryRails::FindRoute
  def process(controller); end
end

class PryRails::ModelFormatter
  def format_active_record(model); end

  def format_association(type, other, options=T.unsafe(nil)); end

  def format_column(name, type); end

  def format_error(message); end

  def format_model_name(model); end

  def format_mongoid(model); end

  def kind_of_relation(relation); end
end

class PryRails::Prompt
  def self.formatted_env(); end

  def self.project_name(); end
end

class PryRails::RecognizePath
  def process(path); end
end

class PryRails::ShowMiddleware
  def print_middleware(middlewares); end
end

class PryRails::ShowModels
  def colorize_matches(string); end

  def display_activerecord_models(); end

  def display_mongoid_models(); end

  def grep_regex(); end

  def print_unless_filtered(str); end
end

class PryRails::ShowRoutes
  def grep_routes(formatted); end

  def process_rails_3_0_and_3_1(all_routes); end

  def process_rails_3_2(all_routes); end

  def process_rails_4_and_5(all_routes); end

  def process_rails_6_and_higher(all_routes); end
end

module PryStackExplorer
  Commands = ::T.let(nil, ::T.untyped)
  LOCATION_LAMBDA = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PryStackExplorer::FrameManager
  def binding_index(); end

  def binding_index=(binding_index); end

  def bindings(); end

  def bindings=(bindings); end

  def change_frame_to(index, run_whereami=T.unsafe(nil)); end

  def current_frame(); end

  def each(&block); end

  def initialize(bindings, _pry_); end

  def prior_backtrace(); end

  def prior_binding(); end

  def refresh_frame(run_whereami=T.unsafe(nil)); end

  def set_binding_index_safely(index); end

  def user(); end
end

class PryStackExplorer::WhenStartedHook
  def call(target, options, _pry_); end

  def caller_bindings(target); end
end

module PryStackExplorer
  def self.bindings_equal?(b1, b2); end

  def self.clear_frame_managers(_pry_); end

  def self.create_and_push_frame_manager(bindings, _pry_, options=T.unsafe(nil)); end

  def self.delete_frame_managers(_pry_); end

  def self.frame_hash(); end

  def self.frame_manager(_pry_); end

  def self.frame_managers(_pry_); end

  def self.pop_frame_manager(_pry_); end
end

module Psych
  LOADER_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::AliasesNotEnabled
  def initialize(); end
end

class Psych::AliasesNotEnabled
end

class Psych::AnchorNotDefined
  def initialize(anchor_name); end
end

class Psych::AnchorNotDefined
end

class Psych::ScalarScanner
  INTEGER_LEGACY = ::T.let(nil, ::T.untyped)
  INTEGER_STRICT = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
  def visit_Symbol(sym); end
  DEFAULT_PERMITTED_CLASSES = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
end

class Psych::Visitors::Visitor
  def self.dispatch_cache(); end
end

module Psych
  extend ::Bootsnap::CompileCache::YAML::Psych4::Patch
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.config(); end

  def self.domain_types(); end

  def self.domain_types=(value); end

  def self.dump_tags(); end

  def self.dump_tags=(value); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(value); end

  def self.remove_type(type_tag); end

  def self.safe_dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end

  def self.unsafe_load_file(filename, **kwargs); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::Domain
  def domain(); end

  def domain?(); end

  def initialize(*args); end

  def name(); end

  def sld(); end

  def subdomain(); end

  def subdomain?(); end

  def tld(); end

  def to_a(); end

  def trd(); end
end

class PublicSuffix::Domain
  def self.name_to_labels(name); end
end

class PublicSuffix::List
  def <<(rule); end

  def ==(other); end

  def add(rule); end

  def clear(); end

  def default_rule(); end

  def each(&block); end

  def empty?(); end

  def eql?(other); end

  def find(name, default: T.unsafe(nil), **options); end

  def rules(); end

  def size(); end
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  def self.default(**options); end

  def self.default=(value); end

  def self.parse(input, private_domains: T.unsafe(nil)); end
end

class PublicSuffix::Rule::Base
  def ==(other); end

  def decompose(*arg); end

  def eql?(other); end

  def initialize(value:, length: T.unsafe(nil), private: T.unsafe(nil)); end

  def length(); end

  def match?(name); end

  def parts(); end

  def private(); end

  def value(); end
end

class PublicSuffix::Rule::Base
  def self.build(content, private: T.unsafe(nil)); end
end

class PublicSuffix::Rule::Entry
  def length=(_); end

  def private(); end

  def private=(_); end

  def type(); end

  def type=(_); end
end

class PublicSuffix::Rule::Entry
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class PublicSuffix::Rule::Exception
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Normal
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Wildcard
  def decompose(domain); end

  def rule(); end
end

module PublicSuffix::Rule
  def self.default(); end

  def self.factory(content, private: T.unsafe(nil)); end
end

module PublicSuffix
  def self.decompose(name, rule); end

  def self.domain(name, **options); end

  def self.normalize(name); end

  def self.parse(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end

  def self.valid?(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end
end

module Puma
  HAS_FORK = ::T.let(nil, ::T.untyped)
  HAS_NATIVE_IO_WAIT = ::T.let(nil, ::T.untyped)
  HAS_SSL = ::T.let(nil, ::T.untyped)
  HAS_UNIX_SOCKET = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MRI = ::T.let(nil, ::T.untyped)
  IS_OSX = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  def activated_sockets(); end

  def add_ssl_listener(host, port, ctx, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_tcp_listener(host, port, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_unix_listener(path, umask=T.unsafe(nil), mode=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def close(); end

  def close_listeners(); end

  def connected_ports(); end

  def create_activated_fds(env_hash); end

  def create_inherited_fds(env_hash); end

  def env(sock); end

  def envs(); end

  def inherit_ssl_listener(fd, ctx); end

  def inherit_tcp_listener(host, port, fd); end

  def inherit_unix_listener(path, fd); end

  def inherited_fds(); end

  def initialize(log_writer, conf=T.unsafe(nil)); end

  def ios(); end

  def ios=(ios); end

  def listeners(); end

  def listeners=(listeners); end

  def localhost_authority(); end

  def localhost_authority_context(); end

  def parse(binds, log_writer=T.unsafe(nil), log_msg=T.unsafe(nil)); end

  def proto_env(); end

  def redirects_for_restart(); end

  def redirects_for_restart_env(); end

  def synthesize_binds_from_activated_fs(binds, only_matching); end

  def unix_paths(); end
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  def body(); end

  def call(); end

  def can_close?(); end

  def close(); end

  def closed?(); end

  def eagerly_finish(); end

  def env(); end

  def expect_proxy_proto=(val); end

  def finish(timeout); end

  def hijacked(); end

  def http_content_length_limit=(http_content_length_limit); end

  def http_content_length_limit_exceeded(); end

  def in_data_phase(); end

  def initialize(io, env=T.unsafe(nil)); end

  def io(); end

  def io_buffer(); end

  def io_ok?(); end

  def listener(); end

  def listener=(listener); end

  def peer_family(); end

  def peerip(); end

  def peerip=(peerip); end

  def ready(); end

  def remote_addr_header(); end

  def remote_addr_header=(remote_addr_header); end

  def reset(fast_check=T.unsafe(nil)); end

  def set_timeout(val); end

  def tempfile(); end

  def timeout(); end

  def timeout!(); end

  def timeout_at(); end

  def to_io(); end

  def try_to_finish(); end

  def try_to_parse_proxy_protocol(); end

  def write_error(status_code); end
  ALLOWED_TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE_INVALID = ::T.let(nil, ::T.untyped)
  CHUNK_VALID_ENDING = ::T.let(nil, ::T.untyped)
  CHUNK_VALID_ENDING_SIZE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_VALUE_INVALID = ::T.let(nil, ::T.untyped)
  EmptyBody = ::T.let(nil, ::T.untyped)
  MAX_CHUNK_EXCESS = ::T.let(nil, ::T.untyped)
  MAX_CHUNK_HEADER_SIZE = ::T.let(nil, ::T.untyped)
  TE_ERR_MSG = ::T.let(nil, ::T.untyped)
end

class Puma::Cluster
  def all_workers_booted?(); end

  def all_workers_idle_timed_out?(); end

  def all_workers_in_phase?(); end

  def check_workers(); end

  def cull_start_index(diff); end

  def cull_workers(); end

  def fork_worker!(); end

  def halt(); end

  def next_worker_index(); end

  def phased_restart(refork=T.unsafe(nil)); end

  def preload?(); end

  def reload_worker_directory(); end

  def restart(); end

  def run(); end

  def setup_signals(); end

  def spawn_worker(idx, master); end

  def spawn_workers(); end

  def start_phased_restart(); end

  def stop(); end

  def stop_blocked(); end

  def stop_workers(); end

  def worker(index, master); end

  def worker_at(idx); end

  def workers(); end

  def workers_to_cull(diff); end
end

class Puma::Cluster::Worker
  def index(); end

  def initialize(index:, master:, launcher:, pipes:, server: T.unsafe(nil)); end

  def master(); end

  def run(); end
end

class Puma::Cluster::WorkerHandle
  def boot!(); end

  def booted?(); end

  def hup(); end

  def index(); end

  def initialize(idx, pid, phase, options); end

  def kill(); end

  def last_checkin(); end

  def last_status(); end

  def phase(); end

  def phase=(phase); end

  def pid(); end

  def pid=(pid); end

  def ping!(status); end

  def ping_timeout(); end

  def signal(); end

  def started_at(); end

  def term(); end

  def term!(); end

  def term?(); end

  def uptime(); end
end

class Puma::Configuration
  def app(); end

  def app_configured?(); end

  def clamp(); end

  def config_files(); end

  def configure(); end

  def environment(); end

  def final_options(); end

  def flatten(); end

  def flatten!(); end

  def initialize(user_options=T.unsafe(nil), default_options=T.unsafe(nil), &block); end

  def load(); end

  def load_plugin(name); end

  def options(); end

  def plugins(); end

  def puma_default_options(); end

  def puma_options_from_env(); end

  def rackup(); end

  def run_hooks(key, arg, log_writer, hook_data=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Puma::Configuration::ConfigMiddleware
  def call(env); end

  def initialize(config, app); end
end

class Puma::Configuration
  def self.random_token(); end

  def self.temp_path(); end
end

module Puma::Const
  BANNED_HEADER_KEY = ::T.let(nil, ::T.untyped)
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  DQUOTE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER_DELIMITER = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  IANA_HTTP_METHODS = ::T.let(nil, ::T.untyped)
  ILLEGAL_HEADER_KEY_REGEX = ::T.let(nil, ::T.untyped)
  ILLEGAL_HEADER_VALUE_REGEX = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_IPV4 = ::T.let(nil, ::T.untyped)
  LOCALHOST_IPV6 = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PROXY_PROTOCOL_V1_REGEX = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  SUPPORTED_HTTP_METHODS = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  UNSPECIFIED_IPV4 = ::T.let(nil, ::T.untyped)
  UNSPECIFIED_IPV6 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Puma::DSL
  def _load_from(path); end

  def _offer_plugins(); end

  def activate_control_app(url=T.unsafe(nil), opts=T.unsafe(nil)); end

  def after_worker_boot(&block); end

  def after_worker_fork(&block); end

  def app(obj=T.unsafe(nil), &block); end

  def before_fork(&block); end

  def bind(url); end

  def bind_to_activated_sockets(bind=T.unsafe(nil)); end

  def clean_thread_locals(which=T.unsafe(nil)); end

  def clear_binds!(); end

  def custom_logger(custom_logger); end

  def debug(); end

  def default_host(); end

  def directory(dir); end

  def drain_on_shutdown(which=T.unsafe(nil)); end

  def early_hints(answer=T.unsafe(nil)); end

  def environment(environment); end

  def extra_runtime_dependencies(answer=T.unsafe(nil)); end

  def first_data_timeout(seconds); end

  def force_shutdown_after(val=T.unsafe(nil)); end

  def fork_worker(after_requests=T.unsafe(nil)); end

  def get(key, default=T.unsafe(nil)); end

  def http_content_length_limit(limit); end

  def idle_timeout(seconds); end

  def initialize(options, config); end

  def inject(&blk); end

  def io_selector_backend(backend); end

  def load(file); end

  def log_formatter(&block); end

  def log_requests(which=T.unsafe(nil)); end

  def lowlevel_error_handler(obj=T.unsafe(nil), &block); end

  def max_fast_inline(num_of_requests); end

  def mutate_stdout_and_stderr_to_sync_on_write(enabled=T.unsafe(nil)); end

  def on_booted(&block); end

  def on_refork(key=T.unsafe(nil), &block); end

  def on_restart(&block); end

  def on_thread_exit(&block); end

  def on_thread_start(&block); end

  def on_worker_boot(key=T.unsafe(nil), &block); end

  def on_worker_fork(&block); end

  def on_worker_shutdown(key=T.unsafe(nil), &block); end

  def out_of_band(&block); end

  def persistent_timeout(seconds); end

  def pidfile(path); end

  def plugin(name); end

  def port(port, host=T.unsafe(nil)); end

  def preload_app!(answer=T.unsafe(nil)); end

  def prune_bundler(answer=T.unsafe(nil)); end

  def queue_requests(answer=T.unsafe(nil)); end

  def quiet(which=T.unsafe(nil)); end

  def rack_url_scheme(scheme=T.unsafe(nil)); end

  def rackup(path); end

  def raise_exception_on_sigterm(answer=T.unsafe(nil)); end

  def restart_command(cmd); end

  def set_default_host(host); end

  def set_remote_address(val=T.unsafe(nil)); end

  def shutdown_debug(val=T.unsafe(nil)); end

  def silence_fork_callback_warning(); end

  def silence_single_worker_warning(); end

  def ssl_bind(host, port, opts=T.unsafe(nil)); end

  def state_path(path); end

  def state_permission(permission); end

  def stdout_redirect(stdout=T.unsafe(nil), stderr=T.unsafe(nil), append=T.unsafe(nil)); end

  def supported_http_methods(methods); end

  def tag(string); end

  def threads(min, max); end

  def wait_for_less_busy_worker(val=T.unsafe(nil)); end

  def worker_boot_timeout(timeout); end

  def worker_check_interval(interval); end

  def worker_culling_strategy(strategy); end

  def worker_shutdown_timeout(timeout); end

  def worker_timeout(timeout); end

  def workers(count); end
  ON_WORKER_KEY = ::T.let(nil, ::T.untyped)
end

class Puma::DSL
  def self.ssl_bind_str(host, port, opts); end
end

class Puma::ErrorLogger
  def debug(options=T.unsafe(nil)); end

  def info(options=T.unsafe(nil)); end

  def initialize(ioerr); end

  def ioerr(); end

  def request_dump(req); end

  def request_headers(req); end

  def request_parsed?(req); end

  def request_title(req); end

  def title(options=T.unsafe(nil)); end
  LOG_QUEUE = ::T.let(nil, ::T.untyped)
  REQUEST_FORMAT = ::T.let(nil, ::T.untyped)
end

class Puma::ErrorLogger
  def self.stdio(); end
end

class Puma::Events
  def fire(hook, *args); end

  def fire_on_booted!(); end

  def fire_on_restart!(); end

  def fire_on_stopped!(); end

  def on_booted(&block); end

  def on_restart(&block); end

  def on_stopped(&block); end

  def register(hook, obj=T.unsafe(nil), &blk); end
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::IOBuffer
  def append(*arg); end

  def clear(); end

  def empty?(); end

  def initialize(); end

  def read_and_reset(); end

  def reset(); end
end

module Puma::JSONSerialization
  BACKSLASH = ::T.let(nil, ::T.untyped)
  CHAR_TO_ESCAPE = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR_TO_ESCAPE = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
end

class Puma::Launcher
  def binder(); end

  def close_binder_listeners(); end

  def config(); end

  def connected_ports(); end

  def delete_pidfile(); end

  def events(); end

  def halt(); end

  def initialize(conf, launcher_args=T.unsafe(nil)); end

  def log_writer(); end

  def options(); end

  def phased_restart(); end

  def refork(); end

  def restart(); end

  def restart_args(); end

  def restart_dir(); end

  def run(); end

  def stats(); end

  def stop(); end

  def thread_status(); end

  def write_state(); end
end

class Puma::Launcher::BundlePruner
  def initialize(original_argv, extra_runtime_dependencies, log_writer); end

  def prune(); end
end

class Puma::Launcher::BundlePruner
end

class Puma::LogWriter
  def connection_error(error, req, text=T.unsafe(nil)); end

  def custom_logger(); end

  def custom_logger=(custom_logger); end

  def debug(str); end

  def debug?(); end

  def debug_error(error, req=T.unsafe(nil), text=T.unsafe(nil)); end

  def error(str); end

  def format(str); end

  def formatter(); end

  def formatter=(formatter); end

  def initialize(stdout, stderr); end

  def log(str); end

  def parse_error(error, req); end

  def ssl_error(error, ssl_socket); end

  def stderr(); end

  def stdout(); end

  def unknown_error(error, req=T.unsafe(nil), text=T.unsafe(nil)); end

  def write(str); end
  DEFAULT = ::T.let(nil, ::T.untyped)
  LOG_QUEUE = ::T.let(nil, ::T.untyped)
end

class Puma::LogWriter::DefaultFormatter
  def call(str); end
end

class Puma::LogWriter::PidFormatter
  def call(str); end
end

class Puma::LogWriter
  def self.null(); end

  def self.stdio(); end

  def self.strings(); end
end

module Puma::MiniSSL
  HAS_TLS1_3 = ::T.let(nil, ::T.untyped)
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_SSL3 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1_1 = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
  VERIFICATION_FLAGS = ::T.let(nil, ::T.untyped)
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::ContextBuilder
  def context(); end

  def initialize(params, log_writer); end
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::SSLError
end

class Puma::NullIO
  def close(); end

  def closed?(); end

  def each(&blk); end

  def eof?(); end

  def flush(); end

  def gets(); end

  def puts(*ary); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def string(); end

  def sync(); end

  def sync=(v); end

  def write(*ary); end
end

class Puma::Plugin
  def in_background(&blk); end
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Plugin
  def self.create(&blk); end

  def self.extract_name(ary); end
end

class Puma::PluginLoader
  def create(name); end

  def fire_starts(launcher); end
end

class Puma::PluginRegistry
  def add_background(blk); end

  def find(name); end

  def fire_background(); end

  def register(name, cls); end
end

class Puma::Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Puma::Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Puma::Rack::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Puma::Reactor
  def add(client); end

  def initialize(backend, &block); end

  def run(background=T.unsafe(nil)); end

  def shutdown(); end
end

module Puma::Request
  def default_server_port(env); end

  def handle_request(client, requests); end

  def prepare_response(status, headers, res_body, requests, client); end
  BODY_LEN_MAX = ::T.let(nil, ::T.untyped)
  CUSTOM_STAT = ::T.let(nil, ::T.untyped)
  IO_BODY_MAX = ::T.let(nil, ::T.untyped)
  IO_BUFFER_LEN_MAX = ::T.let(nil, ::T.untyped)
  SOCKET_WRITE_ERR_MSG = ::T.let(nil, ::T.untyped)
end

class Puma::Runner
  def app(); end

  def close_control_listeners(); end

  def debug(str); end

  def development?(); end

  def error(str); end

  def initialize(launcher); end

  def load_and_bind(); end

  def log(str); end

  def options(); end

  def output_header(mode); end

  def redirect_io(); end

  def redirected_io?(); end

  def ruby_engine(); end

  def start_control(); end

  def start_server(); end

  def stop_control(); end

  def test?(); end

  def wakeup!(); end
end

class Puma::Server
  def add_ssl_listener(host, port, ctx, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_tcp_listener(host, port, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_unix_listener(path, umask=T.unsafe(nil), mode=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def app(); end

  def app=(app); end

  def auto_trim_time(); end

  def backlog(); end

  def begin_restart(sync=T.unsafe(nil)); end

  def binder(); end

  def binder=(binder); end

  def client_error(e, client, requests=T.unsafe(nil)); end

  def closed_socket?(socket); end

  def connected_ports(); end

  def cork_socket(socket); end

  def early_hints(); end

  def events(); end

  def first_data_timeout(); end

  def graceful_shutdown(); end

  def halt(sync=T.unsafe(nil)); end

  def handle_check(); end

  def handle_servers(); end

  def inherit_binder(bind); end

  def initialize(app, events=T.unsafe(nil), options=T.unsafe(nil)); end

  def leak_stack_on_error(); end

  def log_writer(); end

  def lowlevel_error(e, env, status=T.unsafe(nil)); end

  def max_threads(); end

  def min_threads(); end

  def persistent_timeout(); end

  def pool_capacity(); end

  def process_client(client); end

  def reactor_wakeup(client); end

  def reaping_time(); end

  def requests_count(); end

  def run(background=T.unsafe(nil), thread_name: T.unsafe(nil)); end

  def running(); end

  def shutting_down?(); end

  def stats(); end

  def stop(sync=T.unsafe(nil)); end

  def thread(); end

  def uncork_socket(socket); end

  def with_force_shutdown(client, &block); end
  STAT_METHODS = ::T.let(nil, ::T.untyped)
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
  UNPACK_TCP_STATE_FROM_TCP_INFO = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  def self.current(); end
end

class Puma::Single
  def halt(); end

  def restart(); end

  def run(); end

  def stop(); end

  def stop_blocked(); end
end

class Puma::ThreadPool
  def <<(work); end

  def auto_reap!(timeout=T.unsafe(nil)); end

  def auto_trim!(timeout=T.unsafe(nil)); end

  def backlog(); end

  def busy_threads(); end

  def initialize(name, options=T.unsafe(nil), &block); end

  def pool_capacity(); end

  def reap(); end

  def shutdown(timeout=T.unsafe(nil)); end

  def spawned(); end

  def trim(force=T.unsafe(nil)); end

  def trim_requested(); end

  def wait_for_less_busy_worker(delay_s); end

  def wait_until_not_full(); end

  def waiting(); end

  def with_force_shutdown(); end

  def with_mutex(&block); end
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool::Automaton
  def initialize(pool, timeout, thread_name, message); end

  def start!(); end

  def stop(); end
end

class Puma::ThreadPool
  def self.clean_thread_locals(); end
end

class Puma::UserFileDefaultOptions
  def [](key); end

  def []=(key, value); end

  def all_of(key); end

  def default_options(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def file_options(); end

  def final_options(); end

  def finalize_values(); end

  def initialize(user_options, default_options); end

  def user_options(); end
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Puma::Util::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def replace(other); end
end

class Puma::Util::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

module Puma::Util
  def self.escape(s, encoding=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.pipe(); end

  def self.purge_interrupt_queue(); end

  def self.unescape(s, encoding=T.unsafe(nil)); end
end

module Pundit
  SUFFIX = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RBI::Arg
  def ==(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end

  def value(*args, **arg, &blk); end
end

class RBI::Attr
  def fully_qualified_names(*args, **arg, &blk); end

  def names(*args, **arg, &blk); end

  def sigs(*args, **arg, &blk); end

  def visibility(*args, **arg, &blk); end

  def visibility=(visibility); end
end

class RBI::AttrAccessor
  def to_s(*args, **arg, &blk); end
end

class RBI::AttrReader
  def to_s(*args, **arg, &blk); end
end

class RBI::AttrWriter
  def to_s(*args, **arg, &blk); end
end

class RBI::BlockParam
  def ==(*args, **arg, &blk); end
end

class RBI::Class
  def name(*args, **arg, &blk); end

  def name=(name); end

  def superclass_name(*args, **arg, &blk); end

  def superclass_name=(superclass_name); end
end

class RBI::Comment
  def ==(*args, **arg, &blk); end

  def text(*args, **arg, &blk); end

  def text=(text); end
end

class RBI::Const
  def fully_qualified_name(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end

  def value(); end
end

class RBI::Extend
  def to_s(*args, **arg, &blk); end
end

class RBI::File
  def <<(*args, **arg, &blk); end

  def comments(*args, **arg, &blk); end

  def comments=(comments); end

  def empty?(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def root(*args, **arg, &blk); end

  def root=(root); end

  def strictness(*args, **arg, &blk); end

  def strictness=(strictness); end
end

class RBI::Helper
  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Include
  def to_s(*args, **arg, &blk); end
end

class RBI::Index
  def [](*args, **arg, &blk); end

  def index(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def keys(*args, **arg, &blk); end
end

class RBI::Index
  def self.index(*args, **arg, &blk); end
end

module RBI::Indexable
  def index_ids(*args, **arg, &blk); end
end

class RBI::KwArg
  def keyword(*args, **arg, &blk); end
end

class RBI::KwOptParam
  def ==(*args, **arg, &blk); end

  def value(*args, **arg, &blk); end
end

class RBI::KwParam
  def ==(*args, **arg, &blk); end
end

class RBI::KwRestParam
  def ==(*args, **arg, &blk); end
end

class RBI::Loc
  def begin_column(); end

  def begin_line(*args, **arg, &blk); end

  def end_column(); end

  def end_line(); end

  def file(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def source(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Loc
  def self.from_prism(*args, **arg, &blk); end
end

class RBI::Method
  def <<(*args, **arg, &blk); end

  def add_block_param(*args, **arg, &blk); end

  def add_kw_opt_param(*args, **arg, &blk); end

  def add_kw_param(*args, **arg, &blk); end

  def add_kw_rest_param(*args, **arg, &blk); end

  def add_opt_param(*args, **arg, &blk); end

  def add_param(*args, **arg, &blk); end

  def add_rest_param(*args, **arg, &blk); end

  def add_sig(*args, **arg, &blk); end

  def fully_qualified_name(*args, **arg, &blk); end

  def is_singleton(*args, **arg, &blk); end

  def is_singleton=(is_singleton); end

  def name(*args, **arg, &blk); end

  def name=(name); end

  def params(*args, **arg, &blk); end

  def sigs(*args, **arg, &blk); end

  def sigs=(sigs); end

  def to_s(*args, **arg, &blk); end

  def visibility(*args, **arg, &blk); end

  def visibility=(visibility); end
end

class RBI::MixesInClassMethods
  def to_s(*args, **arg, &blk); end
end

class RBI::Mixin
  def names(*args, **arg, &blk); end
end

class RBI::Module
  def name(*args, **arg, &blk); end

  def name=(name); end
end

class RBI::Node
  def detach(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def loc(*args, **arg, &blk); end

  def loc=(loc); end

  def parent_scope(*args, **arg, &blk); end

  def parent_tree(*args, **arg, &blk); end

  def parent_tree=(parent_tree); end

  def replace(*args, **arg, &blk); end

  def satisfies_version?(*args, **arg, &blk); end
end

class RBI::NodeWithComments
  def annotations(*args, **arg, &blk); end

  def comments(*args, **arg, &blk); end

  def comments=(comments); end

  def version_requirements(*args, **arg, &blk); end
end

class RBI::OptParam
  def ==(*args, **arg, &blk); end

  def value(*args, **arg, &blk); end
end

class RBI::Param
  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::ReqParam
  def ==(*args, **arg, &blk); end
end

class RBI::RequiresAncestor
  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::RestParam
  def ==(*args, **arg, &blk); end
end

class RBI::Rewriters::AddSigTemplates
  def initialize(*args, **arg, &blk); end
end

class RBI::Rewriters::Annotate
  def initialize(*args, **arg, &blk); end
end

class RBI::Rewriters::Deannotate
  def initialize(*args, **arg, &blk); end
end

class RBI::Rewriters::FilterVersions
  def initialize(*args, **arg, &blk); end
  VERSION_PREFIX = ::T.let(nil, ::T.untyped)
end

class RBI::Rewriters::FilterVersions
  def self.filter(*args, **arg, &blk); end
end

class RBI::Rewriters::Merge
  def initialize(*args, **arg, &blk); end

  def merge(*args, **arg, &blk); end

  def tree(*args, **arg, &blk); end
end

class RBI::Rewriters::Merge::Conflict
  def self.inherited(grandchild); end
end

class RBI::Rewriters::Merge::Keep
  LEFT = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  RIGHT = ::T.let(nil, ::T.untyped)
end

class RBI::Rewriters::Merge
  def self.merge_trees(*args, **arg, &blk); end
end

class RBI::Scope
  def fully_qualified_name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Send
  def <<(*args, **arg, &blk); end

  def ==(*args, **arg, &blk); end

  def args(*args, **arg, &blk); end

  def method(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::Sig
  def <<(*args, **arg, &blk); end

  def ==(*args, **arg, &blk); end

  def add_param(*args, **arg, &blk); end

  def checked(*args, **arg, &blk); end

  def checked=(checked); end

  def is_abstract(*args, **arg, &blk); end

  def is_abstract=(is_abstract); end

  def is_final(); end

  def is_final=(is_final); end

  def is_overridable(); end

  def is_overridable=(is_overridable); end

  def is_override(); end

  def is_override=(is_override); end

  def params(*args, **arg, &blk); end

  def return_type(*args, **arg, &blk); end

  def return_type=(return_type); end

  def type_params(*args, **arg, &blk); end
end

class RBI::SigParam
  def ==(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def type(); end
end

class RBI::Struct
  def keyword_init(*args, **arg, &blk); end

  def keyword_init=(keyword_init); end

  def members(*args, **arg, &blk); end

  def members=(members); end

  def name(*args, **arg, &blk); end

  def name=(name); end
end

class RBI::TEnumBlock
  def <<(*args, **arg, &blk); end

  def empty?(*args, **arg, &blk); end

  def names(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end
end

class RBI::TStructConst
  def to_s(*args, **arg, &blk); end
end

class RBI::TStructField
  def default(*args, **arg, &blk); end

  def default=(default); end

  def fully_qualified_names(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def name=(name); end

  def type(); end

  def type=(type); end
end

class RBI::TStructProp
  def to_s(*args, **arg, &blk); end
end

class RBI::Tree
  def <<(*args, **arg, &blk); end

  def add_sig_templates!(*args, **arg, &blk); end

  def annotate!(*args, **arg, &blk); end

  def deannotate!(*args, **arg, &blk); end

  def empty?(*args, **arg, &blk); end

  def filter_versions!(*args, **arg, &blk); end

  def index(*args, **arg, &blk); end

  def nodes(*args, **arg, &blk); end
end

class RBI::TypeMember
  def fully_qualified_name(*args, **arg, &blk); end

  def name(*args, **arg, &blk); end

  def to_s(*args, **arg, &blk); end

  def value(); end
end

class RBI::Visibility
  def ==(*args, **arg, &blk); end

  def private?(*args, **arg, &blk); end

  def protected?(*args, **arg, &blk); end

  def public?(*args, **arg, &blk); end

  def visibility(*args, **arg, &blk); end
end

class RBI::Visitor
  def visit(*args, **arg, &blk); end

  def visit_all(*args, **arg, &blk); end
end

module RBS
  VERSION = ::T.let(nil, ::T.untyped)
end

class RBS::AST::Annotation
  def ==(other); end

  def eql?(other); end

  def initialize(string:, location:); end

  def location(); end

  def string(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Comment
  def ==(other); end

  def eql?(other); end

  def initialize(string:, location:); end

  def location(); end

  def string(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::Alias
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, type:, annotations:, location:, comment:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end

  def type_params(); end
end

class RBS::AST::Declarations::Class
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, super_class:, members:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def super_class(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end
end

class RBS::AST::Declarations::Class::Super
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, location:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::Constant
  def ==(other); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type:, location:, comment:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::AST::Declarations::Global
  def ==(other); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type:, location:, comment:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::AST::Declarations::Interface
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, members:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end
end

module RBS::AST::Declarations::MixinHelper
  def each_mixin(&block); end
end

class RBS::AST::Declarations::Module
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, members:, self_types:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def self_types(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end
end

class RBS::AST::Declarations::Module::Self
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, location:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end
end

module RBS::AST::Declarations::NestedDeclarationHelper
  def each_decl(); end

  def each_member(); end
end

class RBS::AST::Members::Alias
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(new_name:, old_name:, kind:, annotations:, location:, comment:); end

  def instance?(); end

  def kind(); end

  def location(); end

  def new_name(); end

  def old_name(); end

  def singleton?(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrAccessor
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrReader
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrWriter
  def to_json(state=T.unsafe(nil)); end
end

module RBS::AST::Members::Attribute
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, type:, ivar_name:, kind:, annotations:, location:, comment:, visibility: T.unsafe(nil)); end

  def ivar_name(); end

  def kind(); end

  def location(); end

  def name(); end

  def type(); end

  def update(name: T.unsafe(nil), type: T.unsafe(nil), ivar_name: T.unsafe(nil), kind: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def visibility(); end
end

class RBS::AST::Members::ClassInstanceVariable
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::ClassVariable
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Extend
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Include
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::InstanceVariable
  def to_json(state=T.unsafe(nil)); end
end

module RBS::AST::Members::LocationOnly
  def ==(other); end

  def eql?(other); end

  def hash(); end

  def initialize(location:); end

  def location(); end
end

class RBS::AST::Members::MethodDefinition
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, kind:, types:, annotations:, location:, comment:, overload:, visibility: T.unsafe(nil)); end

  def instance?(); end

  def kind(); end

  def location(); end

  def name(); end

  def overload(); end

  def overload?(); end

  def singleton?(); end

  def to_json(state=T.unsafe(nil)); end

  def types(); end

  def update(name: T.unsafe(nil), kind: T.unsafe(nil), types: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), overload: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def visibility(); end
end

module RBS::AST::Members::Mixin
  def ==(other); end

  def annotations(); end

  def args(); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, args:, annotations:, location:, comment:); end

  def location(); end

  def name(); end
end

class RBS::AST::Members::Prepend
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Private
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Public
  def to_json(state=T.unsafe(nil)); end
end

module RBS::AST::Members::Var
  def ==(other); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, type:, location:, comment:); end

  def location(); end

  def name(); end

  def type(); end
end

class RBS::AST::TypeParam
  def ==(other); end

  def eql?(other); end

  def initialize(name:, variance:, upper_bound:, location:); end

  def location(); end

  def map_type(&block); end

  def name(); end

  def rename(name); end

  def to_json(state=T.unsafe(nil)); end

  def unchecked!(value=T.unsafe(nil)); end

  def unchecked?(); end

  def upper_bound(); end

  def variance(); end
end

class RBS::AST::TypeParam
  def self.rename(params, new_names:); end

  def self.resolve_variables(params); end

  def self.subst_var(vars, type); end
end

class RBS::AncestorGraph
  def ancestor_builder(); end

  def build(); end

  def build_ancestors(node, ancestors); end

  def children(); end

  def each_ancestor(node, yielded: T.unsafe(nil), &block); end

  def each_child(node, &block); end

  def each_descendant(node, yielded: T.unsafe(nil), &block); end

  def each_parent(node, &block); end

  def env(); end

  def initialize(env:, ancestor_builder: T.unsafe(nil)); end

  def parents(); end

  def register(parent:, child:); end
end

class RBS::AncestorGraph::InstanceNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::AncestorGraph::InstanceNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::AncestorGraph::SingletonNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::AncestorGraph::SingletonNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Buffer
  def content(); end

  def initialize(name:, content:); end

  def last_position(); end

  def lines(); end

  def loc_to_pos(loc); end

  def name(); end

  def pos_to_loc(pos); end

  def ranges(); end
end

module RBS::BuiltinNames
  Array = ::T.let(nil, ::T.untyped)
  BasicObject = ::T.let(nil, ::T.untyped)
  Class = ::T.let(nil, ::T.untyped)
  Comparable = ::T.let(nil, ::T.untyped)
  Enumerable = ::T.let(nil, ::T.untyped)
  Enumerator = ::T.let(nil, ::T.untyped)
  FalseClass = ::T.let(nil, ::T.untyped)
  Float = ::T.let(nil, ::T.untyped)
  Hash = ::T.let(nil, ::T.untyped)
  Integer = ::T.let(nil, ::T.untyped)
  Kernel = ::T.let(nil, ::T.untyped)
  Module = ::T.let(nil, ::T.untyped)
  Numeric = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  Regexp = ::T.let(nil, ::T.untyped)
  Set = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
  TrueClass = ::T.let(nil, ::T.untyped)
end

class RBS::BuiltinNames::Name
  def initialize(name:); end

  def instance_type(*args); end

  def instance_type?(type); end

  def name(); end

  def singleton_type(); end

  def singleton_type?(type); end
end

class RBS::BuiltinNames::Name
  def self.define(name, namespace: T.unsafe(nil)); end
end

class RBS::Collection::Cleaner
  def clean(); end

  def initialize(lockfile_path:); end

  def lock(); end

  def needed?(gem_name, version); end
end

class RBS::Collection::Config
  def add_gem(gem); end

  def check_rbs_availability!(); end

  def dump_to(io); end

  def gem(gem_name); end

  def gemfile_lock_path(); end

  def gemfile_lock_path=(path); end

  def gems(); end

  def initialize(data, config_path:); end

  def repo_path(); end

  def sources(); end
  PATH = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Config::CollectionNotAvailable
  def initialize(); end
end

class RBS::Collection::Config::LockfileGenerator
  def config(); end

  def gemfile_lock(); end

  def generate(); end

  def initialize(config_path:, gemfile_lock_path:, with_lockfile:); end

  def lock(); end

  def lock_path(); end
end

class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError
  def initialize(expected:, actual:); end
end

class RBS::Collection::Config::LockfileGenerator
  def self.generate(config_path:, gemfile_lock_path:, with_lockfile: T.unsafe(nil)); end
end

class RBS::Collection::Config
  def self.find_config_path(); end

  def self.from_path(path); end

  def self.generate_lockfile(config_path:, gemfile_lock_path:, with_lockfile: T.unsafe(nil)); end

  def self.lockfile_of(config_path); end

  def self.to_lockfile_path(config_path); end
end

class RBS::Collection::Installer
  def initialize(lockfile_path:, stdout: T.unsafe(nil)); end

  def install_from_lockfile(); end

  def lockfile(); end

  def stdout(); end
end

module RBS::Collection::Sources::Base
  def dependencies_of(config_entry); end
end

class RBS::Collection::Sources::Git
  def has?(config_entry); end

  def initialize(name:, revision:, remote:, repo_dir:); end

  def install(dest:, config_entry:, stdout:); end

  def manifest_of(config_entry); end

  def name(); end

  def remote(); end

  def repo_dir(); end

  def to_lockfile(); end

  def versions(config_entry); end
  METADATA_FILENAME = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Sources::Rubygems
  def has?(config_entry); end

  def install(dest:, config_entry:, stdout:); end

  def manifest_of(config_entry); end

  def to_lockfile(); end

  def versions(config_entry); end
end

class RBS::Collection::Sources::Stdlib
  def has?(config_entry); end

  def install(dest:, config_entry:, stdout:); end

  def manifest_of(config_entry); end

  def to_lockfile(); end

  def versions(config_entry); end
  REPO = ::T.let(nil, ::T.untyped)
end

module RBS::Collection::Sources
  def self.from_config_entry(source_entry); end
end

class RBS::Constant
  def ==(other); end

  def entry(); end

  def eql?(other); end

  def initialize(name:, type:, entry:); end

  def name(); end

  def type(); end
end

class RBS::ConstantTable
  def absolute_type(type, context:); end

  def absolute_type_name(type_name, context:, location:); end

  def constant_scopes(name); end

  def constant_scopes0(name, scopes: T.unsafe(nil)); end

  def constant_scopes_cache(); end

  def constant_scopes_module(name, scopes:); end

  def definition_builder(); end

  def env(); end

  def initialize(builder:); end

  def name_to_constant(name); end

  def resolve_constant_reference(name, context:); end

  def resolve_constant_reference_context(name, context:); end

  def resolve_constant_reference_inherit(name, scopes:, no_object: T.unsafe(nil)); end

  def resolver(); end

  def split_name(name); end
end

class RBS::CyclicTypeParameterBound
  def initialize(type_name:, method_name:, params:, location:); end

  def location(); end

  def method_name(); end

  def params(); end

  def type_name(); end
end

class RBS::Definition
  def ancestors(); end

  def class?(); end

  def class_type?(); end

  def class_variables(); end

  def each_type(&block); end

  def entry(); end

  def initialize(type_name:, entry:, self_type:, ancestors:); end

  def instance_type?(); end

  def interface?(); end

  def interface_type?(); end

  def map_method_type(&block); end

  def methods(); end

  def module?(); end

  def self_type(); end

  def sub(s); end

  def type_name(); end

  def type_params(); end

  def type_params_decl(); end
end

class RBS::Definition::Ancestor::Instance
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, source:); end

  def name(); end

  def source(); end
end

class RBS::Definition::Ancestor::Singleton
  def ==(other); end

  def eql?(other); end

  def initialize(name:); end

  def name(); end
end

class RBS::Definition::InstanceAncestors
  def ancestors(); end

  def apply(args, location:); end

  def initialize(type_name:, params:, ancestors:); end

  def params(); end

  def type_name(); end
end

class RBS::Definition::Method
  def ==(other); end

  def accessibility(); end

  def alias_of(); end

  def annotations(); end

  def comments(); end

  def defined_in(); end

  def defs(); end

  def eql?(other); end

  def extra_annotations(); end

  def implemented_in(); end

  def initialize(super_method:, defs:, accessibility:, alias_of:, annotations: T.unsafe(nil)); end

  def map_method_type(&block); end

  def map_type(&block); end

  def map_type_bound(&block); end

  def members(); end

  def method_types(); end

  def private?(); end

  def public?(); end

  def sub(s); end

  def super_method(); end

  def update(super_method: T.unsafe(nil), defs: T.unsafe(nil), accessibility: T.unsafe(nil), alias_of: T.unsafe(nil), annotations: T.unsafe(nil)); end
end

class RBS::Definition::Method::TypeDef
  def ==(other); end

  def annotations(); end

  def comment(); end

  def defined_in(); end

  def eql?(other); end

  def implemented_in(); end

  def initialize(type:, member:, defined_in:, implemented_in:); end

  def member(); end

  def overload?(); end

  def type(); end

  def update(type: T.unsafe(nil), member: T.unsafe(nil), defined_in: T.unsafe(nil), implemented_in: T.unsafe(nil)); end
end

class RBS::Definition::SingletonAncestors
  def ancestors(); end

  def initialize(type_name:, ancestors:); end

  def type_name(); end
end

class RBS::Definition::Variable
  def declared_in(); end

  def initialize(parent_variable:, type:, declared_in:); end

  def parent_variable(); end

  def sub(s); end

  def type(); end
end

class RBS::DefinitionBuilder
  def ancestor_builder(); end

  def build_instance(type_name, no_self_types: T.unsafe(nil)); end

  def build_interface(type_name); end

  def build_singleton(type_name); end

  def build_singleton0(type_name); end

  def define_methods(definition, methods:, interface_methods:, methods_with_self:, super_interface_method:); end

  def define_methods_instance(definition, methods:, interface_methods:); end

  def define_methods_module_instance(definition, methods:, interface_methods:, module_self_methods:); end

  def define_methods_singleton(definition, methods:, interface_methods:); end

  def ensure_namespace!(namespace, location:); end

  def env(); end

  def expand_alias(type_name); end

  def expand_alias1(type_name); end

  def expand_alias2(type_name, args); end

  def initialize(env:, ancestor_builder: T.unsafe(nil), method_builder: T.unsafe(nil)); end

  def insert_variable(type_name, variables, name:, type:); end

  def instance_cache(); end

  def interface_cache(); end

  def merge_definition(src:, dest:, subst:, implemented_in: T.unsafe(nil), keep_super: T.unsafe(nil)); end

  def merge_method(type_name, methods, name, method, sub, implemented_in: T.unsafe(nil), keep_super: T.unsafe(nil)); end

  def merge_variable(variables, name, variable, sub, keep_super: T.unsafe(nil)); end

  def method_builder(); end

  def singleton0_cache(); end

  def singleton_cache(); end

  def source_location(source, decl); end

  def try_cache(type_name, cache:, key: T.unsafe(nil)); end

  def type_name_resolver(); end

  def update(env:, except:, ancestor_builder:); end

  def validate_params_with(type_params, result:); end

  def validate_type_name(name, location); end

  def validate_type_params(definition, ancestors:, methods:); end

  def validate_type_presence(type); end
end

class RBS::DefinitionBuilder::AncestorBuilder
  def env(); end

  def initialize(env:); end

  def instance_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def instance_ancestors_cache(); end

  def interface_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def interface_ancestors_cache(); end

  def mixin_ancestors(entry, type_name, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end

  def mixin_ancestors0(decl, type_name, align_params:, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end

  def one_instance_ancestors(type_name); end

  def one_instance_ancestors_cache(); end

  def one_interface_ancestors(type_name); end

  def one_interface_ancestors_cache(); end

  def one_singleton_ancestors(type_name); end

  def one_singleton_ancestors_cache(); end

  def singleton_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def singleton_ancestors_cache(); end

  def validate_super_class!(type_name, entry); end
end

class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def each_ancestor(&block); end

  def each_extended_interface(&block); end

  def each_extended_module(&block); end

  def each_included_interface(&block); end

  def each_included_module(&block); end

  def each_prepended_module(&block); end

  def each_self_type(&block); end

  def extended_interfaces(); end

  def extended_modules(); end

  def included_interfaces(); end

  def included_modules(); end

  def initialize(type_name:, params:, super_class:, self_types:, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end

  def params(); end

  def prepended_modules(); end

  def self_types(); end

  def super_class(); end

  def type_name(); end
end

class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def self.class_instance(type_name:, params:, super_class:); end

  def self.interface(type_name:, params:); end

  def self.module_instance(type_name:, params:); end

  def self.singleton(type_name:, super_class:); end
end

class RBS::DefinitionBuilder::MethodBuilder
  def build_alias(methods, type, member:); end

  def build_attribute(methods, type, member:, accessibility:); end

  def build_instance(type_name); end

  def build_interface(type_name); end

  def build_method(methods, type, member:, accessibility:); end

  def build_singleton(type_name); end

  def each_member_with_accessibility(members, accessibility: T.unsafe(nil)); end

  def env(); end

  def initialize(env:); end

  def instance_methods(); end

  def interface_methods(); end

  def singleton_methods(); end

  def update(env:, except:); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods
  def each(&blk); end

  def initialize(type:); end

  def methods(); end

  def type(); end

  def validate!(); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition
  def accessibilities(); end

  def accessibilities=(_); end

  def accessibility(); end

  def name(); end

  def name=(_); end

  def original(); end

  def originals(); end

  def originals=(_); end

  def overloads(); end

  def overloads=(_); end

  def type(); end

  def type=(_); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition
  def self.[](*arg); end

  def self.empty(name:, type:); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
  def initialize(methods); end

  def methods(); end

  def tsort_each_child(defn); end

  def tsort_each_node(&block); end
end

class RBS::DuplicatedDeclarationError
  def decls(); end

  def initialize(name, *decls); end

  def name(); end
end

class RBS::DuplicatedInterfaceMethodDefinitionError
  def initialize(type:, method_name:, member:); end

  def member(); end

  def method_name(); end

  def qualified_method_name(); end

  def type(); end

  def type_name(); end
end

class RBS::DuplicatedMethodDefinitionError
  def initialize(type:, method_name:, members:); end

  def location(); end

  def members(); end

  def method_name(); end

  def other_locations(); end

  def qualified_method_name(); end

  def type(); end

  def type_name(); end
end

class RBS::Environment
  def <<(decl); end

  def absolute_type(resolver, type, context:); end

  def absolute_type_name(resolver, type_name, context:); end

  def alias_decls(); end

  def buffers(); end

  def buffers_decls(); end

  def cache_name(cache, name:, decl:, outer:); end

  def class_decls(); end

  def constant_decls(); end

  def declarations(); end

  def foo(); end

  def global_decls(); end

  def insert_decl(decl, outer:, namespace:); end

  def interface_decls(); end

  def reject(); end

  def resolve_declaration(resolver, decl, outer:, prefix:); end

  def resolve_member(resolver, member, context:); end

  def resolve_method_type(resolver, type, context:); end

  def resolve_type_names(only: T.unsafe(nil)); end

  def resolve_type_params(resolver, params, context:); end

  def validate_type_params(); end
end

module RBS::Environment::ContextUtil
  def calculate_context(decls); end
end

class RBS::Environment::ModuleEntry
  def self_types(); end
end

class RBS::Environment::MultiEntry
  def compatible_params?(ps1, ps2); end

  def decls(); end

  def initialize(name:); end

  def insert(decl:, outer:); end

  def name(); end

  def primary(); end

  def type_params(); end

  def validate_type_params(); end
end

class RBS::Environment::MultiEntry::D
  def context(); end

  def decl(); end

  def decl=(_); end

  def outer(); end

  def outer=(_); end
end

class RBS::Environment::MultiEntry::D
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Environment::SingleEntry
  def context(); end

  def decl(); end

  def initialize(name:, decl:, outer:); end

  def name(); end

  def outer(); end
end

class RBS::Environment
  def self.from_loader(loader); end
end

class RBS::EnvironmentLoader
  def add(path: T.unsafe(nil), library: T.unsafe(nil), version: T.unsafe(nil), resolve_dependencies: T.unsafe(nil)); end

  def add_collection(collection_config); end

  def core_root(); end

  def dirs(); end

  def each_decl(); end

  def each_dir(); end

  def each_file(path, immediate:, skip_hidden:, &block); end

  def has_library?(library:, version:); end

  def initialize(core_root: T.unsafe(nil), repository: T.unsafe(nil)); end

  def libs(); end

  def load(env:); end

  def repository(); end

  def resolve_dependencies(library:, version:); end
  DEFAULT_CORE_ROOT = ::T.let(nil, ::T.untyped)
end

class RBS::EnvironmentLoader::Library
  def name(); end

  def name=(_); end

  def version(); end

  def version=(_); end
end

class RBS::EnvironmentLoader::Library
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentLoader::UnknownLibraryError
  def initialize(lib:); end

  def library(); end
end

class RBS::EnvironmentLoader
  def self.gem_sig_path(name, version); end
end

class RBS::EnvironmentWalker
  def builder(); end

  def each_type_name(type, &block); end

  def each_type_node(type, &block); end

  def env(); end

  def initialize(env:); end

  def only_ancestors!(only=T.unsafe(nil)); end

  def only_ancestors?(); end

  def tsort_each_child(node, &block); end

  def tsort_each_node(&block); end
end

class RBS::EnvironmentWalker::InstanceNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::InstanceNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentWalker::SingletonNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::SingletonNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentWalker::TypeNameNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::TypeNameNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Factory
  def type_name(string); end
end

class RBS::GenericParameterMismatchError
  def decl(); end

  def initialize(name:, decl:); end

  def name(); end
end

class RBS::InheritModuleError
  def initialize(super_decl); end

  def super_decl(); end
end

class RBS::InheritModuleError
  def self.check!(super_decl, env:); end
end

class RBS::InvalidOverloadMethodError
  def initialize(type_name:, method_name:, kind:, members:); end

  def kind(); end

  def members(); end

  def method_name(); end

  def type_name(); end
end

class RBS::InvalidTypeApplicationError
  def args(); end

  def initialize(type_name:, args:, params:, location:); end

  def location(); end

  def params(); end

  def type_name(); end
end

class RBS::InvalidTypeApplicationError
  def self.check!(type_name:, args:, params:, location:); end
end

class RBS::InvalidVarianceAnnotationError
  def initialize(type_name:, param:, location:); end

  def location(); end

  def param(); end

  def type_name(); end
end

class RBS::Location
  def ==(other); end

  def [](arg); end

  def _add_optional_child(arg, arg1, arg2); end

  def _add_optional_no_child(arg); end

  def _add_required_child(arg, arg1, arg2); end

  def _optional_keys(); end

  def _required_keys(); end

  def add_optional_child(name, range); end

  def add_required_child(name, range); end

  def aref(arg); end

  def buffer(); end

  def each_optional_key(&block); end

  def each_required_key(&block); end

  def end_column(); end

  def end_line(); end

  def end_loc(); end

  def end_pos(); end

  def initialize(arg, arg1, arg2); end

  def key?(name); end

  def name(); end

  def optional_key?(name); end

  def range(); end

  def required_key?(name); end

  def source(); end

  def start_column(); end

  def start_line(); end

  def start_loc(); end

  def start_pos(); end

  def to_json(state=T.unsafe(nil)); end
end

RBS::Location::WithChildren = RBS::Location

class RBS::Location
  def self.new(buffer_=T.unsafe(nil), start_pos_=T.unsafe(nil), end_pos_=T.unsafe(nil), buffer: T.unsafe(nil), start_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def self.to_string(location, default: T.unsafe(nil)); end
end

class RBS::Locator
  def buffer(); end

  def decls(); end

  def find(line:, column:); end

  def find2(line:, column:); end

  def find_in_decl(pos, decl:, array:); end

  def find_in_loc(pos, location:, array:); end

  def find_in_member(pos, member:, array:); end

  def find_in_method_type(pos, method_type:, array:); end

  def find_in_type(pos, type:, array:); end

  def find_in_type_param(pos, type_param:, array:); end

  def initialize(decls:); end

  def test_loc(pos, location:); end
end

module RBS::MethodNameHelper
  def method_name_string(); end
end

class RBS::MethodType
  def ==(other); end

  def block(); end

  def each_type(&block); end

  def free_variables(set=T.unsafe(nil)); end

  def initialize(type_params:, type:, block:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_bound(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end

  def type_param_names(); end

  def type_params(); end

  def update(type_params: T.unsafe(nil), type: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end
end

class RBS::MixinClassError
  def initialize(type_name:, member:); end

  def location(); end

  def member(); end

  def type_name(); end
end

class RBS::MixinClassError
  def self.check!(type_name:, env:, member:); end
end

class RBS::Namespace
  def +(other); end

  def ==(other); end

  def absolute!(); end

  def absolute?(); end

  def append(component); end

  def ascend(); end

  def empty?(); end

  def eql?(other); end

  def initialize(path:, absolute:); end

  def parent(); end

  def path(); end

  def relative!(); end

  def relative?(); end

  def split(); end

  def to_type_name(); end
end

class RBS::Namespace
  def self.empty(); end

  def self.parse(string); end

  def self.root(); end
end

class RBS::NoMixinFoundError
  def initialize(type_name:, member:); end

  def location(); end

  def member(); end

  def type_name(); end
end

class RBS::NoMixinFoundError
  def self.check!(type_name, env:, member:); end
end

class RBS::NoSelfTypeFoundError
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoSelfTypeFoundError
  def self.check!(self_type, env:); end
end

class RBS::NoSuperclassFoundError
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoSuperclassFoundError
  def self.check!(type_name, env:, location:); end
end

class RBS::NoTypeFoundError
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoTypeFoundError
  def self.check!(type_name, env:, location:); end
end

class RBS::NonregularTypeAliasError
  def diagnostic(); end

  def initialize(diagnostic:, location:); end

  def location(); end
end

class RBS::Parser
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

RBS::Parser::LexerError = RBS::ParsingError

class RBS::Parser::LocatedValue
end

class RBS::Parser::LocatedValue
end

RBS::Parser::SemanticsError = RBS::ParsingError

RBS::Parser::SyntaxError = RBS::ParsingError

class RBS::Parser
  def self._parse_method_type(arg, arg1, arg2, arg3, arg4); end

  def self._parse_signature(arg, arg1); end

  def self._parse_type(arg, arg1, arg2, arg3, arg4); end

  def self.buffer(source); end

  def self.parse_method_type(source, line: T.unsafe(nil), column: T.unsafe(nil), range: T.unsafe(nil), variables: T.unsafe(nil)); end

  def self.parse_signature(source, line: T.unsafe(nil), column: T.unsafe(nil)); end

  def self.parse_type(source, line: T.unsafe(nil), column: T.unsafe(nil), range: T.unsafe(nil), variables: T.unsafe(nil)); end
end

class RBS::ParsingError
  def error_message(); end

  def error_value(); end

  def initialize(location, error_message, token_type); end

  def location(); end

  def token_str(); end

  def token_type(); end
end

class RBS::Prototype::RB
  def block_type(node); end

  def body_type(node); end

  def const_to_name(node, context:); end

  def const_to_name!(node); end

  def current_accessibility(decls, index=T.unsafe(nil)); end

  def decls(); end

  def find_def_index_by_name(decls, name); end

  def function_return_type_from_body(node); end

  def function_type_from_body(node, def_name); end

  def if_unless_type(node); end

  def is_accessibility?(decl); end

  def literal_to_symbol(node); end

  def literal_to_type(node); end

  def node_type(node, default: T.unsafe(nil)); end

  def param_type(node, default: T.unsafe(nil)); end

  def parse(string); end

  def private(); end

  def process(node, decls:, comments:, context:); end

  def process_children(node, decls:, comments:, context:); end

  def public(); end

  def range_element_type(types); end

  def remove_unnecessary_accessibility_methods!(decls); end

  def source_decls(); end

  def toplevel_members(); end

  def types_to_union_type(types); end
end

class RBS::Prototype::RB::Context
  def attribute_kind(); end

  def method_kind(); end

  def module_function(); end

  def module_function=(_); end

  def namespace(); end

  def namespace=(_); end

  def singleton(); end

  def singleton=(_); end
end

class RBS::Prototype::RB::Context
  def self.[](*arg); end

  def self.initial(namespace: T.unsafe(nil)); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Prototype::RBI
  def call_node?(node, name:, receiver: T.unsafe(nil), args: T.unsafe(nil)); end

  def const_to_name(node); end

  def current_module(); end

  def current_module!(); end

  def current_namespace(); end

  def decls(); end

  def each_arg(array, &block); end

  def each_child(node); end

  def join_comments(nodes, comments); end

  def last_sig(); end

  def method_type(args_node, type_node, variables:, overloads:); end

  def modules(); end

  def nested_name(name); end

  def node_to_hash(node); end

  def parse(string); end

  def parse_params(args_node, args, method_type, variables:, overloads:); end

  def pop_sig(); end

  def proc_type?(type_node); end

  def process(node, comments:, outer: T.unsafe(nil)); end

  def push_class(name, super_class, comment:); end

  def push_module(name, comment:); end

  def push_sig(node); end

  def type_of(type_node, variables:); end

  def type_of0(type_node, variables:); end
end

class RBS::Prototype::Runtime
  def block_from_ast_of(method); end

  def builder(); end

  def const_name(const); end

  def decls(); end

  def each_included_module(type_name, mod); end

  def ensure_outer_module_declarations(mod); end

  def env(); end

  def generate_class(mod); end

  def generate_constants(mod, decls); end

  def generate_methods(mod, module_name, members); end

  def generate_module(mod); end

  def generate_super_class(mod); end

  def initialize(patterns:, env:, merge:, owners_included: T.unsafe(nil)); end

  def merge(); end

  def merge_rbs(module_name, members, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end

  def method_type(method); end

  def only_name(mod); end

  def owners_included(); end

  def parse(file); end

  def patterns(); end

  def target?(const); end

  def target_method?(mod, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end

  def to_type_name(name, full_name: T.unsafe(nil)); end

  def type_args(type_name); end
end

class RBS::RecursiveAliasDefinitionError
  def defs(); end

  def initialize(type:, defs:); end

  def location(); end

  def type(); end
end

class RBS::RecursiveAncestorError
  def ancestors(); end

  def initialize(ancestors:, location:); end

  def location(); end
end

class RBS::RecursiveAncestorError
  def self.check!(self_ancestor, ancestors:, location:); end
end

class RBS::RecursiveTypeAliasError
  def alias_names(); end

  def initialize(alias_names:, location:); end

  def location(); end

  def name(); end
end

class RBS::Repository
  def add(dir); end

  def dirs(); end

  def gems(); end

  def initialize(no_stdlib: T.unsafe(nil)); end

  def lookup(gem, version); end

  def lookup_path(gem, version); end
  DEFAULT_STDLIB_ROOT = ::T.let(nil, ::T.untyped)
end

class RBS::Repository::GemRBS
  def empty?(); end

  def find_best_version(version); end

  def initialize(name:); end

  def latest_version(); end

  def load!(); end

  def name(); end

  def oldest_version(); end

  def paths(); end

  def version_names(); end

  def versions(); end
end

class RBS::Repository::VersionPath
  def gem(); end

  def gem=(_); end

  def path(); end

  def path=(_); end

  def version(); end

  def version=(_); end
end

class RBS::Repository::VersionPath
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Repository
  def self.default(); end

  def self.find_best_version(version, candidates); end
end

class RBS::Resolver::ConstantResolver
  def builder(); end

  def child_constants_cache(); end

  def children(module_name); end

  def constants(context); end

  def constants_from_ancestors(module_name, constants:); end

  def constants_from_context(context, constants:); end

  def constants_itself(context, constants:); end

  def context_constants_cache(); end

  def initialize(builder:); end

  def load_child_constants(name); end

  def load_context_constants(context); end

  def resolve(name, context:); end

  def resolve_child(module_name, name); end

  def table(); end
end

class RBS::Resolver::ConstantResolver::Table
  def children(name); end

  def children_table(); end

  def constant(name); end

  def constant_of_constant(name, entry); end

  def constant_of_module(name, entry); end

  def constants_table(); end

  def initialize(environment); end

  def toplevel(); end
end

class RBS::Resolver::TypeNameResolver
  def all_names(); end

  def cache(); end

  def has_name?(full_name); end

  def initialize(env); end

  def resolve(type_name, context:); end

  def resolve_in(type_name, context); end

  def try_cache(query); end
end

class RBS::Substitution
  def add(from:, to:); end

  def apply(ty); end

  def empty?(); end

  def instance_type(); end

  def instance_type=(instance_type); end

  def mapping(); end

  def without(*vars); end
end

class RBS::Substitution
  def self.build(variables, types, instance_type: T.unsafe(nil), &block); end
end

class RBS::SuperclassMismatchError
  def entry(); end

  def initialize(name:, entry:); end

  def name(); end
end

class RBS::TypeAliasDependency
  def build_dependencies(); end

  def circular_definition?(alias_name); end

  def dependencies(); end

  def direct_dependencies(); end

  def env(); end

  def initialize(env:); end

  def transitive_closure(); end
end

class RBS::TypeAliasRegularity
  def build_alias_type(name); end

  def builder(); end

  def compatible_args?(args1, args2); end

  def diagnostics(); end

  def each_alias_type(type, &block); end

  def each_mutual_alias_defs(&block); end

  def env(); end

  def initialize(env:); end

  def nonregular?(type_name); end

  def validate(); end

  def validate_alias_type(alias_type, names, types); end
end

class RBS::TypeAliasRegularity::Diagnostic
  def initialize(type_name:, nonregular_type:); end

  def nonregular_type(); end

  def type_name(); end
end

class RBS::TypeAliasRegularity
  def self.validate(env:); end
end

class RBS::TypeName
  def +(other); end

  def ==(other); end

  def absolute!(); end

  def absolute?(); end

  def alias?(); end

  def class?(); end

  def eql?(other); end

  def initialize(namespace:, name:); end

  def interface?(); end

  def kind(); end

  def name(); end

  def namespace(); end

  def relative!(); end

  def split(); end

  def to_json(state=T.unsafe(nil)); end

  def to_namespace(); end

  def with_prefix(namespace); end
end

class RBS::TypeNameResolver
  def add_names(names); end

  def all_names(); end

  def cache(); end

  def has_name?(full_name); end

  def resolve(type_name, context:); end

  def try_cache(query); end
end

class RBS::TypeNameResolver::Query
  def context(); end

  def context=(_); end

  def type_name(); end

  def type_name=(_); end
end

class RBS::TypeNameResolver::Query
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::TypeNameResolver
  def self.from_env(env); end
end

class RBS::Types::Alias
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

module RBS::Types::Application
  def ==(other); end

  def args(); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def hash(); end

  def name(); end

  def to_s(level=T.unsafe(nil)); end
end

class RBS::Types::Bases::Base
  def ==(other); end

  def eql?(other); end

  def initialize(location:); end

  def location(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end
end

class RBS::Types::Block
  def ==(other); end

  def initialize(type:, required:, self_type: T.unsafe(nil)); end

  def map_type(&block); end

  def required(); end

  def self_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::Types::ClassInstance
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::Types::ClassSingleton
  def ==(other); end

  def eql?(other); end

  def initialize(name:, location:); end

  def location(); end

  def map_type_name(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end
end

module RBS::Types::EmptyEachType
  def each_type(); end

  def map_type(&block); end
end

class RBS::Types::Function
  def ==(other); end

  def amap(array, &block); end

  def drop_head(); end

  def drop_tail(); end

  def each_param(&block); end

  def each_type(); end

  def empty?(); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_keyword?(); end

  def hmapv(hash, &block); end

  def initialize(required_positionals:, optional_positionals:, rest_positionals:, trailing_positionals:, required_keywords:, optional_keywords:, rest_keywords:, return_type:); end

  def map_type(&block); end

  def map_type_name(&block); end

  def optional_keywords(); end

  def optional_positionals(); end

  def param_to_s(); end

  def required_keywords(); end

  def required_positionals(); end

  def rest_keywords(); end

  def rest_positionals(); end

  def return_to_s(); end

  def return_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def trailing_positionals(); end

  def update(required_positionals: T.unsafe(nil), optional_positionals: T.unsafe(nil), rest_positionals: T.unsafe(nil), trailing_positionals: T.unsafe(nil), required_keywords: T.unsafe(nil), optional_keywords: T.unsafe(nil), rest_keywords: T.unsafe(nil), return_type: T.unsafe(nil)); end

  def with_return_type(type); end
end

class RBS::Types::Function::Param
  def ==(other); end

  def eql?(other); end

  def initialize(type:, name:, location: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::Types::Function
  def self.empty(return_type); end
end

class RBS::Types::Interface
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::Types::Intersection
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end
end

class RBS::Types::Literal
  def ==(other); end

  def eql?(other); end

  def initialize(literal:, location:); end

  def literal(); end

  def location(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end
end

module RBS::Types::NoFreeVariables
  def free_variables(set=T.unsafe(nil)); end
end

module RBS::Types::NoSubst
  def sub(s); end
end

module RBS::Types::NoTypeName
  def map_type_name(); end
end

class RBS::Types::Optional
  def ==(other); end

  def each_type(); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def initialize(type:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def type(); end
end

class RBS::Types::Proc
  def ==(other); end

  def block(); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def initialize(location:, type:, block:, self_type: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def self_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def type(); end
end

class RBS::Types::Record
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def fields(); end

  def free_variables(set=T.unsafe(nil)); end

  def initialize(fields:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end
end

module RBS::Types::SelfTypeBindingHelper
  def self.self_type_binding_to_s(t); end
end

class RBS::Types::Tuple
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end
end

class RBS::Types::Union
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end
end

class RBS::Types::Variable
  def ==(other); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def initialize(name:, location:); end

  def location(); end

  def name(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end
end

class RBS::Types::Variable
  def self.build(v); end

  def self.fresh(v=T.unsafe(nil)); end
end

class RBS::UnknownMethodAliasError
  def aliased_name(); end

  def initialize(type_name:, original_name:, aliased_name:, location:); end

  def location(); end

  def original_name(); end

  def type_name(); end
end

class RBS::Validator
  def absolute_type(type, context:); end

  def definition_builder(); end

  def env(); end

  def initialize(env:, resolver:); end

  def resolver(); end

  def type_alias_dependency(); end

  def type_alias_regularity(); end

  def validate_method_definition(method_def, type_name:); end

  def validate_type(type, context:); end

  def validate_type_alias(entry:); end

  def validate_type_params(params, type_name:, location:, method_name: T.unsafe(nil)); end
end

class RBS::VarianceCalculator
  def builder(); end

  def env(); end

  def function(type, result:, context:); end

  def in_inherit(name:, args:, variables:); end

  def in_method_type(method_type:, variables:); end

  def in_type_alias(name:); end

  def initialize(builder:); end

  def negate(variance); end

  def type(type, result:, context:); end
end

class RBS::VarianceCalculator::Result
  def compatible?(var, with_annotation:); end

  def contravariant(x); end

  def covariant(x); end

  def each(&block); end

  def include?(name); end

  def incompatible?(params); end

  def initialize(variables:); end

  def invariant(x); end

  def result(); end
end

class RBS::Vendorer
  def clean!(); end

  def copy!(); end

  def ensure_dir(); end

  def initialize(vendor_dir:, loader:); end

  def loader(); end

  def vendor_dir(); end
end

class RBS::Writer
  def attribute(kind, attr); end

  def indent(size=T.unsafe(nil)); end

  def indentation(); end

  def initialize(out:); end

  def method_name(name); end

  def name_and_args(name, args); end

  def name_and_params(name, params); end

  def out(); end

  def prefix(); end

  def preserve!(preserve: T.unsafe(nil)); end

  def preserve?(); end

  def preserve_empty_line(prev, decl); end

  def put_lines(lines, leading_spaces:); end

  def puts(string=T.unsafe(nil)); end

  def write(decls); end

  def write_annotation(annotations); end

  def write_comment(comment); end

  def write_decl(decl); end

  def write_def(member); end

  def write_loc_source(located); end

  def write_member(member); end
end

module RBS
  def self.logger(); end

  def self.logger_level(); end

  def self.logger_level=(level); end

  def self.logger_output(); end

  def self.logger_output=(val); end

  def self.print_warning(); end
end

class RDoc::Alias
  def initialize(text, old_name, new_name, comment, singleton=T.unsafe(nil)); end
end

class RDoc::AnyMethod
  def _call_seq(); end

  def has_call_seq?(); end

  def section_title(); end

  def section_title=(section_title); end

  def skip_description?(); end
end

class RDoc::Attr
  def initialize(text, name, rw, comment, singleton=T.unsafe(nil)); end
end

class RDoc::ClassModule
  def initialize(name, superclass=T.unsafe(nil)); end
end

class RDoc::CodeObject
  def initialize_visibility(); end
end

class RDoc::Comment
  def initialize(text=T.unsafe(nil), location=T.unsafe(nil), language=T.unsafe(nil)); end

  def line(); end

  def line=(line); end
end

class RDoc::Constant
  def initialize(name, value, comment); end
end

class RDoc::Context
  def add_module_by_normal_module(mod); end

  def initialize_methods_etc(); end

  def instance_methods(); end
end

class RDoc::Context::Section
  def initialize(parent, title, comment); end
end

class RDoc::CrossReference
  def initialize(context); end

  def resolve_method(name); end
  METHOD_ARGS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  METHOD_ARG_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class RDoc::ERBIO
  def initialize(str, trim_mode: T.unsafe(nil), eoutvar: T.unsafe(nil)); end
end

module RDoc::Encoding
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

module RDoc::Encoding
  def self.detect_encoding(string); end

  def self.remove_magic_comment(string); end
end

class RDoc::Generator::Darkfish
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil
  def initialize(store, options); end
end

class RDoc::Generator::JsonIndex
  def initialize(parent_generator, options); end
end

class RDoc::Generator::POT
  def initialize(store, options); end
end

class RDoc::Generator::POT::MessageExtractor
  def initialize(store); end
end

class RDoc::Generator::POT::POEntry
  def initialize(msgid, options=T.unsafe(nil)); end
end

class RDoc::Generator::RI
  def initialize(store, options); end
end

class RDoc::I18n::Locale
  def initialize(name); end
end

class RDoc::I18n::Text
  def initialize(raw); end
end

class RDoc::Markdown
  def _Table(); end

  def _TableAlign(); end

  def _TableAlign2(); end

  def _TableHead(); end

  def _TableItem(); end

  def _TableItem2(); end

  def _TableLine(); end

  def _TableRow(); end

  def current_character(target=T.unsafe(nil)); end

  def current_pos_info(target=T.unsafe(nil)); end

  def get_line(no); end

  def initialize(extensions=T.unsafe(nil), debug=T.unsafe(nil)); end

  def position_line_offsets(); end
end

class RDoc::Markdown::KpegPosInfo
  def char(); end

  def char=(_); end

  def col(); end

  def col=(_); end

  def line(); end

  def line=(_); end

  def lno(); end

  def lno=(_); end

  def pos(); end

  def pos=(_); end
end

class RDoc::Markdown::KpegPosInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RDoc::Markdown::Literals
  def current_character(target=T.unsafe(nil)); end

  def current_pos_info(target=T.unsafe(nil)); end

  def get_line(no); end

  def initialize(str, debug=T.unsafe(nil)); end

  def position_line_offsets(); end
end

class RDoc::Markdown::Literals::KpegPosInfo
  def char(); end

  def char=(_); end

  def col(); end

  def col=(_); end

  def line(); end

  def line=(_); end

  def lno(); end

  def lno=(_); end

  def pos(); end

  def pos=(_); end
end

class RDoc::Markdown::Literals::KpegPosInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RDoc::Markdown::Literals::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::Literals::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markdown::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markup
  def add_regexp_handling(pattern, name); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class RDoc::Markup::AttrChanger
  def self.keyword_init?(); end
end

class RDoc::Markup::AttrSpan
  def initialize(length, exclusive); end
end

class RDoc::Markup::AttributeManager
  def add_regexp_handling(pattern, name, exclusive=T.unsafe(nil)); end

  def convert_attrs_matching_word_pairs(str, attrs, exclusive); end

  def convert_attrs_word_pair_map(str, attrs, exclusive); end

  def convert_regexp_handlings(str, attrs, exclusive=T.unsafe(nil)); end

  def exclusive?(attr); end

  def exclusive_bitmap(); end

  def regexp_handlings(); end
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::Attributes
  def regexp_handling(); end
end

class RDoc::Markup::Document
  def initialize(*parts); end
end

class RDoc::Markup::Formatter
  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def convert_regexp_handling(target); end

  def initialize(options, markup=T.unsafe(nil)); end
end

class RDoc::Markup::Formatter::InlineTag
  def self.keyword_init?(); end
end

class RDoc::Markup::Heading
  def self.keyword_init?(); end
end

class RDoc::Markup::Include
  def initialize(file, include_path); end
end

class RDoc::Markup::IndentedParagraph
  def initialize(indent, *parts); end
end

class RDoc::Markup::List
  def initialize(type=T.unsafe(nil), *items); end
end

class RDoc::Markup::ListItem
  def initialize(label=T.unsafe(nil), *parts); end
end

class RDoc::Markup::Parser::MyStringScanner
  def [](i); end

  def eos?(); end

  def initialize(input); end

  def matched(); end

  def newline!(); end

  def pos(); end

  def scan(re); end

  def unscan(s); end
end

class RDoc::Markup::Parser::MyStringScanner
end

class RDoc::Markup::PreProcess
  def initialize(input_file_name, include_path); end
end

class RDoc::Markup::Raw
  def initialize(*parts); end
end

class RDoc::Markup::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class RDoc::Markup::RegexpHandling
end

class RDoc::Markup::Table
  def ==(other); end

  def accept(visitor); end

  def align(); end

  def align=(align); end

  def body(); end

  def body=(body); end

  def header(); end

  def header=(header); end

  def initialize(header, align, body); end
end

class RDoc::Markup::Table
end

class RDoc::Markup::ToHtml
  def accept_table(header, body, aligns); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end

  def init_link_notation_regexp_handlings(); end

  def init_regexp_handlings(); end
  URL_CHARACTERS_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class RDoc::Markup::ToHtmlCrossref
  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToHtmlSnippet
  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToJoinedParagraph
  def accept_table(*node); end

  def initialize(); end
end

class RDoc::Markup::ToLabel
  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToMarkdown
  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToRdoc
  def accept_table(header, body, aligns); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToTableOfContents
  def accept_table(*node); end

  def initialize(); end
end

class RDoc::Markup::ToTtOnly
  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::MethodAttr
  def initialize(text, name); end
end

class RDoc::Mixin
  def initialize(name, comment); end
end

class RDoc::Options
  def initialize(loaded_options=T.unsafe(nil)); end

  def override(map); end

  def skip_tests(); end

  def skip_tests=(skip_tests); end

  def to_yaml(*options); end
end

class RDoc::Options
  def self.load_options(); end
end

class RDoc::Parser
  def handle_tab_width(body); end

  def initialize(top_level, file_name, content, options, stats); end
end

class RDoc::Parser::C
  def add_alias(var_name, class_obj, old_name, new_name, comment); end

  def do_classes_and_modules(); end

  def new_comment(text=T.unsafe(nil), location=T.unsafe(nil), language=T.unsafe(nil)); end
  BOOL_ARG_PATTERN = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::ChangeLog
  def parse_date(date); end
end

module RDoc::Parser::ChangeLog::Git
  def create_entries(entries); end

  def parse_entries(); end

  def parse_info(info); end
  HEADING_LEVEL = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::ChangeLog::Git::LogEntry
  def accept(visitor); end

  def aref(); end

  def author(); end

  def author=(_); end

  def base(); end

  def base=(_); end

  def commit(); end

  def commit=(_); end

  def contents(); end

  def contents=(_); end

  def date(); end

  def date=(_); end

  def email(); end

  def email=(_); end

  def initialize(base, commit, author, email, date, contents); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def text(); end
end

class RDoc::Parser::ChangeLog::Git::LogEntry
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RDoc::Parser::ChangeLog::Git
end

class RDoc::Parser::RipperStateLex
  def get_squashed_tk(); end

  def initialize(code); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  RIPPER_HAS_LEX_STATE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::RipperStateLex::InnerStateLex
  def initialize(code); end

  def on_default(event, tok, data); end
end

class RDoc::Parser::RipperStateLex::InnerStateLex
end

class RDoc::Parser::RipperStateLex::Token
  def char_no(); end

  def char_no=(_); end

  def kind(); end

  def kind=(_); end

  def line_no(); end

  def line_no=(_); end

  def state(); end

  def state=(_); end

  def text(); end

  def text=(_); end
end

class RDoc::Parser::RipperStateLex::Token
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RDoc::Parser::RipperStateLex
  def self.end?(token); end

  def self.parse(code); end
end

class RDoc::Parser::Ruby
  def get_included_module_with_optional_parens(); end

  def parse_included_with_activesupport_concern(container, comment); end

  def retrieve_comment_body(tk); end

  def skip_parentheses(&block); end
end

module RDoc::Parser::RubyTools
  def skip_tkspace_without_nl(); end
end

class RDoc::RD::BlockParser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::Inline
  def initialize(rdoc, reference); end
end

class RDoc::RD::InlineParser
  def initialize(block_parser); end
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RDoc
  TEST_SUITE_DIRECTORY_NAMES = ::T.let(nil, ::T.untyped)
  UNCONDITIONALLY_SKIPPED_DIRECTORIES = ::T.let(nil, ::T.untyped)
end

class RDoc::RI::Driver
  def initialize(initial_options=T.unsafe(nil)); end
end

class RDoc::RI::Driver::NotFoundError
  def initialize(klass, suggestion_proc=T.unsafe(nil)); end
end

RDoc::RI::Store = RDoc::Store

class RDoc::Require
  def initialize(name, comment); end
end

class RDoc::Servlet
  def initialize(server, stores, cache, mount_path=T.unsafe(nil), extra_doc_dirs=T.unsafe(nil)); end
end

class RDoc::Stats
  def initialize(store, num_files, verbosity=T.unsafe(nil)); end
end

class RDoc::Stats::Quiet
  def initialize(num_files); end
end

class RDoc::Store
  def initialize(path=T.unsafe(nil), type=T.unsafe(nil)); end

  def unmatched_constant_alias(); end

  def update_parser_of_file(absolute_name, parser); end
end

class RDoc::Store::MissingFileError
  def initialize(store, file, name); end
end

class RDoc::Task
  def coverage_task_description(); end

  def inline_source(); end

  def inline_source=(value); end
end

module RDoc::Text
  def language(); end

  def language=(language); end
  SPACE_SEPARATED_LETTER_CLASS = ::T.let(nil, ::T.untyped)
end

class RDoc::TopLevel
  def initialize(absolute_name, relative_name=T.unsafe(nil)); end
end

module RDoc
  def self.home(); end
end

class REXML::AttlistDecl
  def initialize(source); end
end

class REXML::Attribute
  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Attributes
  def initialize(element); end
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Child
  def initialize(parent=T.unsafe(nil)); end
end

class REXML::Comment
  def initialize(first, second=T.unsafe(nil)); end
end

class REXML::Declaration
  def initialize(src); end
end

class REXML::DocType
  def initialize(first, parent=T.unsafe(nil)); end
end

class REXML::Document
  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Element
  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Elements
  def initialize(parent); end

  def parent(); end
end

class REXML::Entity
  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end
end

class REXML::ExternalEntity
  def initialize(src); end
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end
end

class REXML::Formatters::Pretty
  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::Instruction
  def initialize(target, content=T.unsafe(nil)); end
end

module REXML::Namespace
  NAME_WITHOUT_NAMESPACE = ::T.let(nil, ::T.untyped)
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end
end

class REXML::Output
  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::ParseException
  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end
end

class REXML::Parsers::BaseParser
  def initialize(source); end
  EXTERNAL_ID_PUBLIC = ::T.let(nil, ::T.untyped)
  EXTERNAL_ID_SYSTEM = ::T.let(nil, ::T.untyped)
  PUBLIC_ID = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::StreamParser
  def initialize(source, listener); end
end

class REXML::Parsers::TreeParser
  def initialize(source, build_context=T.unsafe(nil)); end
end

class REXML::Parsers::XPathParser
  def preciate_to_string(parsed, &block); end

  def predicate_to_path(parsed, &block); end
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::ReferenceWriter
  def initialize(id_type, public_id_literal, system_literal, context=T.unsafe(nil)); end

  def write(output); end
end

class REXML::Source
  def initialize(arg, encoding=T.unsafe(nil)); end
end

class REXML::Text
  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::XMLDecl
  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathParser
  def initialize(strict: T.unsafe(nil)); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::Bisect::BisectFailedError
  def self.for_failed_spec_run(spec_output); end
end

class RSpec::Core::Bisect::Channel
  def close(); end

  def receive(); end

  def send(message); end
  MARSHAL_DUMP_ENCODING = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def all_example_ids(); end

  def all_example_ids=(_); end

  def failed_example_ids(); end

  def failed_example_ids=(_); end
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Bisect::Notifier
  def initialize(formatter); end

  def publish(event, *args); end
end

class RSpec::Core::Configuration
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_exit_code=(error_exit_code); end

  def error_exit_code?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(value); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_cause_backtrace=(full_cause_backtrace); end

  def full_cause_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def pending_failure_output=(mode); end

  def pending_failure_output?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples(); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_exit_code(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def full_cause_backtrace(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def pending_failure_output(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_alias(name, alias_name); end

  def self.define_predicate(name); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::DSL
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ==(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def eql?(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def ruby2_keywords(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusDumper
  def dump(); end

  def initialize(examples); end
end

class RSpec::Core::ExampleStatusDumper
  def self.dump(examples); end
end

class RSpec::Core::ExampleStatusMerger
  def initialize(this_run, from_previous_runs); end

  def merge(); end
end

class RSpec::Core::ExampleStatusMerger
  def self.merge(this_run, from_previous_runs); end
end

class RSpec::Core::ExampleStatusParser
  def initialize(string); end

  def parse(); end
end

class RSpec::Core::ExampleStatusParser
  def self.parse(string); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

module RSpec::Core::FlatMap
  def self.flat_map(array, &block); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*arg); end
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlPrinter
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil
  def flush(); end

  def initialize(output); end

  def make_example_group_header_red(group_id); end

  def make_example_group_header_yellow(group_id); end

  def make_header_red(); end

  def make_header_yellow(); end

  def move_progress(percent_done); end

  def print_example_failed(pending_fixed, description, run_time, failure_id, exception, extra_content); end

  def print_example_group_end(); end

  def print_example_group_start(group_id, description, number_of_parents); end

  def print_example_passed(description, run_time); end

  def print_example_pending(description, pending_message); end

  def print_html_start(); end

  def print_summary(duration, example_count, failure_count, pending_count); end
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(group_notification); end
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  def self.highlight_syntax(lines); end
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assert_valid_keys(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compact_blank(*args, &block); end

  def compact_blank!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deconstruct_keys(*args, &block); end

  def deep_merge(*args, &block); end

  def deep_merge!(*args, &block); end

  def deep_merge?(*args, &block); end

  def deep_stringify_keys(*args, &block); end

  def deep_stringify_keys!(*args, &block); end

  def deep_symbolize_keys(*args, &block); end

  def deep_symbolize_keys!(*args, &block); end

  def deep_transform_keys(*args, &block); end

  def deep_transform_keys!(*args, &block); end

  def deep_transform_values(*args, &block); end

  def deep_transform_values!(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def except(*args, &block); end

  def except!(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extractable_options?(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def filter_map(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def in_order_of(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def maximum(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minimum(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def nested_under_indifferent_access(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def reverse_merge(*args, &block); end

  def reverse_merge!(*args, &block); end

  def reverse_update(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sole(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def stringify_keys(*args, &block); end

  def stringify_keys!(*args, &block); end

  def sum(*args, &block); end

  def symbolize_keys(*args, &block); end

  def symbolize_keys!(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def tally(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_options(*args, &block); end

  def to_options!(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def with_defaults(*args, &block); end

  def with_defaults!(*args, &block); end

  def with_indifferent_access(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::LegacyExampleGroupHash
  def initialize(metadata); end
end

module RSpec::Core::MemoizedHelpers
  def initialize(*arg); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

module RSpec::Core::MemoizedHelpers
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

module RSpec::Core::Metadata
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def self.configuration(); end

  def self.framework_name(); end
end

class RSpec::Core::MultipleExceptionError
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*arg); end

  def self.from_hash(data); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*arg); end

  def self.for(example); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Delayed
  def initialize(registry, name); end

  def order(list); end
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::RecentlyModified
  def order(list); end
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def has_strategy?(name); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def as_json(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def beep(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def check_winsize_changed(*args, &block); end

  def clear_screen(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def console_mode(*args, &block); end

  def console_mode=(*args, &block); end

  def cooked(*args, &block); end

  def cooked!(*args, &block); end

  def cursor(*args, &block); end

  def cursor=(*args, &block); end

  def cursor_down(*args, &block); end

  def cursor_left(*args, &block); end

  def cursor_right(*args, &block); end

  def cursor_up(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def echo=(*args, &block); end

  def echo?(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def erase_line(*args, &block); end

  def erase_screen(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def getch(*args, &block); end

  def getpass(*args, &block); end

  def gets(*args, &block); end

  def goto(*args, &block); end

  def goto_column(*args, &block); end

  def iflush(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def ioflush(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def method_missing(name, *args, &block); end

  def noecho(*args, &block); end

  def nonblock(*args, &block); end

  def nonblock=(*args, &block); end

  def nonblock?(*args, &block); end

  def nread(*args, &block); end

  def oflush(*args, &block); end

  def output(); end

  def output=(output); end

  def path(*args, &block); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def pressed?(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def raw(*args, &block); end

  def raw!(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def scroll_backward(*args, &block); end

  def scroll_forward(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def set_encoding_by_bom(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def timeout(*args, &block); end

  def timeout=(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def to_path(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_priority(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def winsize(*args, &block); end

  def winsize=(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def exit_early(exit_code); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::RubyProject
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def exit_code(examples_passed=T.unsafe(nil)); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::Time
  def self.now(in: T.unsafe(nil)); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_group_counts_by_spec_file(); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def rspec_is_quitting(); end

  def rspec_is_quitting=(rspec_is_quitting); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(); end
end

module RSpec::Core
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def initialize(*arg); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def strict_predicate_matchers(); end

  def strict_predicate_matchers=(flag); end

  def strict_predicate_matchers?(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

module RSpec::Expectations::ExpectationHelper
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationTarget
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
  AGGREGATED_FAILURE = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::FailureAggregator::AggregatedFailure
  MESSAGE = ::T.let(nil, ::T.untyped)
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, custom_message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, custom_message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  def a_block_changing(*args, **arg, &block); end

  def a_block_outputting(*args, **arg, &block); end

  def a_block_raising(*args, **arg, &block); end

  def a_block_throwing(*args, **arg, &block); end

  def a_block_yielding_control(*args, **arg, &block); end

  def a_block_yielding_successive_args(*args, **arg, &block); end

  def a_block_yielding_with_args(*args, **arg, &block); end

  def a_block_yielding_with_no_args(*args, **arg, &block); end

  def a_collection_containing_exactly(*args, **arg, &block); end

  def a_collection_ending_with(*args, **arg, &block); end

  def a_collection_including(*args, **arg, &block); end

  def a_collection_starting_with(*args, **arg, &block); end

  def a_falsey_value(*args, **arg, &block); end

  def a_falsy_value(*args, **arg, &block); end

  def a_hash_including(*args, **arg, &block); end

  def a_kind_of(*args, **arg, &block); end

  def a_nil_value(*args, **arg, &block); end

  def a_range_covering(*args, **arg, &block); end

  def a_string_ending_with(*args, **arg, &block); end

  def a_string_including(*args, **arg, &block); end

  def a_string_matching(*args, **arg, &block); end

  def a_string_starting_with(*args, **arg, &block); end

  def a_truthy_value(*args, **arg, &block); end

  def a_value(*args, **arg, &block); end

  def a_value_between(*args, **arg, &block); end

  def a_value_within(*args, **arg, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_array_matching(*args, **arg, &block); end

  def an_instance_of(*args, **arg, &block); end

  def an_object_eq_to(*args, **arg, &block); end

  def an_object_eql_to(*args, **arg, &block); end

  def an_object_equal_to(*args, **arg, &block); end

  def an_object_existing(*args, **arg, &block); end

  def an_object_having_attributes(*args, **arg, &block); end

  def an_object_matching(*args, **arg, &block); end

  def an_object_responding_to(*args, **arg, &block); end

  def an_object_satisfying(*args, **arg, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, **arg, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, **arg, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, **arg, &block); end

  def cover(*values); end

  def covering(*args, **arg, &block); end

  def end_with(*expected); end

  def ending_with(*args, **arg, &block); end

  def eq(expected); end

  def eq_to(*args, **arg, &block); end

  def eql(expected); end

  def eql_to(*args, **arg, &block); end

  def equal(expected); end

  def equal_to(*args, **arg, &block); end

  def exist(*args); end

  def existing(*args, **arg, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, **arg, &block); end

  def include(*expected); end

  def including(*args, **arg, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, **arg, &block); end

  def matching(*args, **arg, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, **arg, &block); end

  def respond_to(*names); end

  def responding_to(*args, **arg, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, **arg, &block); end

  def start_with(*expected); end

  def starting_with(*args, **arg, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, **arg, &block); end

  def within(*args, **arg, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, **arg, &block); end

  def yielding_successive_args(*args, **arg, &block); end

  def yielding_with_args(*args, **arg, &block); end

  def yielding_with_no_args(*args, **arg, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*arg); end
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::StringEncodingFormatting
  def self.format_encoding(value); end

  def self.string_encoding_differs?(); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  def does_not_match?(actual); end

  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BePredicate
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

module RSpec::Matchers::BuiltIn::CaptureStderr
  def self.capture(block); end
end

module RSpec::Matchers::BuiltIn::CaptureStdout
  def self.capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
  def capture(block); end
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::ChangeDetails
  def actual_after(); end

  def actual_delta(); end

  def changed?(); end

  def initialize(matcher_name, receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def perform_change(event_proc); end

  def value_representation(); end
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
  def does_not_match?(event_proc); end

  def initialize(change_details, expected_before); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
  def does_not_match?(_event_proc); end

  def initialize(change_details, expected_delta, relativity, &comparer); end

  def matches?(event_proc); end
end

class RSpec::Matchers::BuiltIn::ChangeToValue
  def does_not_match?(_event_proc); end

  def from(value); end

  def initialize(change_details, expected_after); end
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *arg); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RSpec::Matchers::BuiltIn::CountExpectation
  def at_least(number); end

  def at_most(number); end

  def count_expectation_type(); end

  def exactly(number); end

  def expected_count(); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::DynamicPredicate
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, **arg, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Has
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

module RSpec::Matchers::BuiltIn::NullCapture
  def self.capture(_block); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::RaiseError
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message, expected_message, &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end

  def with_message(expected_message); end
  UndefinedValue = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
  def captures(); end

  def initialize(match_data); end

  def match_data(); end

  def names(); end
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def ignoring_method_signature_failure!(); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo::ArityCheck
  def initialize(expected_arity, expected_keywords, arbitrary_keywords, unlimited_arguments); end

  def matches?(actual, name); end

  def method_signature_for(actual, name); end

  def verifier_for(actual, name); end
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, from, to); end

  def matches?(event_proc); end
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def assert_used!(); end

  def assert_valid_expect_block!(); end

  def has_block?(); end

  def initialize(block, &callback); end

  def num_yields(); end

  def num_yields=(num_yields); end

  def probe(); end

  def single_yield_args(); end

  def to_proc(); end

  def yielded_args(); end

  def yielded_args=(yielded_args); end

  def yielded_once?(matcher_name); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def self.probe(block, &callback); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(options=T.unsafe(nil), &match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

class RSpec::Matchers::DSL::Matcher
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

module RSpec::Matchers::EnglishPhrasing
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::MatcherDelegator
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MultiMatcherDiff
  def initialize(expected_list); end

  def message_with_diff(message, differ); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::MultiMatcherDiff
  def self.for_many_matchers(matchers); end

  def self.from(expected, actual); end
end

module RSpec::Matchers
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AndInvokeImplementation
  def call(*args, &block); end

  def initialize(procs_to_invoke); end
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, **arg, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AnyInstance::Chain
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Recorder
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::ArgumentListMatcher
  def args_match?(*actual_args, **arg); end

  def expected_args(); end

  def initialize(*expected_args, **arg); end

  def resolve_expected_args_based_on(actual_args); end
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end

  def an_instance_of(klass); end

  def any_args(); end

  def anything(); end

  def array_excluding(*args); end

  def array_including(*args); end

  def boolean(); end

  def duck_type(*args); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def hash_not_including(*args); end

  def instance_of(klass); end

  def kind_of(klass); end

  def no_args(); end
end

module RSpec::Mocks::ArgumentMatchers
  def self.anythingize_lonely_keys(*args); end
end

class RSpec::Mocks::CallbackInvocationStrategy
  def call(doubled_module); end
end

class RSpec::Mocks::ClassNewMethodReference
  CLASS_NEW = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ClassNewMethodReference
  def self.applies_to?(method_name); end

  def self.uses_class_new?(klass); end
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Constant
  def hidden=(hidden); end

  def hidden?(); end

  def initialize(name); end

  def mutated?(); end

  def name(); end

  def original_value(); end

  def original_value=(original_value); end

  def previously_defined=(previously_defined); end

  def previously_defined?(); end

  def stubbed=(stubbed); end

  def stubbed?(); end

  def valid_name=(valid_name); end

  def valid_name?(); end
end

class RSpec::Mocks::Constant
  def self.original(name); end

  def self.unmutated(name); end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  def full_constant_name(); end

  def idempotently_reset(); end

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def original_value(); end

  def to_constant(); end
end

class RSpec::Mocks::ConstantMutator::ConstantHider
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
  def initialize(*args); end

  def mutate(); end

  def reset(); end

  def should_transfer_nested_constants?(); end

  def transfer_nested_constants(); end

  def verify_constants_to_transfer!(); end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator
  def self.hide(constant_name); end

  def self.mutate(mutator); end

  def self.raise_on_invalid_const(); end

  def self.stub(constant_name, value, options=T.unsafe(nil)); end
end

class RSpec::Mocks::DirectObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(object); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

module RSpec::Mocks::ExampleMethods
  def allow(target); end

  def allow_any_instance_of(klass); end

  def allow_message_expectations_on_nil(); end

  def class_double(doubled_class, *args); end

  def class_spy(*args); end

  def double(*args); end

  def expect_any_instance_of(klass); end

  def have_received(method_name, &block); end

  def hide_const(constant_name); end

  def instance_double(doubled_class, *args); end

  def instance_spy(*args); end

  def object_double(object_or_name, *args); end

  def object_spy(*args); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end

  def spy(*args); end

  def stub_const(constant_name, value, options=T.unsafe(nil)); end

  def without_partial_double_verification(); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExampleMethods
  def self.declare_double(type, *args); end

  def self.declare_verifying_double(type, ref, *args); end

  def self.extended(object); end

  def self.included(klass); end
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::ExpectationTargetMethods
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::Implementation
  def call(*args, **arg, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::InstanceMethodStasher
  def handle_restoration_failures(); end

  def initialize(object, method); end

  def method_is_stashed?(); end

  def original_method(); end

  def restore(); end

  def stash(); end
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

class RSpec::Mocks::Matchers::ExpectationCustomization
  def block(); end

  def block=(block); end

  def initialize(method_name, args, block); end

  def playback_onto(expectation); end
end

class RSpec::Mocks::Matchers::HaveReceived
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matcher_name(); end

  def matches?(subject, &block); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::Receive
  def and_call_original(*args, **arg, &block); end

  def and_invoke(*args, **arg, &block); end

  def and_raise(*args, **arg, &block); end

  def and_return(*args, **arg, &block); end

  def and_throw(*args, **arg, &block); end

  def and_wrap_original(*args, **arg, &block); end

  def and_yield(*args, **arg, &block); end

  def at_least(*args, **arg, &block); end

  def at_most(*args, **arg, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, **arg, &block); end

  def initialize(message, block); end

  def inspect(*args, **arg, &block); end

  def matcher_name(); end

  def matches?(subject, &block); end

  def never(*args, **arg, &block); end

  def once(*args, **arg, &block); end

  def ordered(*args, **arg, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, **arg, &block); end

  def time(*args, **arg, &block); end

  def times(*args, **arg, &block); end

  def to_s(*args, **arg, &block); end

  def twice(*args, **arg, &block); end

  def with(*args, **arg, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  def and_call_original(*args, &block); end

  def and_invoke(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matcher_name(); end

  def matches?(subject, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matcher_name(); end

  def matches?(subject); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageExpectation
  def and_call_original(); end

  def and_invoke(first_proc, *procs); end

  def and_raise(*args); end

  def and_return(first_value, *values); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def time(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, **arg, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, **arg, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, **arg, &block); end

  def matches?(message, *args, **arg); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, **arg, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

class RSpec::Mocks::MethodDouble
  def add_default_stub(*args, &implementation); end

  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end

  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end

  def add_simple_stub(method_name, response); end

  def add_stub(error_generator, expectation_ordering, expected_from, opts=T.unsafe(nil), &implementation); end

  def build_expectation(error_generator, expectation_ordering); end

  def clear(); end

  def configure_method(); end

  def define_proxy_method(); end

  def expectations(); end

  def initialize(object, method_name, proxy); end

  def message_expectation_class(); end

  def method_missing_block(); end

  def method_name(); end

  def method_stasher(); end

  def object(); end

  def object_singleton_class(); end

  def original_implementation_callable(); end

  def original_method(); end

  def proxy_method_invoked(_obj, *args, **arg, &block); end

  def raise_method_not_stubbed_error(); end

  def remove_stub(); end

  def remove_stub_if_present(); end

  def reset(); end

  def restore_original_method(); end

  def restore_original_visibility(); end

  def save_original_implementation_callable!(); end

  def setup_simple_method_double(method_name, response, collection, error_generator=T.unsafe(nil), backtrace_line=T.unsafe(nil)); end

  def show_frozen_warning(); end

  def stubs(); end

  def verify(); end

  def visibility(); end
  FROZEN_ERROR_MSG = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::MethodReference
  def defined?(); end

  def implemented?(); end

  def initialize(object_reference, method_name); end

  def unimplemented?(); end

  def visibility(); end

  def with_signature(); end
end

class RSpec::Mocks::MethodReference
  def self.for(object_reference, method_name); end

  def self.instance_method_visibility_for(klass, method_name); end

  def self.method_defined_at_any_visibility?(klass, method_name); end

  def self.method_visibility_for(object, method_name); end
end

class RSpec::Mocks::NamedObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(const_name); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::NestedSpace
  def initialize(parent); end
end

class RSpec::Mocks::NoCallbackInvocationStrategy
  def call(_doubled_module); end
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  def self.for(object_module_or_name, allow_direct_object_refs=T.unsafe(nil)); end
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  def as_stubbed_const(options=T.unsafe(nil)); end
end

class RSpec::Mocks::OrderGroup
  def clear(); end

  def consume(); end

  def empty?(); end

  def handle_order_constraint(expectation); end

  def invoked(message); end

  def ready_for?(expectation); end

  def register(expectation); end

  def verify_invocation_order(expectation); end
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def method_double_from_ancestor_for(message); end

  def original_method_handle_for(message); end

  def original_unbound_method_handle_from_ancestor_for(message); end

  def superclass_proxy(); end
end

class RSpec::Mocks::PartialDoubleProxy
  def original_method_handle_for(message); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::Proxy
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_expectation(method_name, response, location); end

  def add_simple_stub(method_name, response); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def build_expectation(method_name); end

  def check_for_unexpected_arguments(expectation); end

  def ensure_can_be_proxied!(object); end

  def ensure_implemented(*_args); end

  def has_negative_expectation?(message); end

  def initialize(object, order_group, options=T.unsafe(nil)); end

  def message_received(message, *args, **arg, &block); end

  def messages_arg_list(); end

  def method_double_if_exists_for_message(message); end

  def object(); end

  def original_method_handle_for(_message); end

  def prepended_modules_of_singleton_class(); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_unexpected_message_error(method_name, args); end

  def received_message?(method_name, *args, &block); end

  def record_message_received(message, *args, **arg, &block); end

  def remove_stub(method_name); end

  def remove_stub_if_present(method_name); end

  def replay_received_message_on(expectation, &block); end

  def reset(); end

  def verify(); end

  def visibility_for(_method_name); end
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy::SpecificMessage
  def ==(expectation); end

  def args(); end

  def args=(_); end

  def message(); end

  def message=(_); end

  def object(); end

  def object=(_); end
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Mocks::Proxy
  def self.prepended_modules_of(klass); end
end

class RSpec::Mocks::ProxyForNil
  def disallow_expectations(); end

  def disallow_expectations=(disallow_expectations); end

  def initialize(order_group); end

  def warn_about_expectations(); end

  def warn_about_expectations=(warn_about_expectations); end
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end

  def any_instance_recorder_for(*_args); end

  def any_instance_recorders_from_ancestry_of(_object); end

  def new_scope(); end

  def proxy_for(*_args); end

  def register_constant_mutator(_mutator); end

  def registered?(_object); end

  def reset_all(); end

  def superclass_proxy_for(*_args); end

  def verify_all(); end
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::Space
  def any_instance_mutex(); end

  def any_instance_proxy_for(klass); end

  def any_instance_recorder_for(klass, only_return_existing=T.unsafe(nil)); end

  def any_instance_recorders(); end

  def any_instance_recorders_from_ancestry_of(object); end

  def constant_mutator_for(name); end

  def ensure_registered(object); end

  def new_scope(); end

  def proxies(); end

  def proxies_of(klass); end

  def proxy_for(object); end

  def proxy_mutex(); end

  def register_constant_mutator(mutator); end

  def registered?(object); end

  def reset_all(); end

  def superclass_proxy_for(klass); end

  def verify_all(); end
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
  def self.default_should_syntax_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_unless_should_configured(method_name, replacement=T.unsafe(nil)); end
end

class RSpec::Mocks::TargetBase
  def initialize(target); end
end

module RSpec::Mocks::TargetDelegationClassMethods
  def delegate_not_to(matcher_method, options=T.unsafe(nil)); end

  def delegate_to(matcher_method); end

  def disallow_negation(method_name); end
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  def target(); end
end

module RSpec::Mocks::TestDouble
  def ==(other); end

  def __build_mock_proxy_unless_expired(order_group); end

  def __disallow_further_usage!(); end

  def as_null_object(); end

  def freeze(); end

  def initialize(name=T.unsafe(nil), stubs=T.unsafe(nil)); end

  def inspect(); end

  def null_object?(); end

  def respond_to?(message, incl_private=T.unsafe(nil)); end

  def to_s(); end
end

module RSpec::Mocks::TestDoubleFormatter
  def self.format(dbl, unwrap=T.unsafe(nil)); end
end

module RSpec::Mocks::VerifyingDouble
  def __send__(name, *args, **arg, &block); end

  def initialize(doubled_module, *args); end

  def method_missing(message, *args, &block); end

  def respond_to?(message, include_private=T.unsafe(nil)); end

  def send(name, *args, **arg, &block); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?(); end

  def with_signature(); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def self.for(object, method_name, proxy); end
end

class RSpec::Mocks::VerifyingMessageExpectation
  def initialize(*args); end

  def method_reference(); end

  def method_reference=(method_reference); end
end

class RSpec::Mocks::VerifyingMethodDouble
  def add_expectation(*args, &block); end

  def add_stub(*args, &block); end

  def initialize(object, method_name, proxy, method_reference); end

  def proxy_method_invoked(obj, *args, **arg, &block); end

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
  def ensure_implemented(_method_name); end

  def initialize(object, expectation_ordering, optional_callback_invocation_strategy=T.unsafe(nil)); end

  def method_reference(); end
end

class RSpec::Mocks::VerifyingProxy
  def initialize(object, order_group, doubled_module, method_reference_class); end

  def method_reference(); end

  def validate_arguments!(method_name, args); end

  def visibility_for(method_name); end
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_stub(method_name, *args); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def ensure_implemented(method_name); end

  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  def self.allow_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.configuration(); end

  def self.error_generator(); end

  def self.expect_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.setup(); end

  def self.space(); end

  def self.teardown(); end

  def self.verify(); end

  def self.with_temporary_scope(); end
end

module RSpec::Rails::FeatureCheck
  def self.has_action_cable_testing?(); end

  def self.has_action_mailbox?(); end

  def self.has_action_mailer?(); end

  def self.has_action_mailer_legacy_delivery_job?(); end

  def self.has_action_mailer_parameterized?(); end

  def self.has_action_mailer_preview?(); end

  def self.has_action_mailer_unified_delivery?(); end

  def self.has_active_job?(); end

  def self.has_active_record?(); end

  def self.has_active_record_migration?(); end

  def self.type_metatag(type); end
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

class RSpec::Support::ComparableVersion
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

class RSpec::Support::HunkGenerator
  def hunks(); end

  def initialize(actual, expected); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  def self.new(); end
end

module RSpec::Support::OS
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*arg); end

  def self.can_inspect?(_object); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

module RSpec::Support::Ruby
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end

  def self.truffleruby?(); end
end

module RSpec::Support::RubyFeatures
  def self.caller_locations_supported?(); end

  def self.distincts_kw_args_from_positional_hash?(); end

  def self.fork_supported?(); end

  def self.kw_arg_separation?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_syntax_suggest?(); end

  def self.supports_taint?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::WithKeywordsWhenNeeded
  def self.class_exec(klass, *args, **arg, &block); end
end

module RSpec::Support
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.current_scope(); end

  def self.current_scope=(scope); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.reset(); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_ERROR = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RESPONSE_FINISHED = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *arg); end
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, **arg, &block); end
end

class Rack::Builder
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app=T.unsafe(nil), &block); end

  def to_app(); end

  def use(middleware, *args, **arg, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(path); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, cascade_for=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::ContentLength
  def call(env); end

  def initialize(app); end
end

class Rack::ContentType
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::Cors
  DEFAULT_VARY_HEADERS = ::T.let(nil, ::T.untyped)
  ENV_KEY = ::T.let(nil, ::T.untyped)
  HTTP_ACCESS_CONTROL_REQUEST_HEADERS = ::T.let(nil, ::T.untyped)
  HTTP_ACCESS_CONTROL_REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  HTTP_ORIGIN = ::T.let(nil, ::T.untyped)
  HTTP_X_ORIGIN = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  RACK_CORS = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Cors::Resource
  CORS_SIMPLE_HEADERS = ::T.let(nil, ::T.untyped)
end

class Rack::Cors::Result
  HEADER_KEY = ::T.let(nil, ::T.untyped)
  MISS_DENY_HEADER = ::T.let(nil, ::T.untyped)
  MISS_DENY_METHOD = ::T.let(nil, ::T.untyped)
  MISS_NO_METHOD = ::T.let(nil, ::T.untyped)
  MISS_NO_ORIGIN = ::T.let(nil, ::T.untyped)
  MISS_NO_PATH = ::T.let(nil, ::T.untyped)
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
  BUFFER_LENGTH = ::T.let(nil, ::T.untyped)
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def root(); end

  def stat(path); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::Events
  def call(env); end

  def initialize(app, handlers); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end

  def on_error(req, res, e); end

  def on_finish(req, res); end

  def on_send(req, res); end

  def on_start(req, res); end
end

class Rack::Events::BufferedResponse
  def body(); end

  def initialize(status, headers, body); end

  def to_a(); end
end

class Rack::Events::EventedBodyProxy
  def each(&blk); end

  def initialize(body, request, response, handlers, &block); end

  def request(); end

  def response(); end
end

Rack::File = Rack::Files

class Rack::Files
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Files::BaseIterator
  def bytesize(); end

  def close(); end

  def each(&blk); end

  def initialize(path, ranges, options); end

  def options(); end

  def path(); end

  def ranges(); end
end

class Rack::Files::Iterator
  def to_path(); end
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

Rack::Handler = Rackup::Handler

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Lint
  def call(env=T.unsafe(nil)); end

  def initialize(app); end
end

class Rack::Lint::Wrapper
  def call(stream); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_environment(env); end

  def check_error(error); end

  def check_header_value(key, value); end

  def check_headers(headers); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app, env); end

  def respond_to?(name, *arg); end

  def response(); end

  def to_ary(); end

  def to_path(); end

  def verify_content_length(size); end

  def verify_to_path(); end
  BODY_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::Wrapper::ErrorWrapper
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::Wrapper::InputWrapper
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end
end

class Rack::Lint::Wrapper::StreamWrapper
  def <<(*args, **arg, &block); end

  def close(*args, **arg, &block); end

  def close_read(*args, **arg, &block); end

  def close_write(*args, **arg, &block); end

  def closed?(*args, **arg, &block); end

  def flush(*args, **arg, &block); end

  def initialize(stream); end

  def read(*args, **arg, &block); end

  def write(*args, **arg, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

Rack::MockSession = Rack::Test::Session

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def parse(io); end

  def result(); end

  def state(); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end
end

class Rack::Multipart::Parser::Collector
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(request, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug!(); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error!(); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal!(); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info!(); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def log(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def progname(); end

  def progname=(progname); end

  def reopen(logdev=T.unsafe(nil)); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn!(); end

  def warn?(); end
end

class Rack::QueryParser
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

class Rack::Request
  def query(); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_FORWARDED = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::Response
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Rack::RewindableInput
  def close(); end

  def each(&block); end

  def gets(); end

  def initialize(io); end

  def read(*args); end

  def rewind(); end

  def size(); end
end

class Rack::RewindableInput::Middleware
  def call(env); end

  def initialize(app); end
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

Rack::Server = Rackup::Server

module Rack::Session
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def same_site(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*arg); end

  def generate_sid(*arg); end
end

class Rack::Session::Abstract::SessionHash
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def dig(key, *keys); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

class Rack::Session::Cookie
  def coder(); end

  def encryptors(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Marshal
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Encryptor
  def decrypt(base64_data); end

  def encrypt(message); end

  def initialize(secret, opts=T.unsafe(nil)); end
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end

  def template(); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  END_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  START_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

Rack::Utils::ParamsTooDeepError = Rack::QueryParser::ParamsTooDeepError

module Rackup
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rackup::Handler
  RACKUP_HANDLER = ::T.let(nil, ::T.untyped)
  RACK_HANDLER = ::T.let(nil, ::T.untyped)
end

class Rackup::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rackup::Handler::WEBrick
  def initialize(server, app); end
end

class Rackup::Handler::WEBrick::Input
  def close(); end

  def initialize(request); end
end

class Rackup::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rackup::Handler
  def self.[](name); end

  def self.default(); end

  def self.get(name); end

  def self.pick(server_names); end

  def self.register(name, klass); end

  def self.require_handler(prefix, const_name); end
end

class Rackup::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&block); end
end

class Rackup::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rackup::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

class Rackup::Stream
  def <<(buffer); end

  def close(error=T.unsafe(nil)); end

  def close_read(); end

  def close_write(); end

  def closed?(); end

  def empty?(); end

  def flush(); end

  def initialize(input=T.unsafe(nil), output=T.unsafe(nil)); end

  def input(); end

  def output(); end

  def write(buffer); end

  def write_nonblock(buffer); end
end

module Rackup::Stream::Reader
  def each(&blk); end

  def gets(); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def read_nonblock(length, buffer=T.unsafe(nil)); end

  def read_partial(length=T.unsafe(nil)); end
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

class Rails::ApplicationController
end

module Rails::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::DeviseI18n::ViewHelpers
  include ::AnniversariesHelper
  include ::ApplicationHelper
  include ::BirthdaysHelper
  include ::CheckoutHelper
  include ::MembersHelper
  include ::ParticipantsHelper
  include ::RoomsHelper
  include ::SubmitStoriesHelper
  include ::TodoItemsHelper
  include ::DeviseHelper
end

module Rails::ApplicationController::HelperMethods
end

class Rails::ApplicationController
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rails::Conductor::ActionMailbox::InboundEmails::SourcesController
  def create(); end

  def new(); end
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
  def create(); end

  def index(); end

  def new(); end

  def show(); end
end

class Rails::Conductor::ActionMailbox::IncineratesController
  def create(); end
end

class Rails::Conductor::ActionMailbox::ReroutesController
  def create(); end
end

module Rails::Dom::Testing
  def default_html_version(); end

  def default_html_version=(val); end
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil), strict: T.unsafe(nil), html_version: T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil), strict: T.unsafe(nil), html_version: T.unsafe(nil)); end

  def compare_doms(expected, actual, strict); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_child?(child, other_child, strict); end

  def equal_children?(child, other_child, strict); end

  def extract_children(node, strict); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  def assert_dom(*args, &block); end

  def assert_dom_email(html_version: T.unsafe(nil), &block); end

  def assert_dom_encoded(element=T.unsafe(nil), html_version: T.unsafe(nil), &block); end

  def assert_select(*args, &block); end

  def assert_select_email(html_version: T.unsafe(nil), &block); end

  def assert_select_encoded(element=T.unsafe(nil), html_version: T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Dom::Testing
  def self.default_html_version(); end

  def self.default_html_version=(val); end

  def self.html5_support?(); end

  def self.html_document(html_version: T.unsafe(nil)); end

  def self.html_document_fragment(html_version: T.unsafe(nil)); end
end

module Rails::HTML::Concern::Scrubber::SafeList
  DEFAULT_ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  DEFAULT_ALLOWED_TAGS = ::T.let(nil, ::T.untyped)
end

Rails::HTML::FullSanitizer = Rails::HTML4::FullSanitizer

Rails::HTML::LinkSanitizer = Rails::HTML4::LinkSanitizer

Rails::HTML::SafeListSanitizer = Rails::HTML4::SafeListSanitizer

class Rails::HTML::Sanitizer
  VERSION = ::T.let(nil, ::T.untyped)
end

Rails::HTML::WhiteListSanitizer = Rails::HTML4::SafeListSanitizer

class Rails::HealthController
  def show(); end
end

module Rails::HealthController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::DeviseI18n::ViewHelpers
  include ::AnniversariesHelper
  include ::ApplicationHelper
  include ::BirthdaysHelper
  include ::CheckoutHelper
  include ::MembersHelper
  include ::ParticipantsHelper
  include ::RoomsHelper
  include ::SubmitStoriesHelper
  include ::TodoItemsHelper
  include ::DeviseHelper
end

module Rails::HealthController::HelperMethods
end

class Rails::HealthController
end

Rails::Html = Rails::HTML

module Rails::Info
  def properties(); end

  def properties=(val); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(val); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

class Rails::MailersController
  def download(); end

  def index(); end

  def preview(); end
end

module Rails::MailersController::HelperMethods
  include ::Rails::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::DeviseI18n::ViewHelpers
  include ::AnniversariesHelper
  include ::ApplicationHelper
  include ::BirthdaysHelper
  include ::CheckoutHelper
  include ::MembersHelper
  include ::ParticipantsHelper
  include ::RoomsHelper
  include ::SubmitStoriesHelper
  include ::TodoItemsHelper
  include ::DeviseHelper
  def locale_query(*args, **arg, &block); end

  def part_query(*args, **arg, &block); end
end

module Rails::MailersController::HelperMethods
end

class Rails::MailersController
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::SourceAnnotationExtractor
  def display(results, options=T.unsafe(nil)); end

  def find(dirs); end

  def find_in(dir); end

  def initialize(tag); end

  def tag(); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def to_s(options=T.unsafe(nil)); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def self.directories(); end

  def self.extensions(); end

  def self.register_directories(*dirs); end

  def self.register_extensions(*exts, &block); end

  def self.register_tags(*additional_tags); end

  def self.tags(); end
end

class Rails::SourceAnnotationExtractor::ParserExtractor
  def annotations(file); end
end

class Rails::SourceAnnotationExtractor::ParserExtractor::Parser
  def comments(); end

  def initialize(source, pattern:); end

  def on_comment(value); end

  def pattern(); end
end

class Rails::SourceAnnotationExtractor::PatternExtractor
  def annotations(file); end
end

class Rails::SourceAnnotationExtractor
  def self.enumerate(tag=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Railslove::Acts::Birthday
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

module Rainbow
  def self.new(); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  def compact_blank(*args, &block); end

  def compact_blank!(*args, &block); end

  def deconstruct(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fifth(*args, &block); end

  def filter_map(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def in_order_of(*args, &block); end

  def including(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inquiry(*args, &block); end

  def intersect?(*args, &block); end

  def intersection(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def minimum(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def sole(*args, &block); end

  def split(*args, &block); end

  def tally(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_csv(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_fs(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_sentence(*args, &block); end

  def to_xml(*args, &block); end

  def without(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  def ln_sr(*args, **options, &block); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

Rake::RDocTask = RDoc::Task

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::TaskLib
  include ::FileUtils::StreamUtils_
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake
  extend ::FileUtils::StreamUtils_
end

RakeFileUtils = Rake::FileUtilsExt

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

module Random::Formatter
  def uuid_v4(); end

  def uuid_v7(extra_timestamp_bits: T.unsafe(nil)); end
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::EachTimeWithZone
  def %(arg); end

  def entries(); end

  def overlap?(arg); end

  def reverse_each(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end
end

module Recaptcha
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Recaptcha::Configuration
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

module Recaptcha::Helpers
  DEFAULT_ERRORS = ::T.let(nil, ::T.untyped)
end

class Redis
  BASE_PATH = ::T.let(nil, ::T.untyped)
  SERVER_URL_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Redis::Client
  ERROR_MAPPING = ::T.let(nil, ::T.untyped)
end

module Redis::Commands
  Boolify = ::T.let(nil, ::T.untyped)
  BoolifySet = ::T.let(nil, ::T.untyped)
  Floatify = ::T.let(nil, ::T.untyped)
  FloatifyPairs = ::T.let(nil, ::T.untyped)
  Hashify = ::T.let(nil, ::T.untyped)
  HashifyClusterNodeInfo = ::T.let(nil, ::T.untyped)
  HashifyClusterNodes = ::T.let(nil, ::T.untyped)
  HashifyClusterSlaves = ::T.let(nil, ::T.untyped)
  HashifyClusterSlots = ::T.let(nil, ::T.untyped)
  HashifyInfo = ::T.let(nil, ::T.untyped)
  HashifyStreamAutoclaim = ::T.let(nil, ::T.untyped)
  HashifyStreamAutoclaimJustId = ::T.let(nil, ::T.untyped)
  HashifyStreamEntries = ::T.let(nil, ::T.untyped)
  HashifyStreamPendingDetails = ::T.let(nil, ::T.untyped)
  HashifyStreamPendings = ::T.let(nil, ::T.untyped)
  HashifyStreams = ::T.let(nil, ::T.untyped)
  Noop = ::T.let(nil, ::T.untyped)
  Pairify = ::T.let(nil, ::T.untyped)
end

class Redis::Distributed
  def [](key); end

  def []=(key, value); end

  def _bpop(cmd, args); end

  def _eval(cmd, args); end

  def add_node(options); end

  def append(key, value); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil), scale: T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil), scale: T.unsafe(nil)); end

  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  def blmpop(timeout, *keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, **options); end

  def bzmpop(timeout, *keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  def bzpopmax(*args); end

  def bzpopmin(*args); end

  def close(); end

  def copy(source, destination, **options); end

  def dbsize(); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*args); end

  def discard(); end

  def dump(key); end

  def echo(value); end

  def ensure_same_node(command, keys); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(*args); end

  def exists?(*args); end

  def expire(key, seconds, **kwargs); end

  def expireat(key, unix_time, **kwargs); end

  def expiretime(key); end

  def flushall(); end

  def flushdb(); end

  def get(key); end

  def getbit(key, offset); end

  def getdel(key); end

  def getex(key, **options); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields); end

  def hmset(key, *attrs); end

  def hrandfield(key, count=T.unsafe(nil), **options); end

  def hset(key, *attrs); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(node_configs, options=T.unsafe(nil)); end

  def key_tag(key); end

  def keys(glob=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lmove(source, destination, where_source, where_destination); end

  def lmpop(*keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  def lpop(key, count=T.unsafe(nil)); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(_hash); end

  def mapped_msetnx(_hash); end

  def mget(*keys); end

  def migrate(_key, _options); end

  def monitor(); end

  def move(key, db); end

  def mset(*arg); end

  def msetnx(*arg); end

  def multi(&block); end

  def node_for(key); end

  def node_index_for(key); end

  def nodes(); end

  def on_each_node(command, *args); end

  def persist(key); end

  def pexpire(key, milliseconds, **kwarg); end

  def pexpireat(key, ms_unix_time, **kwarg); end

  def pexpiretime(key); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def punsubscribe(*channels); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, **options); end

  def ring(); end

  def rpop(key, count=T.unsafe(nil)); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, *members); end

  def sadd?(key, *members); end

  def save(); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def set(key, value, **options); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def smembers(key); end

  def smismember(key, *members); end

  def smove(source, destination, member); end

  def sort(key, **options); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, *members); end

  def srem?(key, *members); end

  def sscan(key, cursor, **options); end

  def sscan_each(key, **options, &block); end

  def strlen(key); end

  def subscribe(channel, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*args); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*keys, &block); end

  def zadd(key, *args, **arg); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zdiff(*keys, **options); end

  def zdiffstore(destination, *keys, **options); end

  def zincrby(key, increment, member); end

  def zinter(*keys, **options); end

  def zinterstore(destination, *keys, **options); end

  def zmpop(*keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  def zmscore(key, *members); end

  def zrandmember(key, count=T.unsafe(nil), **options); end

  def zrange(key, start, stop, **options); end

  def zrangebyscore(key, min, max, **options); end

  def zrangestore(dest_key, src_key, start, stop, **options); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, **options); end

  def zrevrangebyscore(key, max, min, **options); end

  def zrevrank(key, member); end

  def zscore(key, member); end

  def zunion(*keys, **options); end

  def zunionstore(destination, *keys, **options); end
end

class Redis::Distributed::CannotDistribute
  def initialize(command); end
end

class Redis::Distributed::CannotDistribute
end

class Redis::Distributed
end

class Redis::Future
  FutureNotReady = ::T.let(nil, ::T.untyped)
end

class Redis::HashRing
  def add_node(node); end

  def get_node(key); end

  def initialize(nodes=T.unsafe(nil), replicas=T.unsafe(nil)); end

  def iter_nodes(key); end

  def nodes(); end

  def remove_node(node); end

  def replicas(); end

  def ring(); end

  def sorted_keys(); end
  POINTS_PER_SERVER = ::T.let(nil, ::T.untyped)
end

class Redis::HashRing
end

class RedisClient
  VERSION = ::T.let(nil, ::T.untyped)
end

class RedisClient::CommandError
  ERRORS = ::T.let(nil, ::T.untyped)
end

class RedisClient::Config
  DEFAULT_DB = ::T.let(nil, ::T.untyped)
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
  DEFAULT_USERNAME = ::T.let(nil, ::T.untyped)
end

class RedisClient::Pooled
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

module RedisClient::RESP3
  DUMP_TYPES = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EOL_SIZE = ::T.let(nil, ::T.untyped)
  INTEGER_RANGE = ::T.let(nil, ::T.untyped)
  PARSER_TYPES = ::T.let(nil, ::T.untyped)
end

class RedisClient::RubyConnection
  SUPPORTS_RESOLV_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class RedisClient::RubyConnection::BufferedIO
  ENCODING = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EOL_SIZE = ::T.let(nil, ::T.untyped)
end

class RedisClient::SentinelConfig
  DEFAULT_RECONNECT_ATTEMPTS = ::T.let(nil, ::T.untyped)
  SENTINEL_DELAY = ::T.let(nil, ::T.untyped)
end

class Refinement
  def target(); end
end

class Regexp
  def timeout(); end
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
  def match_length(); end
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

Regexp::Expression::Backref = Regexp::Expression::Backreference

class Regexp::Expression::Backreference::Base
  def match_length(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Backreference::Name
  def name(); end

  def reference(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::Number
  def number(); end

  def reference(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRelative
  def effective_number(); end

  def effective_number=(effective_number); end
end

class Regexp::Expression::Base
  def =~(string, offset=T.unsafe(nil)); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def case_insensitive?(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def custom_to_s_handling(); end

  def custom_to_s_handling=(custom_to_s_handling); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset=T.unsafe(nil)); end

  def match?(string); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def options(); end

  def options=(options); end

  def parent(); end

  def parent=(parent); end

  def possessive?(); end

  def pre_quantifier_decorations(); end

  def pre_quantifier_decorations=(pre_quantifier_decorations); end

  def quantifier(); end

  def quantify(*args); end

  def quantity(); end

  def reluctant?(); end

  def repetitions(); end

  def set_level(); end

  def set_level=(set_level); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def te(); end

  def te=(te); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def u?(); end

  def unicode_classes?(); end

  def unquantified_clone(); end

  def x?(); end
end

class Regexp::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negative(); end

  def negative=(negative); end
end

class Regexp::Expression::CharacterSet::Range
  def complete?(); end
end

class Regexp::Expression::CharacterType::Base
  def match_length(); end
end

class Regexp::Expression::Conditional::Condition
  def match_length(); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def branch(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

Regexp::Expression::Escape = Regexp::Expression::EscapeSequence

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def codepoint(); end

  def match_length(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoints(); end
end

class Regexp::Expression::FreeSpace
  def match_length(); end

  def quantify(*_args); end
end

class Regexp::Expression::Group::Capture
  def identifier(); end

  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Passive
  def implicit=(implicit); end

  def implicit?(); end

  def initialize(*arg); end
end

class Regexp::Expression::Keep::Mark
  def match_length(); end
end

class Regexp::Expression::Literal
  def match_length(); end
end

Regexp::Expression::MatchLength = Regexp::MatchLength

Regexp::Expression::Nonposixclass = Regexp::Expression::PosixClass

Regexp::Expression::Nonproperty = Regexp::Expression::UnicodeProperty

class Regexp::Expression::PosixClass
  def match_length(); end

  def name(); end
end

Regexp::Expression::Posixclass = Regexp::Expression::PosixClass

Regexp::Expression::Property = Regexp::Expression::UnicodeProperty

class Regexp::Expression::Quantifier
  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def custom_to_s_handling(); end

  def custom_to_s_handling=(custom_to_s_handling); end

  def greedy?(); end

  def initialize(*args); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def max(); end

  def min(); end

  def mode(); end

  def nesting_level(); end

  def options(); end

  def options=(options); end

  def parent(); end

  def parent=(parent); end

  def possessive?(); end

  def pre_quantifier_decorations(); end

  def pre_quantifier_decorations=(pre_quantifier_decorations); end

  def quantifier(); end

  def reluctant?(); end

  def set_level(); end

  def set_level=(set_level); end

  def te(); end

  def te=(te); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end
end

class Regexp::Expression::Sequence
  def quantify(token, *args); end
end

class Regexp::Expression::Sequence
  def self.add_to(exp, params=T.unsafe(nil), active_opts=T.unsafe(nil)); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::CharacterSet
end

Regexp::Expression::Set::IntersectedSequence = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet
end

module Regexp::Expression::Shared
  def ==(other); end

  def ===(other); end

  def base_length(); end

  def capturing?(); end

  def coded_offset(); end

  def comment?(); end

  def decorative?(); end

  def ends_at(include_quantifier=T.unsafe(nil)); end

  def eql?(other); end

  def full_length(); end

  def human_name(); end

  def inspect(); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def negated?(); end

  def negative?(); end

  def nesting_level=(lvl); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def optional?(); end

  def parts(); end

  def pre_quantifier_decoration(expression_format=T.unsafe(nil)); end

  def pretty_print(q); end

  def pretty_print_instance_variables(); end

  def quantified?(); end

  def quantifier=(qtf); end

  def quantifier_affix(expression_format=T.unsafe(nil)); end

  def referential?(); end

  def starts_at(); end

  def terminal?(); end

  def to_s(format=T.unsafe(nil)); end

  def to_str(format=T.unsafe(nil)); end

  def token_class(); end

  def type?(test_type); end
end

module Regexp::Expression::Shared::ClassMethods
  def capturing?(); end

  def comment?(); end

  def construct(params=T.unsafe(nil)); end

  def construct_defaults(); end

  def decorative?(); end

  def referential?(); end

  def terminal?(); end

  def token_class(); end
end

module Regexp::Expression::Shared
  def self.included(mod); end
end

class Regexp::Expression::Subexpression
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil), &block); end

  def each_expression_with_index(&block); end

  def each_expression_without_index(&block); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def extract_quantifier_target(quantifier_description); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil), &block); end

  def index(*args, &block); end

  def inner_match_length(); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def match_length(); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::UnicodeProperty::Base
  def match_length(); end

  def name(); end

  def shortcut(); end
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Lexer
  def emit(token); end

  def lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  CONDITION_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
end

class Regexp::MatchLength
  def each(opts=T.unsafe(nil), &blk); end

  def endless_each(); end

  def fixed?(); end

  def include?(length); end

  def initialize(exp, opts=T.unsafe(nil)); end

  def max(); end

  def min(); end

  def to_re(); end
end

class Regexp::MatchLength
  def self.of(obj); end
end

class Regexp::Parser
  def parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Regexp::Parser::UP = Regexp::Expression::UnicodeProperty

Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def emit(type, token, text); end

  def literal_run(); end

  def literal_run=(literal_run); end

  def scan(input_object, options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::UnknownPosixClassError
  def initialize(text, _); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name, _); end
end

class Regexp::Scanner::ValidationError
  def self.for(type, problem, reason=T.unsafe(nil)); end

  def self.types(); end
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.parse_prop_map(name); end

  def self.posix_classes(); end

  def self.scan(input_object, options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
  def self.implements?(_type, _token); end
end

class Regexp::Syntax::Base
  def method_missing(name, *args); end
end

class Regexp::Syntax::Base
  def self.added_features(); end

  def self.check!(type, token); end

  def self.check?(type, token); end

  def self.excludes(type, tokens); end

  def self.features(); end

  def self.features=(features); end

  def self.implementations(type); end

  def self.implements(type, tokens); end

  def self.implements!(type, token); end

  def self.implements?(type, token); end

  def self.inherited(subclass); end

  def self.normalize(type, token); end

  def self.normalize_backref(type, token); end

  def self.normalize_group(type, token); end

  def self.removed_features(); end
end

Regexp::Syntax::CURRENT = Regexp::Syntax::V3_2_0

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Alternation
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Backref = Regexp::Syntax::Token::Backreference

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  NumberRef = ::T.let(nil, ::T.untyped)
  Plain = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V1_9_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::EscapeSequence = Regexp::Syntax::Token::Escape

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Alternation = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Property = Regexp::Syntax::Token::UnicodeProperty

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Set = Regexp::Syntax::Token::CharacterSet

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  Age_V3_1_0 = ::T.let(nil, ::T.untyped)
  Age_V3_2_0 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji_V2_6_0 = ::T.let(nil, ::T.untyped)
  Enumerated = ::T.let(nil, ::T.untyped)
  Enumerated_V2_4_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Script_V3_1_0 = ::T.let(nil, ::T.untyped)
  Script_V3_2_0 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_1_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_2_0 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
  V3_1_0 = ::T.let(nil, ::T.untyped)
  V3_2_0 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

module Regexp::Syntax
  def self.comparable(name); end

  def self.const_missing(const_name); end

  def self.fallback_version_class(version); end

  def self.for(name); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(arg); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Regexp
  def self.linear_time?(*arg); end
end

module Reline
  DEFAULT_DIALOG_CONTEXT = ::T.let(nil, ::T.untyped)
  DEFAULT_DIALOG_PROC_AUTOCOMPLETE = ::T.let(nil, ::T.untyped)
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  ANSI_CURSOR_KEY_BINDINGS = ::T.let(nil, ::T.untyped)
  CAPNAME_KEY_BINDINGS = ::T.let(nil, ::T.untyped)
  END_BRACKETED_PASTE = ::T.let(nil, ::T.untyped)
  RESET_COLOR = ::T.let(nil, ::T.untyped)
  START_BRACKETED_PASTE = ::T.let(nil, ::T.untyped)
end

class Reline::Config
  KEYSEQ_PATTERN = ::T.let(nil, ::T.untyped)
  VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  VARIABLE_NAME_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Reline::Core
  ATTR_READER_NAMES = ::T.let(nil, ::T.untyped)
end

class Reline::GeneralIO
  RESET_COLOR = ::T.let(nil, ::T.untyped)
end

Reline::IOGate = Reline::ANSI

class Reline::KeyActor::Base
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Emacs
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViCommand
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViInsert
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyStroke
  CSI_INTERMEDIATE_BYTES_RANGE = ::T.let(nil, ::T.untyped)
  CSI_PARAMETER_BYTES_RANGE = ::T.let(nil, ::T.untyped)
  ESC_BYTE = ::T.let(nil, ::T.untyped)
end

module Reline::KillRing::State
  CONTINUED = ::T.let(nil, ::T.untyped)
  FRESH = ::T.let(nil, ::T.untyped)
  PROCESSED = ::T.let(nil, ::T.untyped)
  YANK = ::T.let(nil, ::T.untyped)
end

class Reline::LineEditor
  DIALOG_DEFAULT_HEIGHT = ::T.let(nil, ::T.untyped)
  MINIMUM_SCROLLBAR_HEIGHT = ::T.let(nil, ::T.untyped)
  VI_MOTIONS = ::T.let(nil, ::T.untyped)
end

module Reline::LineEditor::CompletionState
  COMPLETION = ::T.let(nil, ::T.untyped)
  MENU = ::T.let(nil, ::T.untyped)
  MENU_WITH_PERFECT_MATCH = ::T.let(nil, ::T.untyped)
  NORMAL = ::T.let(nil, ::T.untyped)
  PERFECT_MATCH = ::T.let(nil, ::T.untyped)
end

module Reline::Terminfo
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Reline::Unicode
  CSI_REGEXP = ::T.let(nil, ::T.untyped)
  EscapedChars = ::T.let(nil, ::T.untyped)
  EscapedPairs = ::T.let(nil, ::T.untyped)
  HalfwidthDakutenHandakuten = ::T.let(nil, ::T.untyped)
  MBCharWidthRE = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  OSC_REGEXP = ::T.let(nil, ::T.untyped)
  WIDTH_SCANNER = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
  TYPE_A = ::T.let(nil, ::T.untyped)
  TYPE_F = ::T.let(nil, ::T.untyped)
  TYPE_H = ::T.let(nil, ::T.untyped)
  TYPE_N = ::T.let(nil, ::T.untyped)
  TYPE_NA = ::T.let(nil, ::T.untyped)
  TYPE_W = ::T.let(nil, ::T.untyped)
end

class Resolv
  VERSION = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end

  def use_ipv6?(); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_list(); end

  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HTTPS
end

class Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SVCB
end

class Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::IPv6
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

module ReverseMarkdown
  VERSION = ::T.let(nil, ::T.untyped)
end

class ReverseMarkdown::Cleaner
  def clean_punctuation_characters(string); end

  def clean_tag_borders(string); end

  def force_encoding(string); end

  def remove_inner_whitespaces(string); end

  def remove_leading_newlines(string); end

  def remove_newlines(string); end

  def tidy(string); end
end

class ReverseMarkdown::Config
  def force_encoding(); end

  def force_encoding=(force_encoding); end

  def github_flavored(); end

  def github_flavored=(github_flavored); end

  def tag_border(); end

  def tag_border=(tag_border); end

  def unknown_tags(); end

  def unknown_tags=(unknown_tags); end

  def with(options=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::A
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Base
  def escape_keychars(string); end

  def extract_title(node); end

  def treat(node, state); end

  def treat_children(node, state); end
end

class ReverseMarkdown::Converters::Blockquote
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Br
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Bypass
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Code
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Del
  def convert(node, state=T.unsafe(nil)); end

  def disabled?(); end

  def enabled?(); end
end

class ReverseMarkdown::Converters::Details
  def convert(node, state=T.unsafe(nil)); end

  def disabled?(); end

  def enabled?(); end
end

class ReverseMarkdown::Converters::Div
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Drop
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Em
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::FigCaption
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Figure
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::H
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Hr
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Ignore
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Img
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Li
  def convert(node, state=T.unsafe(nil)); end

  def indentation_from(state); end

  def prefix_for(node); end
end

class ReverseMarkdown::Converters::Ol
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::P
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::PassThrough
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Pre
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Strong
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Table
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Td
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Text
  def convert(node, options=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Tr
  def convert(node, state=T.unsafe(nil)); end

  def table_header_row?(node); end

  def underline_for(node); end
end

module ReverseMarkdown::Converters
  def self.default_converter(tag_name); end

  def self.lookup(tag_name); end

  def self.register(tag_name, converter); end

  def self.unregister(tag_name); end
end

module ReverseMarkdown
  def self.cleaner(); end

  def self.config(); end

  def self.convert(input, options=T.unsafe(nil)); end
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(**kw); end

  def parse(raise_errors: T.unsafe(nil)); end

  def scan(**kw); end

  def tokenize(**kw); end
end

class Ripper::Lexer::Elem
  def [](index); end

  def event(); end

  def event=(event); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pos(); end

  def pos=(pos); end

  def state(); end

  def state=(state); end

  def to_a(); end

  def tok(); end

  def tok=(tok); end
end

class Ripper::Lexer::Elem
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def [](index); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def |(i); end
end

class Ripper::Lexer::State
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg, **arg1); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

class Role
  include ::Role::GeneratedAttributeMethods
  include ::Role::GeneratedAssociationMethods
  def autosave_associated_records_for_roles_users(*args); end

  def autosave_associated_records_for_users(*args); end

  def validate_associated_records_for_roles_users(*args); end

  def validate_associated_records_for_users(*args); end
end

module Role::GeneratedAssociationMethods
  def user_ids(); end

  def user_ids=(ids); end

  def users(); end

  def users=(value); end
end

module Role::GeneratedAssociationMethods
end

module Role::GeneratedAttributeMethods
end

module Role::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Room
  include ::Room::GeneratedAttributeMethods
  include ::Room::GeneratedAssociationMethods
  def autosave_associated_records_for_messages(*args); end

  def validate_associated_records_for_messages(*args); end
end

module Room::GeneratedAssociationMethods
  def message_ids(); end

  def message_ids=(ids); end

  def messages(); end

  def messages=(value); end
end

module Room::GeneratedAssociationMethods
end

module Room::GeneratedAttributeMethods
end

module Room::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Rouge
  LIB_DIR = ::T.let(nil, ::T.untyped)
end

class Rouge::CSSTheme
  def initialize(opts=T.unsafe(nil)); end

  def render(&b); end

  def render_base(selector, &b); end

  def style_for(tok); end
end

class Rouge::Formatter
  def escape?(tok); end

  def filter_escapes(tokens); end

  def format(tokens, &b); end

  def initialize(opts=T.unsafe(nil)); end

  def render(tokens); end

  def stream(tokens, &b); end

  def token_lines(tokens, &b); end
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Rouge::Formatter
  def self.disable_escape!(); end

  def self.enable_escape!(); end

  def self.escape_enabled?(); end

  def self.find(tag); end

  def self.format(tokens, *args, **kwargs, &b); end

  def self.tag(tag=T.unsafe(nil)); end

  def self.with_escape(); end
end

class Rouge::Formatters::HTML
  def safe_span(tok, safe_val); end

  def span(tok, val); end
  ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
  TABLE_FOR_ESCAPE_HTML = ::T.let(nil, ::T.untyped)
end

class Rouge::Formatters::HTMLInline
  def initialize(theme); end
end

class Rouge::Formatters::HTMLLineHighlighter
  def initialize(delegate, opts=T.unsafe(nil)); end

  def stream(tokens); end
end

class Rouge::Formatters::HTMLLineTable
  def initialize(formatter, opts=T.unsafe(nil)); end
end

class Rouge::Formatters::HTMLLinewise
  def initialize(formatter, opts=T.unsafe(nil)); end
end

class Rouge::Formatters::HTMLPygments
  def initialize(inner, css_class=T.unsafe(nil)); end
end

class Rouge::Formatters::HTMLTable
  def initialize(inner, opts=T.unsafe(nil)); end

  def style(scope); end
end

class Rouge::Formatters::Null
  def initialize(*arg); end
end

class Rouge::Formatters::Terminal256
  def escape_sequence(token); end

  def get_style(token); end

  def initialize(theme=T.unsafe(nil)); end

  def make_escape_sequence(style); end

  def text_style(); end

  def theme(); end
end

class Rouge::Formatters::Terminal256::EscapeSequence
  def bg(); end

  def fg(); end

  def initialize(style); end

  def reset_string(); end

  def stream_value(val, &b); end

  def style(); end

  def style_string(); end
  MAX_DISTANCE = ::T.let(nil, ::T.untyped)
end

class Rouge::Formatters::Terminal256::EscapeSequence
  def self.closest_color(r, g, b); end

  def self.color_index(color); end

  def self.get_rgb(color); end

  def self.xterm_colors(); end
end

class Rouge::Formatters::Terminal256::Unescape
  def initialize(*arg); end

  def reset_string(*arg); end

  def stream_value(val); end

  def style_string(*arg); end
end

class Rouge::Formatters::TerminalTruecolor::TruecolorEscapeSequence
  def get_rgb(color); end
end

class Rouge::Formatters::Tex
  def escape_tex(str); end

  def hphantom_tag(tok, val); end

  def render_line(line, &b); end

  def tag(tok, val); end
  ESCAPE = ::T.let(nil, ::T.untyped)
  ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class Rouge::Guesser
  def collect_best(lexers, opts=T.unsafe(nil), &scorer); end

  def filter(lexers); end
end

class Rouge::Guesser::Ambiguous
  def alternatives(); end

  def initialize(alternatives); end
end

class Rouge::Guesser
  def self.guess(guessers, lexers); end
end

class Rouge::Guessers::Disambiguation
  def contains?(text); end

  def initialize(filename, source); end

  def matches?(re); end
end

class Rouge::Guessers::Disambiguation::Disambiguator
  def decide!(guesser); end

  def initialize(patterns, &decider); end

  def match?(filename); end
end

class Rouge::Guessers::Disambiguation
  def self.disambiguate(*patterns, &decider); end

  def self.disambiguators(); end
end

class Rouge::Guessers::Filename
  def fname(); end

  def initialize(filename); end
end

class Rouge::Guessers::GlobMapping
  def filename(); end

  def glob_map(); end

  def initialize(glob_map, filename); end
end

class Rouge::Guessers::GlobMapping
  def self.by_pairs(mapping, filename); end
end

class Rouge::Guessers::Mimetype
  def initialize(mimetype); end

  def mimetype(); end
end

class Rouge::Guessers::Modeline
  def initialize(source, opts=T.unsafe(nil)); end
  EMACS_MODELINE = ::T.let(nil, ::T.untyped)
  MODELINES = ::T.let(nil, ::T.untyped)
  VIM_MODELINE_1 = ::T.let(nil, ::T.untyped)
  VIM_MODELINE_2 = ::T.let(nil, ::T.untyped)
end

class Rouge::Guessers::Source
  def initialize(source); end

  def source(); end
end

module Rouge::Guessers::Util
  def get_source(source); end

  def test_glob(pattern, path); end
end

module Rouge::Guessers::Util::SourceNormalizer
  UTF8_BOM = ::T.let(nil, ::T.untyped)
  UTF8_BOM_RE = ::T.let(nil, ::T.untyped)
end

module Rouge::Guessers::Util::SourceNormalizer
  def self.normalize(source); end
end

module Rouge::HasModes
  def get_mode(mode); end

  def mode(arg=T.unsafe(nil)); end

  def mode!(arg); end

  def set_mode!(mode); end
end

module Rouge::Indentation
  def indentation(indent_str); end

  def reset!(); end

  def starts_block(block_state); end
end

class Rouge::InheritableHash
  def [](k); end

  def each(&b); end

  def include?(k); end

  def initialize(parent=T.unsafe(nil)); end

  def own_keys(); end

  def parent(); end
end

class Rouge::InheritableList
  def <<(o); end

  def each(&b); end

  def initialize(parent=T.unsafe(nil)); end

  def own_entries(); end

  def parent(); end

  def push(o); end
end

class Rouge::Lexer
  def as_bool(val); end

  def as_lexer(val); end

  def as_list(val); end

  def as_string(val); end

  def as_token(val); end

  def bool_option(name, &default); end

  def continue_lex(string, &b); end

  def hash_option(name, defaults, &val_cast); end

  def initialize(opts=T.unsafe(nil)); end

  def lex(string, opts=T.unsafe(nil), &b); end

  def lexer_option(name, &default); end

  def list_option(name, &default); end

  def options(); end

  def reset!(); end

  def stream_tokens(stream, &b); end

  def string_option(name, &default); end

  def tag(); end

  def token_option(name, &default); end

  def with(opts=T.unsafe(nil)); end
end

class Rouge::Lexer
  def self.aliases(*args); end

  def self.all(); end

  def self.assert_utf8!(str); end

  def self.continue_lex(*a, &b); end

  def self.debug_enabled?(); end

  def self.demo(arg=T.unsafe(nil)); end

  def self.demo_file(arg=T.unsafe(nil)); end

  def self.desc(arg=T.unsafe(nil)); end

  def self.detect?(text); end

  def self.detectable?(); end

  def self.disable_debug!(); end

  def self.enable_debug!(); end

  def self.filenames(*fnames); end

  def self.find(name); end

  def self.find_fancy(str, code=T.unsafe(nil), default_options=T.unsafe(nil)); end

  def self.guess(info=T.unsafe(nil), &fallback); end

  def self.guess_by_filename(fname); end

  def self.guess_by_mimetype(mt); end

  def self.guess_by_source(source); end

  def self.guesses(info=T.unsafe(nil)); end

  def self.lex(stream, opts=T.unsafe(nil), &b); end

  def self.lookup_fancy(str, code=T.unsafe(nil), default_options=T.unsafe(nil)); end

  def self.mimetypes(*mts); end

  def self.option(name, desc); end

  def self.option_docs(); end

  def self.register(name, lexer); end

  def self.tag(t=T.unsafe(nil)); end

  def self.title(t=T.unsafe(nil)); end
end

module Rouge::Lexers
  BASE_DIR = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::ABAP
  def self.builtins(); end

  def self.keywords(); end

  def self.new_keywords(); end

  def self.types(); end
end

class Rouge::Lexers::Actionscript
  def self.builtins(); end

  def self.constants(); end

  def self.declarations(); end

  def self.keywords(); end

  def self.reserved(); end
end

class Rouge::Lexers::Ada
  EXP = ::T.let(nil, ::T.untyped)
  ID = ::T.let(nil, ::T.untyped)
  NUM = ::T.let(nil, ::T.untyped)
  XNUM = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Ada
  def self.idents(); end
end

class Rouge::Lexers::Apache
  def name_for_token(token, tktype); end
end

class Rouge::Lexers::Apache
  def self.directives(); end

  def self.sections(); end

  def self.values(); end
end

class Rouge::Lexers::Apex
  def self.constants(); end

  def self.declarations(); end

  def self.keywords(); end

  def self.soql(); end

  def self.types(); end
end

class Rouge::Lexers::AppleScript
  def self.builtins(); end

  def self.classes(); end

  def self.commands(); end

  def self.controls(); end

  def self.declarations(); end

  def self.handler_params(); end

  def self.literals(); end

  def self.operators(); end

  def self.references(); end

  def self.reserved(); end

  def self.studio_classes(); end

  def self.studio_commands(); end

  def self.studio_events(); end

  def self.studio_properties(); end
end

class Rouge::Lexers::ArmAsm
  def self.builtin(); end

  def self.file_directive(); end

  def self.general_directive(); end

  def self.operator(); end

  def self.preproc_keyword(); end

  def self.shift_or_condition(); end
end

class Rouge::Lexers::Augeas
  def self.reserved(); end
end

class Rouge::Lexers::Awk
  def self.builtins(); end

  def self.constants(); end

  def self.declarations(); end

  def self.keywords(); end

  def self.reserved(); end
end

class Rouge::Lexers::BBCBASIC
  def self.constant(); end

  def self.function(); end

  def self.operator(); end

  def self.punctuation(); end

  def self.statement(); end
end

class Rouge::Lexers::BPF
  MISC_KEYWORDS = ::T.let(nil, ::T.untyped)
  TYPE_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Batchfile
  def self.attributes(); end

  def self.builtin_commands(); end

  def self.devices(); end

  def self.keywords(); end

  def self.operator_words(); end

  def self.other_commands(); end
end

class Rouge::Lexers::Brightscript
  def self.builtins(); end

  def self.keyword_reserved(); end

  def self.keyword_reserved_unsupported(); end

  def self.keyword_type(); end

  def self.name_builtin(); end

  def self.operator_word(); end
end

class Rouge::Lexers::Bsl
  BUILTINS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::C
  def self.builtins(); end

  def self.keywords(); end

  def self.keywords_type(); end

  def self.reserved(); end
end

class Rouge::Lexers::CMHG
  def self.preproc_keyword(); end
end

class Rouge::Lexers::CMake
  BRACKET_OPEN = ::T.let(nil, ::T.untyped)
  BUILTIN_COMMANDS = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  STATES_MAP = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::CSS
  def self.attributes(); end

  def self.builtins(); end

  def self.constants(); end

  def self.vendor_prefixes(); end
end

class Rouge::Lexers::Cfscript
  def self.declarations(); end

  def self.keywords(); end

  def self.types(); end
end

class Rouge::Lexers::Clean
  def self.keywords(); end
end

class Rouge::Lexers::Clojure
  def name_token(name); end
end

class Rouge::Lexers::Clojure
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::Coffeescript
  def self.builtins(); end

  def self.constants(); end

  def self.keywords(); end

  def self.reserved(); end
end

class Rouge::Lexers::CommonLisp
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_FUNCTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_TYPES = ::T.let(nil, ::T.untyped)
  DECLARATIONS = ::T.let(nil, ::T.untyped)
  LAMBDA_LIST_KEYWORDS = ::T.let(nil, ::T.untyped)
  MACROS = ::T.let(nil, ::T.untyped)
  SPECIAL_FORMS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::ConsoleLexer
  def allow_comments?(); end

  def comment_regex(); end

  def end_chars(); end

  def error_regex(); end

  def initialize(*arg); end

  def lang_lexer(); end

  def line_regex(); end

  def output_lexer(); end

  def process_line(input, &output); end

  def prompt_prefix_regex(); end

  def prompt_regex(); end

  def stream_tokens(input, &output); end
end

class Rouge::Lexers::Coq
  def self.classify(x); end

  def self.coq(); end

  def self.gallina(); end

  def self.ltac(); end

  def self.tacticals(); end

  def self.terminators(); end
end

class Rouge::Lexers::Cypher
  def self.functions(); end

  def self.keywords(); end

  def self.predicates(); end
end

class Rouge::Lexers::Cython
  def self.c_keywords(); end
end

class Rouge::Lexers::Datastudio
  def self.sql_keywords(); end
end

class Rouge::Lexers::Digdag
  KEYWORD_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Docker
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::ECL
  def self.class_first(); end

  def self.class_second(); end

  def self.functions(); end

  def self.keywords(); end

  def self.template(); end

  def self.type(); end

  def self.typed(); end
end

class Rouge::Lexers::Eiffel
  BooleanConstants = ::T.let(nil, ::T.untyped)
  LanguageKeywords = ::T.let(nil, ::T.untyped)
  LanguageVariables = ::T.let(nil, ::T.untyped)
  SimpleString = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Escape
  def end(); end

  def initialize(*arg); end

  def lang(); end

  def start(); end

  def stream_tokens(str, &b); end

  def to_end_regex(); end

  def to_start_regex(); end
end

class Rouge::Lexers::FSharp
  def self.keyopts(); end

  def self.keywords(); end

  def self.primitives(); end

  def self.word_operators(); end
end

class Rouge::Lexers::Factor
  def self.builtins(); end
end

class Rouge::Lexers::Fortran
  def self.intrinsics(); end

  def self.keywords(); end

  def self.types(); end
end

class Rouge::Lexers::FreeFEM
  def self.attributes(); end
end

class Rouge::Lexers::GDScript
  def self.builtins(); end

  def self.builtins_type(); end

  def self.keywords(); end

  def self.keywords_reserved(); end
end

class Rouge::Lexers::Gherkin
  def self.keywords(); end

  def self.step_regex(); end
end

class Rouge::Lexers::Go
  BIG_U_VALUE = ::T.let(nil, ::T.untyped)
  BYTE_VALUE = ::T.let(nil, ::T.untyped)
  CHAR_LIT = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DECIMALS = ::T.let(nil, ::T.untyped)
  DECIMAL_DIGIT = ::T.let(nil, ::T.untyped)
  DECIMAL_LIT = ::T.let(nil, ::T.untyped)
  ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
  ESCAPE_SEQUENCE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FLOAT_LIT = ::T.let(nil, ::T.untyped)
  GENERAL_COMMENT = ::T.let(nil, ::T.untyped)
  HEX_BYTE_VALUE = ::T.let(nil, ::T.untyped)
  HEX_DIGIT = ::T.let(nil, ::T.untyped)
  HEX_LIT = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  IMAGINARY_LIT = ::T.let(nil, ::T.untyped)
  INTERPRETED_STRING_LIT = ::T.let(nil, ::T.untyped)
  INT_LIT = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  LINE_COMMENT = ::T.let(nil, ::T.untyped)
  LITTLE_U_VALUE = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  OCTAL_BYTE_VALUE = ::T.let(nil, ::T.untyped)
  OCTAL_DIGIT = ::T.let(nil, ::T.untyped)
  OCTAL_LIT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PREDECLARED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREDECLARED_FUNCTIONS = ::T.let(nil, ::T.untyped)
  PREDECLARED_TYPES = ::T.let(nil, ::T.untyped)
  RAW_STRING_LIT = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
  STRING_LIT = ::T.let(nil, ::T.untyped)
  UNICODE_CHAR = ::T.let(nil, ::T.untyped)
  UNICODE_DIGIT = ::T.let(nil, ::T.untyped)
  UNICODE_LETTER = ::T.let(nil, ::T.untyped)
  UNICODE_VALUE = ::T.let(nil, ::T.untyped)
  WHITE_SPACE = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Groovy
  def self.constants(); end

  def self.declarations(); end

  def self.keywords(); end

  def self.types(); end
end

class Rouge::Lexers::HTTP
  def content_lexer(); end

  def guess_content_lexer(); end
end

class Rouge::Lexers::HTTP
  def self.http_methods(); end
end

class Rouge::Lexers::Haml
  def filters(); end

  def html(); end

  def ruby(); end

  def ruby!(state); end
end

class Rouge::Lexers::Haxe
  def self.builtins(); end

  def self.constants(); end

  def self.declarations(); end

  def self.imports(); end

  def self.keywords(); end

  def self.reserved(); end
end

class Rouge::Lexers::Hcl
  def self.builtins(); end

  def self.constants(); end

  def self.declarations(); end

  def self.keywords(); end

  def self.reserved(); end
end

class Rouge::Lexers::HyLang
  def name_token(name); end
end

class Rouge::Lexers::HyLang
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::IDLang
  def self.conditionals(); end

  def self.decorators(); end

  def self.exec_unit(); end

  def self.keywords(); end

  def self.operators(); end

  def self.routines(); end

  def self.standalone_statements(); end
end

class Rouge::Lexers::IO
  def self.builtins(); end

  def self.constants(); end
end

class Rouge::Lexers::ISBL
  def self.builtins(); end

  def self.constants(); end

  def self.globals(); end

  def self.interfaces(); end

  def self.keywords(); end
end

class Rouge::Lexers::Idris
  def self.ascii(); end

  def self.prelude_functions(); end

  def self.reserved_keywords(); end
end

class Rouge::Lexers::IgorPro
  def self.igorConstants(); end

  def self.igorDeclarations(); end

  def self.igorFunction(); end

  def self.igorOperation(); end

  def self.keywords(); end

  def self.object_name(); end

  def self.preprocessor(); end
end

class Rouge::Lexers::Isabelle
  def self.keyword_abandon_proof(); end

  def self.keyword_diag(); end

  def self.keyword_minor(); end

  def self.keyword_proof_asm(); end

  def self.keyword_proof_asm_goal(); end

  def self.keyword_proof_block(); end

  def self.keyword_proof_chain(); end

  def self.keyword_proof_decl(); end

  def self.keyword_proof_goal(); end

  def self.keyword_proof_script(); end

  def self.keyword_qed(); end

  def self.keyword_section(); end

  def self.keyword_subsection(); end

  def self.keyword_theory_decl(); end

  def self.keyword_theory_goal(); end

  def self.keyword_theory_script(); end

  def self.keyword_thy(); end
end

class Rouge::Lexers::J
  def self.control_words(); end

  def self.control_words_id(); end

  def self.inflection_list(); end

  def self.primitive(char, inflection); end

  def self.primitive_table(); end

  def self.token_map(); end
end

class Rouge::Lexers::JSP
  def initialize(*arg); end
end

class Rouge::Lexers::Janet
  def name_token(name); end
end

class Rouge::Lexers::Janet
  def self.bundled(); end

  def self.specials(); end
end

class Rouge::Lexers::Javascript
  def self.builtins(); end

  def self.constants(); end

  def self.declarations(); end

  def self.id_regex(); end

  def self.keywords(); end

  def self.reserved(); end
end

class Rouge::Lexers::Jinja
  def self.keywords(); end

  def self.pseudo_keywords(); end

  def self.tests(); end

  def self.word_operators(); end
end

class Rouge::Lexers::Jsonnet
  def self.builtins(); end

  def self.constants(); end

  def self.declarations(); end

  def self.keywords(); end
end

class Rouge::Lexers::Julia
  BUILTINS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  NAME_RE = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::LLVM
  def self.instructions(); end

  def self.keywords(); end

  def self.types(); end
end

class Rouge::Lexers::Lasso
  def initialize(*arg); end

  def start_inline?(); end
end

class Rouge::Lexers::Lasso
  def self.keywords(); end
end

class Rouge::Lexers::Lean
  def self.keywords(); end

  def self.operators(); end

  def self.types(); end
end

class Rouge::Lexers::LiterateCoffeescript
  def coffee(); end

  def markdown(); end
end

class Rouge::Lexers::LiterateHaskell
  def haskell(); end
end

class Rouge::Lexers::Livescript
  def self.builtins(); end

  def self.constants(); end

  def self.declarations(); end

  def self.keywords(); end

  def self.loop_control_keywords(); end
end

class Rouge::Lexers::Lua
  def builtins(); end
end

class Rouge::Lexers::Lua
  def self.builtins(); end
end

class Rouge::Lexers::Lustre
  def self.keywords(); end

  def self.primitives(); end

  def self.word_operators(); end
end

class Rouge::Lexers::M68k
  def self.builtins(); end

  def self.keywords(); end

  def self.keywords_type(); end

  def self.reserved(); end
end

class Rouge::Lexers::Magik
  def self.character(); end

  def self.decimal(); end

  def self.digits(); end

  def self.exponent(); end

  def self.global_ref(); end

  def self.identifier(); end

  def self.keywords(); end

  def self.label(); end

  def self.number(); end

  def self.package_identifier(); end

  def self.piped_identifier(); end

  def self.radix(); end

  def self.simple_identifier(); end

  def self.string_double(); end

  def self.string_single(); end

  def self.symbol(); end
end

class Rouge::Lexers::Make
  def self.functions(); end
end

class Rouge::Lexers::Markdown
  def html(); end
end

class Rouge::Lexers::Mason
  def initialize(*arg); end
  COMPONENTS = ::T.let(nil, ::T.untyped)
  PERL_BLOCKS = ::T.let(nil, ::T.untyped)
  TEXT_BLOCKS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Mathematica
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::Matlab
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::Meson
  def current_string(); end
end

class Rouge::Lexers::Meson
  def self.builtin_functions(); end

  def self.builtin_variables(); end

  def self.keywords(); end
end

class Rouge::Lexers::MiniZinc
  def self.builtins(); end

  def self.keywords(); end

  def self.keywords_type(); end

  def self.operators(); end
end

class Rouge::Lexers::Moonscript
  def builtins(); end

  def initialize(*arg); end
end

class Rouge::Lexers::NesAsm
  def self.keywords(); end

  def self.keywords_reserved(); end

  def self.keywords_type(); end
end

class Rouge::Lexers::Nial
  def self.consts(); end

  def self.funcs(); end

  def self.keywords(); end

  def self.operators(); end

  def self.punctuations(); end

  def self.transformers(); end
end

class Rouge::Lexers::Nim
  KEYWORDS = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  OPWORDS = ::T.let(nil, ::T.untyped)
  PSEUDOKEYWORDS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Nim
  def self.underscorize(words); end
end

class Rouge::Lexers::OCL
  def self.builtins(); end

  def self.functions(); end

  def self.keywords(); end

  def self.keywords_type(); end

  def self.operators(); end
end

class Rouge::Lexers::OCamlCommon
  def self.keywords(); end

  def self.primitives(); end

  def self.word_operators(); end
end

module Rouge::Lexers::ObjectiveCCommon
  def at_builtins(); end

  def at_keywords(); end

  def builtins(); end
end

module Rouge::Lexers::ObjectiveCCommon
  def self.extended(base); end
end

class Rouge::Lexers::OpenEdge
  def self.keywords(); end

  def self.keywords_prepro(); end

  def self.keywords_type(); end
end

class Rouge::Lexers::OpenTypeFeatureFile
  def self.keywords(); end
end

class Rouge::Lexers::PHP
  def builtins(); end

  def initialize(*arg); end
end

class Rouge::Lexers::PHP
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::PLSQL
  def self.keywords(); end

  def self.keywords_func(); end

  def self.keywords_reserved(); end

  def self.keywords_type(); end
end

class Rouge::Lexers::PlainText
  def initialize(*arg); end

  def stream_tokens(string, &b); end

  def token(); end
end

class Rouge::Lexers::Powershell
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  AUTO_VARS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_TYPE = ::T.let(nil, ::T.untyped)
  MULTILINE_KEYWORDS = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Praat
  def self.functions_array(); end

  def self.functions_builtin(); end

  def self.functions_matrix(); end

  def self.functions_numeric(); end

  def self.functions_string(); end

  def self.functions_string_vector(); end

  def self.keywords(); end

  def self.object_attributes(); end

  def self.objects(); end

  def self.variables_numeric(); end

  def self.variables_string(); end
end

class Rouge::Lexers::Prometheus
  def self.functions(); end
end

class Rouge::Lexers::Puppet
  def self.constants(); end

  def self.keywords(); end

  def self.metaparameters(); end
end

class Rouge::Lexers::Python
  def current_string(); end
end

class Rouge::Lexers::Python
  def self.builtins(); end

  def self.builtins_pseudo(); end

  def self.exceptions(); end

  def self.keywords(); end
end

class Rouge::Lexers::Q
  def self.builtins(); end

  def self.keywords(); end

  def self.word_operators(); end
end

class Rouge::Lexers::R
  BUILTIN_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_CONSTANTS = ::T.let(nil, ::T.untyped)
  PRIMITIVE_FUNCTIONS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::RML
  def self.arithmetic_keywords(); end

  def self.keywords(); end
end

class Rouge::Lexers::Racket
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::ReScript
  def self.types(); end
end

class Rouge::Lexers::Rego
  def self.constants(); end

  def self.operators(); end
end

class Rouge::Lexers::RobotFramework
  def self.settings_with_args(); end

  def self.settings_with_keywords(); end
end

class Rouge::Lexers::Rust
  def macro_closed?(); end
end

class Rouge::Lexers::Rust
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::SAS
  def self.data_step_statements(); end

  def self.proc_keywords(); end

  def self.sas_auto_macro_vars(); end

  def self.sas_functions(); end

  def self.sas_macro_functions(); end

  def self.sas_macro_statements(); end

  def self.sas_proc_names(); end
end

class Rouge::Lexers::SML
  def token_for_final_id(id); end

  def token_for_id(id); end

  def token_for_id_with_dot(id); end
end

class Rouge::Lexers::SML
  def self.keywords(); end

  def self.symbolic_reserved(); end
end

class Rouge::Lexers::SPARQL
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::SQF
  def self.commands(); end

  def self.constants(); end

  def self.controlflow(); end

  def self.diag_commands(); end

  def self.initializers(); end

  def self.namespaces(); end

  def self.wordoperators(); end
end

class Rouge::Lexers::SQL
  def self.keywords(); end

  def self.keywords_type(); end
end

class Rouge::Lexers::Scheme
  def self.builtins(); end

  def self.keywords(); end
end

class Rouge::Lexers::Sed
  def regex(); end

  def replacement(); end
end

class Rouge::Lexers::Shell
  BUILTINS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Sieve
  def self.actions(); end

  def self.controls(); end

  def self.tests(); end
end

class Rouge::Lexers::Slim
  def filters(); end

  def html(); end

  def ruby(); end
end

class Rouge::Lexers::Smarty
  def self.builtins(); end
end

class Rouge::Lexers::Stan
  ID = ::T.let(nil, ::T.untyped)
  OP = ::T.let(nil, ::T.untyped)
  RT = ::T.let(nil, ::T.untyped)
  WS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Stan
  def self.builtin_functions(); end

  def self.constants(); end

  def self.distributions(); end

  def self.keywords(); end

  def self.reserved(); end

  def self.types(); end
end

class Rouge::Lexers::Stata
  KEYWORDS = ::T.let(nil, ::T.untyped)
  PRIMITIVE_FUNCTIONS = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Stata
  def self.reserved_keywords(); end

  def self.type_keywords(); end
end

class Rouge::Lexers::SuperCollider
  def self.constants(); end

  def self.keywords(); end

  def self.reserved(); end
end

class Rouge::Lexers::Svelte
  def initialize(*arg); end
end

class Rouge::Lexers::Syzlang
  def self.keywords(); end

  def self.keywords_type(); end
end

class Rouge::Lexers::Syzprog
  def self.keywords(); end
end

class Rouge::Lexers::TCL
  ALL = ::T.let(nil, ::T.untyped)
  BUILTINS = ::T.let(nil, ::T.untyped)
  CHARS = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  END_LINE = ::T.let(nil, ::T.untyped)
  END_WORD = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  NOT_CHARS = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::TCL
  def self.gen_command_state(name=T.unsafe(nil)); end

  def self.gen_delimiter_states(name, close, opts=T.unsafe(nil)); end
end

class Rouge::Lexers::TTCN3
  def self.keywords(); end

  def self.reserved(); end

  def self.types(); end
end

module Rouge::Lexers::TypescriptCommon
  def builtins(); end

  def declarations(); end

  def keywords(); end

  def reserved(); end
end

module Rouge::Lexers::TypescriptCommon
  def self.extended(base); end
end

class Rouge::Lexers::VHDL
  def self.keywords(); end

  def self.keywords_type(); end

  def self.operator_words(); end
end

class Rouge::Lexers::Varnish
  SPACE = ::T.let(nil, ::T.untyped)
end

class Rouge::Lexers::Varnish
  def self.functions(); end

  def self.keywords(); end

  def self.variables(); end
end

class Rouge::Lexers::Verilog
  def self.keywords(); end

  def self.keywords_system_task(); end

  def self.keywords_type(); end
end

class Rouge::Lexers::VimL
  def self.keywords(); end
end

class Rouge::Lexers::VisualBasic
  def self.builtins(); end

  def self.keywords(); end

  def self.keywords_type(); end

  def self.operator_words(); end
end

class Rouge::Lexers::Vue
  def initialize(*arg); end

  def lookup_lang(lang); end
end

class Rouge::Lexers::XPath
  def self.axes(); end

  def self.commentStart(); end

  def self.constructorTypes(); end

  def self.decimalLiteral(); end

  def self.digits(); end

  def self.doubleLiteral(); end

  def self.eqName(); end

  def self.keywords(); end

  def self.kindTest(); end

  def self.kindTestForPI(); end

  def self.ncName(); end

  def self.openParen(); end

  def self.operators(); end

  def self.qName(); end

  def self.stringLiteral(); end

  def self.uriQName(); end

  def self.word_operators(); end
end

class Rouge::Lexers::YAML
  def continue_indent(match); end

  def dedent?(level); end

  def indent(); end

  def indent?(level); end

  def reset_indent(); end

  def save_indent(match); end

  def set_indent(match, opts=T.unsafe(nil)); end
end

class Rouge::Lexers::YANG
  def self.body_stmts_keywords(); end

  def self.constants_keywords(); end

  def self.data_def_stmts_keywords(); end

  def self.linkage_stmts_keywords(); end

  def self.list_stmts_keywords(); end

  def self.meta_stmts_keywords(); end

  def self.module_header_stmts_keywords(); end

  def self.top_stmts_keywords(); end

  def self.type_stmts_keywords(); end

  def self.types(); end
end

class Rouge::Lexers::Zig
  def self.builtins(); end

  def self.keywords(); end
end

module Rouge::Lexers
  def self.load_lexer(relpath); end
end

class Rouge::RegexLexer
  def delegate(lexer, text=T.unsafe(nil)); end

  def get_state(state_name); end

  def goto(state_name); end

  def group(tok); end

  def groups(*tokens); end

  def in_state?(state_name); end

  def pop!(times=T.unsafe(nil)); end

  def push(state_name=T.unsafe(nil), &b); end

  def recurse(text=T.unsafe(nil)); end

  def reset_stack(); end

  def stack(); end

  def state(); end

  def state?(state_name); end

  def step(state, stream); end

  def stream_tokens(str, &b); end

  def token(tok, val=T.unsafe(nil)); end
  MAX_NULL_SCANS = ::T.let(nil, ::T.untyped)
end

class Rouge::RegexLexer::ClosedState
  def initialize(state); end

  def rule(); end

  def state(); end
end

class Rouge::RegexLexer::InvalidRegex
  def initialize(re); end
end

class Rouge::RegexLexer::Rule
  def beginning_of_line(); end

  def callback(); end

  def initialize(re, callback); end

  def re(); end
end

class Rouge::RegexLexer::State
  def initialize(name, rules); end

  def name(); end

  def rules(); end
end

class Rouge::RegexLexer::StateDSL
  def appended(&defn); end

  def close!(); end

  def context_sensitive?(re); end

  def initialize(name, &defn); end

  def mixin(state); end

  def name(); end

  def prepended(&defn); end

  def rule(re, tok=T.unsafe(nil), next_state=T.unsafe(nil), &callback); end

  def rules(); end

  def to_state(lexer_class); end
end

class Rouge::RegexLexer
  def self.append(name, &b); end

  def self.get_state(name); end

  def self.prepend(name, &b); end

  def self.replace_state(name, new_defn); end

  def self.start(&b); end

  def self.start_procs(); end

  def self.state(name, &b); end

  def self.state_definitions(); end

  def self.states(); end
end

class Rouge::TemplateLexer
  def parent(); end
end

class Rouge::TexThemeRenderer
  def camelize(name); end

  def gen_inline(name, &b); end

  def initialize(theme, opts=T.unsafe(nil)); end

  def inline_name(color); end

  def palette_name(name); end

  def render(&b); end

  def render_blank(tok, &b); end

  def render_inline_pallete(style, &b); end

  def render_palette(palette, &b); end

  def render_style(tok, style, &b); end

  def token_name(tok); end
end

class Rouge::TextAnalyzer
  def doctype(); end

  def doctype?(type=T.unsafe(nil)); end

  def lexes_cleanly?(lexer); end

  def shebang(); end

  def shebang?(match); end
end

class Rouge::Theme
  def get_own_style(token); end

  def get_style(token); end

  def name(); end

  def palette(*a); end

  def styles(); end
end

class Rouge::Theme::Style
  def bg(); end

  def fg(); end

  def initialize(theme, hsh=T.unsafe(nil)); end

  def render(selector, &b); end

  def rendered_rules(&b); end
end

class Rouge::Theme
  def self.base_style(); end

  def self.find(n); end

  def self.get_own_style(token); end

  def self.get_style(token); end

  def self.name(n=T.unsafe(nil)); end

  def self.palette(arg=T.unsafe(nil)); end

  def self.register(name); end

  def self.registry(); end

  def self.render(opts=T.unsafe(nil), &b); end

  def self.style(*tokens); end

  def self.styles(); end
end

class Rouge::Themes::Base16
  def self.dark!(); end

  def self.light!(); end

  def self.make_dark!(); end

  def self.make_light!(); end
end

class Rouge::Themes::Github
  P_BLUE_1 = ::T.let(nil, ::T.untyped)
  P_BLUE_2 = ::T.let(nil, ::T.untyped)
  P_BLUE_5 = ::T.let(nil, ::T.untyped)
  P_BLUE_6 = ::T.let(nil, ::T.untyped)
  P_BLUE_8 = ::T.let(nil, ::T.untyped)
  P_GRAY_0 = ::T.let(nil, ::T.untyped)
  P_GRAY_1 = ::T.let(nil, ::T.untyped)
  P_GRAY_3 = ::T.let(nil, ::T.untyped)
  P_GRAY_5 = ::T.let(nil, ::T.untyped)
  P_GRAY_8 = ::T.let(nil, ::T.untyped)
  P_GRAY_9 = ::T.let(nil, ::T.untyped)
  P_GREEN_0 = ::T.let(nil, ::T.untyped)
  P_GREEN_1 = ::T.let(nil, ::T.untyped)
  P_GREEN_6 = ::T.let(nil, ::T.untyped)
  P_GREEN_8 = ::T.let(nil, ::T.untyped)
  P_ORANGE_2 = ::T.let(nil, ::T.untyped)
  P_ORANGE_6 = ::T.let(nil, ::T.untyped)
  P_PURPLE_2 = ::T.let(nil, ::T.untyped)
  P_PURPLE_5 = ::T.let(nil, ::T.untyped)
  P_RED_0 = ::T.let(nil, ::T.untyped)
  P_RED_3 = ::T.let(nil, ::T.untyped)
  P_RED_5 = ::T.let(nil, ::T.untyped)
  P_RED_7 = ::T.let(nil, ::T.untyped)
  P_RED_8 = ::T.let(nil, ::T.untyped)
end

class Rouge::Themes::Github
  def self.dark!(); end

  def self.light!(); end

  def self.make_dark!(); end

  def self.make_light!(); end
end

class Rouge::Themes::Gruvbox
  C_bright_aqua = ::T.let(nil, ::T.untyped)
  C_bright_blue = ::T.let(nil, ::T.untyped)
  C_bright_green = ::T.let(nil, ::T.untyped)
  C_bright_orange = ::T.let(nil, ::T.untyped)
  C_bright_purple = ::T.let(nil, ::T.untyped)
  C_bright_red = ::T.let(nil, ::T.untyped)
  C_bright_yellow = ::T.let(nil, ::T.untyped)
  C_dark0 = ::T.let(nil, ::T.untyped)
  C_dark0_hard = ::T.let(nil, ::T.untyped)
  C_dark0_soft = ::T.let(nil, ::T.untyped)
  C_dark1 = ::T.let(nil, ::T.untyped)
  C_dark2 = ::T.let(nil, ::T.untyped)
  C_dark3 = ::T.let(nil, ::T.untyped)
  C_dark4 = ::T.let(nil, ::T.untyped)
  C_dark4_256 = ::T.let(nil, ::T.untyped)
  C_faded_aqua = ::T.let(nil, ::T.untyped)
  C_faded_blue = ::T.let(nil, ::T.untyped)
  C_faded_green = ::T.let(nil, ::T.untyped)
  C_faded_orange = ::T.let(nil, ::T.untyped)
  C_faded_purple = ::T.let(nil, ::T.untyped)
  C_faded_red = ::T.let(nil, ::T.untyped)
  C_faded_yellow = ::T.let(nil, ::T.untyped)
  C_gray_244 = ::T.let(nil, ::T.untyped)
  C_gray_245 = ::T.let(nil, ::T.untyped)
  C_light0 = ::T.let(nil, ::T.untyped)
  C_light0_hard = ::T.let(nil, ::T.untyped)
  C_light0_soft = ::T.let(nil, ::T.untyped)
  C_light1 = ::T.let(nil, ::T.untyped)
  C_light2 = ::T.let(nil, ::T.untyped)
  C_light3 = ::T.let(nil, ::T.untyped)
  C_light4 = ::T.let(nil, ::T.untyped)
  C_light4_256 = ::T.let(nil, ::T.untyped)
  C_neutral_aqua = ::T.let(nil, ::T.untyped)
  C_neutral_blue = ::T.let(nil, ::T.untyped)
  C_neutral_green = ::T.let(nil, ::T.untyped)
  C_neutral_orange = ::T.let(nil, ::T.untyped)
  C_neutral_purple = ::T.let(nil, ::T.untyped)
  C_neutral_red = ::T.let(nil, ::T.untyped)
  C_neutral_yellow = ::T.let(nil, ::T.untyped)
end

class Rouge::Themes::Gruvbox
  def self.dark!(); end

  def self.light!(); end

  def self.make_dark!(); end

  def self.make_light!(); end
end

module Rouge::Token::Tokens
  def self.token(name, shortname, &b); end
end

class Rouge::Token
  def self.[](qualname); end

  def self.cache(); end

  def self.each_token(&b); end

  def self.make_token(name, shortname, &b); end

  def self.matches?(other); end

  def self.parent(); end

  def self.qualname(); end

  def self.register!(); end

  def self.shortname(); end

  def self.sub_tokens(); end

  def self.token(name, shortname, &b); end

  def self.token_chain(); end
end

module Rouge
  def self.highlight(text, lexer, formatter, &b); end

  def self.load_file(path); end

  def self.load_lexers(); end

  def self.reload!(); end

  def self.version(); end
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AndNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::ArgNode
  def default?(); end

  def default_value(); end

  def name(); end
end

class RuboCop::AST::ArgsNode
  def argument_list(); end

  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def each_value(&block); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
end

class RuboCop::AST::AsgnNode
  def expression(); end

  def name(); end
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

class RuboCop::AST::BlockNode
  def argument_list(); end

  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def first_argument(); end

  def keywords?(); end

  def lambda?(); end

  def last_argument(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::CaseMatchNode
  def branches(); end

  def each_in_pattern(&block); end

  def else?(); end

  def else_branch(); end

  def in_pattern_branches(); end

  def keyword(); end
end

class RuboCop::AST::CaseNode
  def branches(); end

  def each_when(&block); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CasgnNode
  def expression(); end

  def name(); end

  def namespace(); end
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

module RuboCop::AST::CollectionNode
  def &(*args, **arg, &block); end

  def *(*args, **arg, &block); end

  def +(*args, **arg, &block); end

  def -(*args, **arg, &block); end

  def <<(*args, **arg, &block); end

  def [](*args, **arg, &block); end

  def []=(*args, **arg, &block); end

  def all?(*args, **arg, &block); end

  def any?(*args, **arg, &block); end

  def append(*args, **arg, &block); end

  def assoc(*args, **arg, &block); end

  def at(*args, **arg, &block); end

  def bsearch(*args, **arg, &block); end

  def bsearch_index(*args, **arg, &block); end

  def chain(*args, **arg, &block); end

  def chunk(*args, **arg, &block); end

  def chunk_while(*args, **arg, &block); end

  def clear(*args, **arg, &block); end

  def collect(*args, **arg, &block); end

  def collect!(*args, **arg, &block); end

  def collect_concat(*args, **arg, &block); end

  def combination(*args, **arg, &block); end

  def compact(*args, **arg, &block); end

  def compact!(*args, **arg, &block); end

  def compact_blank(*args, **arg, &block); end

  def compact_blank!(*args, **arg, &block); end

  def concat(*args, **arg, &block); end

  def count(*args, **arg, &block); end

  def cycle(*args, **arg, &block); end

  def deconstruct(*args, **arg, &block); end

  def delete(*args, **arg, &block); end

  def delete_at(*args, **arg, &block); end

  def delete_if(*args, **arg, &block); end

  def detect(*args, **arg, &block); end

  def difference(*args, **arg, &block); end

  def dig(*args, **arg, &block); end

  def drop(*args, **arg, &block); end

  def drop_while(*args, **arg, &block); end

  def each(*args, **arg, &block); end

  def each_cons(*args, **arg, &block); end

  def each_entry(*args, **arg, &block); end

  def each_index(*args, **arg, &block); end

  def each_slice(*args, **arg, &block); end

  def each_with_index(*args, **arg, &block); end

  def each_with_object(*args, **arg, &block); end

  def empty?(*args, **arg, &block); end

  def entries(*args, **arg, &block); end

  def exclude?(*args, **arg, &block); end

  def excluding(*args, **arg, &block); end

  def extract!(*args, **arg, &block); end

  def extract_options!(*args, **arg, &block); end

  def fetch(*args, **arg, &block); end

  def fifth(*args, **arg, &block); end

  def fill(*args, **arg, &block); end

  def filter(*args, **arg, &block); end

  def filter!(*args, **arg, &block); end

  def filter_map(*args, **arg, &block); end

  def find(*args, **arg, &block); end

  def find_all(*args, **arg, &block); end

  def find_index(*args, **arg, &block); end

  def first(*args, **arg, &block); end

  def flat_map(*args, **arg, &block); end

  def flatten(*args, **arg, &block); end

  def flatten!(*args, **arg, &block); end

  def forty_two(*args, **arg, &block); end

  def fourth(*args, **arg, &block); end

  def from(*args, **arg, &block); end

  def grep(*args, **arg, &block); end

  def grep_v(*args, **arg, &block); end

  def group_by(*args, **arg, &block); end

  def in_groups(*args, **arg, &block); end

  def in_groups_of(*args, **arg, &block); end

  def in_order_of(*args, **arg, &block); end

  def include?(*args, **arg, &block); end

  def including(*args, **arg, &block); end

  def index(*args, **arg, &block); end

  def index_by(*args, **arg, &block); end

  def index_with(*args, **arg, &block); end

  def inject(*args, **arg, &block); end

  def inquiry(*args, **arg, &block); end

  def insert(*args, **arg, &block); end

  def intersect?(*args, **arg, &block); end

  def intersection(*args, **arg, &block); end

  def join(*args, **arg, &block); end

  def keep_if(*args, **arg, &block); end

  def last(*args, **arg, &block); end

  def lazy(*args, **arg, &block); end

  def length(*args, **arg, &block); end

  def many?(*args, **arg, &block); end

  def map(*args, **arg, &block); end

  def map!(*args, **arg, &block); end

  def max(*args, **arg, &block); end

  def max_by(*args, **arg, &block); end

  def maximum(*args, **arg, &block); end

  def member?(*args, **arg, &block); end

  def min(*args, **arg, &block); end

  def min_by(*args, **arg, &block); end

  def minimum(*args, **arg, &block); end

  def minmax(*args, **arg, &block); end

  def minmax_by(*args, **arg, &block); end

  def none?(*args, **arg, &block); end

  def one?(*args, **arg, &block); end

  def pack(*args, **arg, &block); end

  def partition(*args, **arg, &block); end

  def permutation(*args, **arg, &block); end

  def pick(*args, **arg, &block); end

  def pluck(*args, **arg, &block); end

  def pop(*args, **arg, &block); end

  def prepend(*args, **arg, &block); end

  def product(*args, **arg, &block); end

  def push(*args, **arg, &block); end

  def rassoc(*args, **arg, &block); end

  def reduce(*args, **arg, &block); end

  def reject(*args, **arg, &block); end

  def reject!(*args, **arg, &block); end

  def repeated_combination(*args, **arg, &block); end

  def repeated_permutation(*args, **arg, &block); end

  def replace(*args, **arg, &block); end

  def reverse(*args, **arg, &block); end

  def reverse!(*args, **arg, &block); end

  def reverse_each(*args, **arg, &block); end

  def rindex(*args, **arg, &block); end

  def rotate(*args, **arg, &block); end

  def rotate!(*args, **arg, &block); end

  def sample(*args, **arg, &block); end

  def second(*args, **arg, &block); end

  def second_to_last(*args, **arg, &block); end

  def select(*args, **arg, &block); end

  def select!(*args, **arg, &block); end

  def shelljoin(*args, **arg, &block); end

  def shift(*args, **arg, &block); end

  def shuffle(*args, **arg, &block); end

  def shuffle!(*args, **arg, &block); end

  def size(*args, **arg, &block); end

  def slice(*args, **arg, &block); end

  def slice!(*args, **arg, &block); end

  def slice_after(*args, **arg, &block); end

  def slice_before(*args, **arg, &block); end

  def slice_when(*args, **arg, &block); end

  def sole(*args, **arg, &block); end

  def sort(*args, **arg, &block); end

  def sort!(*args, **arg, &block); end

  def sort_by(*args, **arg, &block); end

  def sort_by!(*args, **arg, &block); end

  def split(*args, **arg, &block); end

  def sum(*args, **arg, &block); end

  def take(*args, **arg, &block); end

  def take_while(*args, **arg, &block); end

  def tally(*args, **arg, &block); end

  def third(*args, **arg, &block); end

  def third_to_last(*args, **arg, &block); end

  def to(*args, **arg, &block); end

  def to_ary(*args, **arg, &block); end

  def to_csv(*args, **arg, &block); end

  def to_default_s(*args, **arg, &block); end

  def to_formatted_s(*args, **arg, &block); end

  def to_fs(*args, **arg, &block); end

  def to_h(*args, **arg, &block); end

  def to_msgpack(*args, **arg, &block); end

  def to_sentence(*args, **arg, &block); end

  def to_set(*args, **arg, &block); end

  def to_xml(*args, **arg, &block); end

  def transpose(*args, **arg, &block); end

  def union(*args, **arg, &block); end

  def uniq(*args, **arg, &block); end

  def uniq!(*args, **arg, &block); end

  def unshift(*args, **arg, &block); end

  def values_at(*args, **arg, &block); end

  def without(*args, **arg, &block); end

  def zip(*args, **arg, &block); end

  def |(*args, **arg, &block); end
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

class RuboCop::AST::ConstNode
  def absolute?(); end

  def class_name?(); end

  def each_path(&block); end

  def module_name?(); end

  def namespace(); end

  def relative?(); end

  def short_name(); end
end

class RuboCop::AST::DefNode
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def endless?(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefinedNode
  def arguments(); end
end

module RuboCop::AST::Descendence
  def child_nodes(); end

  def descendants(); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def visit_descendants(types, &block); end
end

class RuboCop::AST::EnsureNode
  def body(); end
end

module RuboCop::AST::Ext::Range
  def line_span(exclude_end: T.unsafe(nil)); end
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(&block); end

  def each_pair(); end

  def each_value(&block); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::IfNode
  def branches(); end

  def each_branch(&block); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::InPatternNode
  def body(); end

  def branch_index(); end

  def pattern(); end

  def then?(); end
end

class RuboCop::AST::IndexNode
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexasgnNode
  def attribute_accessor?(); end
end

class RuboCop::AST::KeywordSplatNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
end

class RuboCop::AST::LambdaNode
  def attribute_accessor?(); end
end

module RuboCop::AST::MethodDispatchNode
  def access_modifier?(); end

  def adjacent_def_modifier?(param0=T.unsafe(nil)); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier(node=T.unsafe(nil)); end

  def def_modifier?(node=T.unsafe(nil)); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def in_macro_scope?(param0=T.unsafe(nil)); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def receiver(); end

  def safe_navigation?(); end

  def selector(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerable_method?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def nonmutating_array_method?(); end

  def nonmutating_binary_operator_method?(); end

  def nonmutating_hash_method?(); end

  def nonmutating_operator_method?(); end

  def nonmutating_string_method?(); end

  def nonmutating_unary_operator_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::Node
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def argument_type?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(param0=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def class_constructor?(param0=T.unsafe(nil)); end

  def class_definition?(param0=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def find_pattern_type?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_arg_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def forwarded_kwrestarg_type?(); end

  def forwarded_restarg_type?(); end

  def global_const?(param0=T.unsafe(nil), param1); end

  def guard_clause?(); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwargs_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(param0=T.unsafe(nil)); end

  def lambda_or_proc?(param0=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def left_sibling(); end

  def left_siblings(); end

  def line_count(); end

  def literal?(); end

  def loop_keyword?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_guard_clause?(param0=T.unsafe(nil)); end

  def match_nil_pattern_type?(); end

  def match_pattern_p_type?(); end

  def match_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_definition?(param0=T.unsafe(nil)); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(param0=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent?(); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def post_condition_loop?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(param0=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rational_type?(); end

  def receiver(param0=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def right_sibling(); end

  def right_siblings(); end

  def root?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(param0=T.unsafe(nil)); end

  def str_type?(); end

  def struct_constructor?(param0=T.unsafe(nil)); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
  def ==(other); end

  def as_json(_options=T.unsafe(nil)); end

  def ast(); end

  def captures(*args, **arg, &block); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def initialize(str, compiler: T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args, **rest, &block); end

  def match_code(); end

  def named_parameters(*args, **arg, &block); end

  def pattern(); end

  def positional_parameters(*args, **arg, &block); end
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Builder
  def emit_atom(type, value); end

  def emit_call(type, selector, args=T.unsafe(nil)); end

  def emit_capture(capture_token, node); end

  def emit_list(type, _begin, children, _end); end

  def emit_subsequence(node_list); end

  def emit_unary_op(type, _operator=T.unsafe(nil), *children); end

  def emit_union(begin_t, pattern_lists, end_t); end
end

class RuboCop::AST::NodePattern::Comment
  def ==(other); end

  def initialize(range); end

  def loc(); end

  def location(); end

  def text(); end
end

class RuboCop::AST::NodePattern::Compiler
  def bind(*args, **arg, &block); end

  def captures(); end

  def compile_as_atom(node); end

  def compile_as_node_pattern(node, **options); end

  def compile_sequence(sequence, var:); end

  def each_union(enum, &block); end

  def named_parameter(name); end

  def named_parameters(); end

  def next_capture(); end

  def parser(); end

  def positional_parameter(number); end

  def positional_parameters(); end

  def with_temp_variables(*names, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Binding
  def bind(name); end

  def union_bind(enum); end
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*args, **arg, &block); end

  def node_ids(); end

  def tokens(*args, **arg, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
  def access(); end

  def initialize(compiler, var: T.unsafe(nil), access: T.unsafe(nil), seq_head: T.unsafe(nil)); end

  def seq_head(); end
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  def compile_sequence(); end

  def compile_terms(children=T.unsafe(nil), last_arity=T.unsafe(nil)); end

  def cur_index(); end

  def in_sync(); end

  def initialize(compiler, sequence:, var:); end

  def sync(); end
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def compile(node); end

  def compiler(); end

  def initialize(compiler); end
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def self.inherited(base); end

  def self.method_added(method); end

  def self.registry(); end
end

class RuboCop::AST::NodePattern::Lexer
  def comments(); end

  def initialize(source); end

  def source_buffer(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::LexerRex
  def action(); end

  def filename(); end

  def filename=(filename); end

  def location(); end

  def match(); end

  def matches(); end

  def next_token(); end

  def parse(str); end

  def parse_file(path); end

  def scanner_class(); end

  def ss(); end

  def ss=(ss); end

  def state(); end

  def state=(state); end
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str, **keyword_defaults); end

  def def_node_search(method_name, pattern_str, **keyword_defaults); end
end

module RuboCop::AST::NodePattern::MethodDefiner
  def as_lambda(); end

  def compile_as_lambda(); end

  def def_node_matcher(base, method_name, **defaults); end

  def def_node_search(base, method_name, **defaults); end
end

class RuboCop::AST::NodePattern::Node
  def arity(); end

  def arity_range(); end

  def capture?(); end

  def child(); end

  def children_nodes(); end

  def in_sequence_head(); end

  def matches_within_set?(); end

  def nb_captures(); end

  def rest?(); end

  def source_range(); end

  def variadic?(); end

  def with(type: T.unsafe(nil), children: T.unsafe(nil), location: T.unsafe(nil)); end
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::AnyOrder
  def ends_with_rest?(); end

  def rest_node(); end

  def term_nodes(); end
end

class RuboCop::AST::NodePattern::Node::Capture
  def arity(*args, **arg, &block); end

  def rest?(*args, **arg, &block); end
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def in_sequence_head(); end
end

class RuboCop::AST::NodePattern::Node::Predicate
  def arg_list(); end

  def method_name(); end
end

class RuboCop::AST::NodePattern::Node::Repetition
  def operator(); end
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser
  def _reduce_10(val, _values); end

  def _reduce_11(val, _values); end

  def _reduce_13(val, _values); end

  def _reduce_14(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_19(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_20(val, _values); end

  def _reduce_21(val, _values); end

  def _reduce_22(val, _values); end

  def _reduce_25(val, _values); end

  def _reduce_26(val, _values); end

  def _reduce_3(val, _values); end

  def _reduce_33(val, _values); end

  def _reduce_37(val, _values); end

  def _reduce_38(val, _values); end

  def _reduce_39(val, _values); end

  def _reduce_4(val, _values); end

  def _reduce_40(val, _values); end

  def _reduce_41(val, _values); end

  def _reduce_42(val, _values); end

  def _reduce_43(val, _values); end

  def _reduce_44(val, _values); end

  def _reduce_45(val, _values); end

  def _reduce_46(val, _values); end

  def _reduce_5(val, _values); end

  def _reduce_6(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def emit_atom(*args, **arg, &block); end

  def emit_call(*args, **arg, &block); end

  def emit_capture(*args, **arg, &block); end

  def emit_list(*args, **arg, &block); end

  def emit_unary_op(*args, **arg, &block); end

  def emit_union(*args, **arg, &block); end

  def initialize(builder=T.unsafe(nil)); end

  def next_token(*args, **arg, &block); end

  def parse(source); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_AFTER_ACTION_APPEND_AFTER_ACTION_APPEND_AROUND_ACTION_ETC = ::T.let(nil, ::T.untyped)
  SET_ANY_EMPTY = ::T.let(nil, ::T.untyped)
  SET_ANY_EMPTY_NONE_ETC = ::T.let(nil, ::T.untyped)
  SET_AP_P_PP_ETC = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_BELONGS_TO_HAS_ONE_HAS_MANY_HAS_AND_BELONGS_TO_MANY = ::T.let(nil, ::T.untyped)
  SET_BINWRITE_SYSWRITE_WRITE_WRITE_NONBLOCK = ::T.let(nil, ::T.untyped)
  SET_BRANCH_REF_TAG = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CHANGE_COLUMN_EXECUTE = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_CLONE_DUP_FREEZE = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_CREATED_AT_UPDATED_AT = ::T.let(nil, ::T.untyped)
  SET_CREATED_AT_UPDATED_AT_2 = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_EXIST_EXISTS = ::T.let(nil, ::T.untyped)
  SET_FILETEST_FILE_DIR_SHELL = ::T.let(nil, ::T.untyped)
  SET_FILE_DIR = ::T.let(nil, ::T.untyped)
  SET_FILE_FILETEST = ::T.let(nil, ::T.untyped)
  SET_FILE_TEMPFILE = ::T.let(nil, ::T.untyped)
  SET_FILE_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GETHOSTBYADDR_GETHOSTBYNAME = ::T.let(nil, ::T.untyped)
  SET_GET_POST_PUT_ETC = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_HAS_MANY_HAS_ONE = ::T.let(nil, ::T.untyped)
  SET_HAS_MANY_HAS_ONE_BELONGS_TO = ::T.let(nil, ::T.untyped)
  SET_HTML_HTML5 = ::T.let(nil, ::T.untyped)
  SET_IF_UNLESS = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INSERT_INSERT = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_IO_FILE = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES_TO_H_TO_XML = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_MESSAGES_DETAILS = ::T.let(nil, ::T.untyped)
  SET_MODULE_FUNCTION_RUBY2_KEYWORDS = ::T.let(nil, ::T.untyped)
  SET_NEW_ = ::T.let(nil, ::T.untyped)
  SET_NEW_COMPILE = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_NOTICE_ALERT = ::T.let(nil, ::T.untyped)
  SET_ONLY_EXCEPT = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRESENT_ANY_BLANK_EMPTY = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PRIVATE_CLASS_METHOD = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_READ_BINREAD = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REFERER_REFERRER = ::T.let(nil, ::T.untyped)
  SET_REJECT_DELETE_IF_REJECT = ::T.let(nil, ::T.untyped)
  SET_RENDER_REDIRECT_TO = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_RETURNING_UNIQUE_BY = ::T.let(nil, ::T.untyped)
  SET_ROOT_PUBLIC_PATH = ::T.let(nil, ::T.untyped)
  SET_SELECT_FILTER_FIND_ALL = ::T.let(nil, ::T.untyped)
  SET_SELECT_SELECT = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SKIP_AFTER_ACTION_SKIP_AROUND_ACTION_SKIP_BEFORE_ACTION_SKIP_ACTION_CALLBACK = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_STDOUT_STDERR = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TIME_DATETIME = ::T.let(nil, ::T.untyped)
  SET_TO_ENUM_ENUM_FOR = ::T.let(nil, ::T.untyped)
  SET_TO_H_TO_HASH = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C_TO_R = ::T.let(nil, ::T.untyped)
  SET_TRANSLATE_LOCALIZE = ::T.let(nil, ::T.untyped)
  SET_TRANSLATE_T = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_TRY_TRY = ::T.let(nil, ::T.untyped)
  SET_T_TRANSLATE_L_LOCALIZE = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__FETCH = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET__PUSH_APPEND = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET___7 = ::T.let(nil, ::T.untyped)
  SET___8 = ::T.let(nil, ::T.untyped)
  SET___EQL_ETC = ::T.let(nil, ::T.untyped)
  SET___EQL_INCLUDE = ::T.let(nil, ::T.untyped)
  SET___METHOD_____CALLEE__ = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____2 = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
  SET____ETC_4 = ::T.let(nil, ::T.untyped)
  SET_____2 = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NodePattern::Sets
  def self.[](set); end

  def self.name(set); end

  def self.uniq(name); end
end

class RuboCop::AST::NodePattern
  def self.descend(element, &block); end
end

module RuboCop::AST::NumericNode
  def sign?(); end
end

class RuboCop::AST::OpAsgnNode
  def assignment_node(); end

  def expression(); end

  def name(); end

  def operator(); end
end

class RuboCop::AST::OrNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::PairNode
  def colon?(); end

  def delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def value_omission?(); end

  def value_on_new_line?(); end
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
  def arguments(); end

  def arguments?(); end

  def first_argument(); end

  def last_argument(); end
  EMPTY_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
  def arguments(); end
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
end

class RuboCop::AST::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def buffer(); end

  def checksum(); end

  def comment_at_line(line); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def contains_comment?(source_range); end

  def current_line(token); end

  def diagnostics(); end

  def each_comment(&block); end

  def each_comment_in_lines(line_range); end

  def each_token(&block); end

  def file_path(); end

  def find_comment(&block); end

  def find_token(&block); end

  def first_token_of(range_or_node); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil), parser_engine: T.unsafe(nil)); end

  def last_token_of(range_or_node); end

  def line_indentation(line_number); end

  def line_with_comment?(line); end

  def lines(); end

  def parser_engine(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def sorted_tokens(); end

  def start_with?(string); end

  def tokens(); end

  def tokens_within(range_or_node); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  def self.from_file(path, ruby_version, parser_engine: T.unsafe(nil)); end
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RegexpNode
  def content(); end

  def delimiter?(char); end

  def delimiters(); end

  def extended?(); end

  def fixed_encoding?(); end

  def ignore_case?(); end

  def interpolation?(); end

  def multiline_mode?(); end

  def no_encoding?(); end

  def options(); end

  def percent_r_literal?(); end

  def regopt(); end

  def single_interpolation?(); end

  def slash_literal?(); end

  def to_regexp(); end
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def branch_index(); end

  def exception_variable(); end

  def exceptions(); end
end

class RuboCop::AST::RescueNode
  def body(); end

  def branches(); end

  def else?(); end

  def else_branch(); end

  def resbody_branches(); end
end

module RuboCop::AST::RuboCopCompatibility
  def rubocop_loaded(); end
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SendNode
  def attribute_accessor?(param0=T.unsafe(nil)); end
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

class RuboCop::AST::StrNode
  def character_literal?(); end

  def heredoc?(); end
end

class RuboCop::AST::SuperNode
  def arguments(); end
end

class RuboCop::AST::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def dot?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def new_line?(); end

  def pos(); end

  def regexp_dots?(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
  LEFT_PAREN_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Token
  def self.from_parser_token(parser_token); end
end

module RuboCop::AST::Traversal
  def on_(node); end

  def on___ENCODING__(node); end

  def on___FILE__(node); end

  def on___LINE__(node); end

  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_find_pattern(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_forwarded_kwrestarg(node); end

  def on_forwarded_restarg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwargs(node); end

  def on_kwbegin(node); end

  def on_kwnilarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_mrasgn(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_rasgn(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::UntilNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(&block); end

  def then?(); end
end

class RuboCop::AST::WhileNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::YieldNode
  def arguments(); end
end

class RuboCop::ArgumentsEnv
  def self.read_as_arguments(); end
end

class RuboCop::ArgumentsFile
  def self.read_as_arguments(); end
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
  DEFAULT_PARALLEL_OPTIONS = ::T.let(nil, ::T.untyped)
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_1_SKIPPED_ONLY_COPS = ::T.let(nil, ::T.untyped)
  PHASE_1_SKIPPED_ONLY_EXCLUDE = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
  PLACEHOLDER = ::T.let(nil, ::T.untyped)
  YAML_OPTIONAL_DOC_START = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  def run(); end
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::LSP
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowDocsUrl
  def run(); end
end

class RuboCop::CLI::Command::SuggestExtensions
  def run(); end
  INCLUDED_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::Version
  def run(); end
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CacheConfig
  def self.root_dir(); end
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CommentConfig
  def comment_only_line?(line_number); end

  def config(*args, **arg, &block); end

  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def cop_opted_in?(cop); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end

  def registry(*args, **arg, &block); end
  CONFIG_DISABLED_LINE_RANGE_MIN = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment
  def initialize(cop_name); end

  def line_number(); end

  def loc(); end

  def text(); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Expression
  def line(); end

  def line=(_); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Expression
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Loc
  def expression(); end

  def expression=(_); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Loc
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Config
  def [](*args, **arg, &block); end

  def []=(*args, **arg, &block); end

  def active_support_extensions_enabled?(); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def clusivity_config_for_badge?(badge); end

  def delete(*args, **arg, &block); end

  def deprecation_check(); end

  def dig(*args, **arg, &block); end

  def disabled_new_cops?(); end

  def each(*args, **arg, &block); end

  def each_key(*args, **arg, &block); end

  def enabled_new_cops?(); end

  def fetch(*args, **arg, &block); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_badge(badge); end

  def for_cop(cop); end

  def for_department(department_name); end

  def gem_versions_in_target(); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*args, **arg, &block); end

  def keys(*args, **arg, &block); end

  def loaded_features(); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*args, **arg, &block); end

  def merge(*args, **arg, &block); end

  def parser_engine(); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def pending_cops(); end

  def possibly_include_hidden?(); end

  def replace(*args, **arg, &block); end

  def signature(); end

  def smart_loaded_path(); end

  def target_rails_version(); end

  def target_ruby_version(*args, **arg, &block); end

  def to_h(*args, **arg, &block); end

  def to_hash(*args, **arg, &block); end

  def transform_values(*args, **arg, &block); end

  def validate(*args, **arg, &block); end

  def validate_after_resolution(); end
end

class RuboCop::Config::CopConfig
  def metadata(); end

  def metadata=(_); end

  def name(); end

  def name=(_); end
end

class RuboCop::Config::CopConfig
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Config
  def self.create(hash, path, check: T.unsafe(nil)); end
end

class RuboCop::ConfigFinder
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigFinder
  extend ::RuboCop::FileFinder
  def self.find_config_path(target_dir); end

  def self.project_root(); end

  def self.project_root=(project_root); end
end

class RuboCop::ConfigLoader
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_loaded_features(loaded_features); end

  def self.add_missing_namespaces(path, hash); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file, check: T.unsafe(nil)); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.ignore_unrecognized_cops(); end

  def self.ignore_unrecognized_cops=(ignore_unrecognized_cops); end

  def self.inject_defaults!(project_root); end

  def self.load_file(file, check: T.unsafe(nil)); end

  def self.load_yaml_configuration(absolute_path); end

  def self.loaded_features(); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.pending_cops_only_qualified(pending_cops); end

  def self.possible_new_cops?(config); end

  def self.project_root(); end

  def self.warn_on_pending_cops(pending_cops); end

  def self.warn_pending_cop(cop); end
end

class RuboCop::ConfigLoaderResolver
  def fix_include_paths(base_config_path, hash, path, key, value); end

  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def override_department_setting_for_cops(base_hash, derived_hash); end

  def override_enabled_for_disabled_departments(base_hash, derived_hash); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete!(); end

  def rules(); end

  def warnings(); end
  COP_RULE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_RULES_FILE = ::T.let(nil, ::T.untyped)
  PARAMETER_RULE_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
  def message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedParameter
  def message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::CopRule
  def initialize(config, old_name); end

  def message(); end

  def old_name(); end

  def warning?(); end
end

class RuboCop::ConfigObsoletion::ExtractedCop
  def department(); end

  def gem(); end

  def initialize(config, old_name, gem); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::ParameterRule
  def cop(); end

  def initialize(config, cop, parameter, metadata); end

  def metadata(); end

  def parameter(); end

  def warning?(); end
end

class RuboCop::ConfigObsoletion::RemovedCop
  def initialize(config, old_name, metadata); end

  def metadata(); end

  def rule_message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::RenamedCop
  def initialize(config, old_name, new_name); end

  def new_name(); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::Rule
  def cop_rule?(); end

  def initialize(config); end

  def parameter_rule?(); end

  def violated?(); end
end

class RuboCop::ConfigObsoletion::SplitCop
  def initialize(config, old_name, metadata); end

  def metadata(); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion
  def self.files(); end

  def self.files=(files); end

  def self.legacy_cop_names(); end
end

class RuboCop::ConfigRegeneration
  def options(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def for_dir(dir); end

  def for_file(file); end

  def for_pwd(); end

  def force_default_config!(); end

  def options_config=(options_config); end

  def unvalidated(); end

  def validated(); end

  def validated?(); end
end

class RuboCop::ConfigValidator
  def for_all_cops(*args, **arg, &block); end

  def initialize(config); end

  def smart_loaded_path(*args, **arg, &block); end

  def target_ruby_version(); end

  def validate(); end

  def validate_after_resolution(); end

  def validate_section_presence(name); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  CONFIG_CHECK_AUTOCORRECTS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ActiveRecordHelper
  def active_record?(param0=T.unsafe(nil)); end

  def external_dependency_checksum(); end

  def find_belongs_to(param0); end

  def find_set_table_name(param0); end

  def foreign_key_of(belongs_to); end

  def in_where?(node); end

  def inherit_active_record_base?(node); end

  def polymorphic?(belongs_to); end

  def resolve_relation_into_column(name:, class_node:, table:); end

  def schema(); end

  def table_name(class_node); end
  WHERE_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ActiveRecordMigrationsHelper
  def create_table_with_block?(param0=T.unsafe(nil)); end
  MYSQL_SCHEMA_DEFINITIONS = ::T.let(nil, ::T.untyped)
  POSTGRES_SCHEMA_DEFINITIONS = ::T.let(nil, ::T.untyped)
  RAILS_ABSTRACT_SCHEMA_DEFINITIONS = ::T.let(nil, ::T.untyped)
  RAILS_ABSTRACT_SCHEMA_DEFINITIONS_HELPERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AlignmentCorrector
  def self.align_end(corrector, processed_source, node, align_to); end

  def self.correct(corrector, processed_source, node, column_delta); end

  def self.processed_source(); end
end

module RuboCop::Cop::AllowedIdentifiers
  def allowed_identifier?(name); end

  def allowed_identifiers(); end
  SIGILS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::AllowedReceivers
  def allowed_receiver?(receiver); end

  def allowed_receivers(); end

  def receiver_name(receiver); end
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AnnotationComment
  def annotation?(); end

  def bounds(); end

  def colon(); end

  def comment(); end

  def correct?(colon:); end

  def initialize(comment, keywords); end

  def keyword(); end

  def margin(); end

  def note(); end

  def space(); end
end

module RuboCop::Cop::AutoCorrector
  def support_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def autocorrect_with_disable_uncorrectable?(); end

  def correctable?(); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def department_name(); end

  def eql?(other); end

  def initialize(class_name_parts); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge
  def self.camel_case(name_part); end

  def self.for(class_name); end

  def self.parse(identifier); end
end

class RuboCop::Cop::Base
  def active_support_extensions_enabled?(); end

  def add_global_offense(message=T.unsafe(nil), severity: T.unsafe(nil)); end

  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def always_autocorrect?(); end

  def begin_investigation(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  def callbacks_needed(); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def contextual_autocorrect?(); end

  def cop_config(); end

  def cop_name(); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def message(_range=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def on_investigation_end(); end

  def on_new_investigation(); end

  def on_other_file(); end

  def parse(source, path=T.unsafe(nil)); end

  def parser_engine(); end

  def processed_source(); end

  def ready(); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base::InvestigationReport
  def cop(); end

  def cop=(_); end

  def corrector(); end

  def corrector=(_); end

  def offenses(); end

  def offenses=(_); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Base::InvestigationReport
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Base
  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.callbacks_needed(); end

  def self.cop_name(); end

  def self.department(); end

  def self.documentation_url(); end

  def self.exclude_from_registry(); end

  def self.gem_requirements(); end

  def self.inherited(subclass); end

  def self.joining_forces(); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.requires_gem(gem_name, *version_requirements); end

  def self.support_autocorrect?(); end

  def self.support_multiple_source?(); end
end

class RuboCop::Cop::Bundler::DuplicatedGem
  def gem_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGroup
  def group_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
  SOURCE_BLOCK_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
  def on_send(node); end
  CHECKED_OPTIONS_CONFIG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemFilename
  GEMFILE_FILES = ::T.let(nil, ::T.untyped)
  GEMS_RB_FILES = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_REQUIRED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemVersion
  def includes_commit_reference?(param0=T.unsafe(nil)); end

  def includes_version_specification?(param0=T.unsafe(nil)); end

  def on_send(node); end
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  def insecure_protocol_source?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_HTTP_PROTOCOL = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
  def gem_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::ClassSendNodeHelper
  def class_send_nodes(class_node); end
end

module RuboCop::Cop::CodeLength
  def max=(value); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CommentsHelp
  def comments_contain_disables?(node, cop_name); end

  def comments_in_range(node); end

  def contains_comments?(node); end

  def source_range_with_comment(node); end
end

class RuboCop::Cop::Commissioner
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def cop_reports(); end

  def cop_reports=(_); end

  def cops(); end

  def correctors(); end

  def errors(); end

  def errors=(_); end

  def merge(investigation); end

  def offenses(); end

  def offenses_per_cop(); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(corrector, node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_configured?(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableFormatting
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableNaming
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
  FORMATS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Cop
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def corrections(); end

  def find_location(node, loc); end

  def support_autocorrect?(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  def self.all(); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def initialize(source); end

  def remove_leading(node_or_range, size); end

  def remove_preceding(node_or_range, size); end

  def remove_trailing(node_or_range, size); end

  def rewrite(); end

  def swap(node_or_range1, node_or_range2); end
  NOOP_CONSUMER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Corrector
  def self.source_buffer(source); end
end

module RuboCop::Cop::DatabaseTypeResolvable
  def database(); end
  MYSQL = ::T.let(nil, ::T.untyped)
  POSTGRESQL = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::Documentation
  def self.base_url_for(cop_class, config); end

  def self.default_base_url(); end

  def self.department_to_basename(department); end

  def self.url_for(cop_class, config=T.unsafe(nil)); end
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(corrector, node); end

  def self.insert_before(corrector, node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::EndKeywordAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
  CORRECTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::GemDeclaration
  def gem_declaration?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Gemspec::DependencyVersion
  def add_dependency_method_declaration?(param0=T.unsafe(nil)); end

  def includes_commit_reference?(param0=T.unsafe(nil)); end

  def includes_version_specification?(param0=T.unsafe(nil)); end

  def on_send(node); end
  ADD_DEPENDENCY_METHODS = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment
  def gem_specification(param0=T.unsafe(nil)); end

  def on_block(block_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DevelopmentDependencies
  def add_development_dependency?(param0=T.unsafe(nil)); end

  def gem?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  def assignment_method_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  def dependency_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequireMFA
  def metadata(param0=T.unsafe(nil)); end

  def on_block(node); end

  def rubygems_mfa_required(param0); end

  def true_string?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def defined_ruby_version(param0=T.unsafe(nil)); end

  def on_send(node); end

  def required_ruby_version?(param0); end
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def on_const(node); end

  def ruby_version?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::GemspecHelp
  def gem_specification(param0); end

  def gem_specification?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Generator
  def initialize(name, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added: T.unsafe(nil)); end

  def inject(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignmentStyles::KeywordSplatAlignment
  def deltas(first_pair, current_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  def deltas_for_first_pair(first_pair, node); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashShorthandSyntax
  def on_hash_for_mixed_shorthand(hash_node); end

  def on_pair(node); end
  DO_NOT_MIX_EXPLICIT_VALUE_MSG = ::T.let(nil, ::T.untyped)
  DO_NOT_MIX_MSG_PREFIX = ::T.let(nil, ::T.untyped)
  DO_NOT_MIX_OMIT_VALUE_MSG = ::T.let(nil, ::T.untyped)
  EXPLICIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
  OMIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashShorthandSyntax::DefNode
  def first_argument(); end

  def last_argument(); end

  def node(); end

  def node=(_); end

  def selector(); end
end

class RuboCop::Cop::HashShorthandSyntax::DefNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::HashTransformMethod
  def array_receiver?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def self.[](*arg); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.from_to_h(node, match); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def noop_transformation?(); end

  def transformation_uses_both_args?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end

  def unchanged_body_expr(); end

  def unchanged_body_expr=(_); end

  def use_transformed_argname?(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::IfThenCorrector
  def call(corrector); end

  def initialize(if_node, indentation: T.unsafe(nil)); end
  DEFAULT_INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
end

RuboCop::Cop::IgnoredMethods = RuboCop::Cop::AllowedMethods

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

module RuboCop::Cop::IndexMethod
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::IndexMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::IndexMethod::Autocorrection
  def self.[](*arg); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.from_to_h(node, match); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::IndexMethod::Captures
  def noop_transformation?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end
end

class RuboCop::Cop::IndexMethod::Captures
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
  def on_csend(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
  def on_array(node); end
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
  def block_end_align_target?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
  def on_case(case_node); end

  def on_case_match(case_match_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
  def on_class(class_node); end

  def on_sclass(class_node); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DotPosition
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::ElseAlignment
  def on_case(node); end

  def on_case_match(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_DIRECTIVE_COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  def on_case(node); end

  def on_if(node); end

  def on_rescue(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  def autocorrect(corrector, prev_def, node, count); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  def on_block(node); end

  def on_numblock(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  def constant_definition?(param0=T.unsafe(nil)); end

  def empty_line_required?(param0=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndAlignment
  def on_case(node); end

  def on_case_match(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndOfLine
  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  def eligible_method_call?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offenses_by(); end

  def offenses_by=(offenses_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  SEPARATOR_ALIGNMENT_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
  def on_heredoc(node); end
  TYPE_MSG = ::T.let(nil, ::T.untyped)
  WIDTH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
  def access_modifier?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_case(case_node); end

  def on_case_match(case_match); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineContinuationLeadingSpace
  def on_dstr(node); end
end

class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation
  def autocorrect(corrector, node); end

  def on_dstr(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
  PARENT_TYPES_FOR_INDENTED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
  def max=(value); end

  def on_array(node); end

  def on_block(node); end

  def on_def(node); end

  def on_hash(node); end

  def on_numblock(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  def on_block(node); end

  def on_numblock(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::ParameterAlignment
  def on_def(node); end

  def on_defs(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RedundantLineBreak
  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  def on_ensure(node); end

  def on_resbody(node); end
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SingleLineBlockChain
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterComma
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_in_pattern(node); end

  def on_kwbegin(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_pattern(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  def on_block(node); end

  def on_numblock(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBrackets
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  def on_send(node); end
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  def on_block(node); end

  def on_numblock(node); end
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  def on_send(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  def on_interpolation(begin_node); end
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Legacy::CorrectionsProxy
  def <<(callable); end

  def concat(corrections); end

  def corrector(); end

  def empty?(); end

  def initialize(corrector); end
end

class RuboCop::Cop::LineBreakCorrector
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

class RuboCop::Cop::Lint::AmbiguousAssignment
  def on_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MISTAKES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence
  def on_and(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PRECEDENCE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRange
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  def big_decimal_new(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  def on_and(node); end

  def on_or(node); end

  def on_send(node); end
  ALLOWED_MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(param0=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  def constant_assigned_in_block?(param0=T.unsafe(nil)); end

  def module_defined_in_block?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantOverwrittenInRescue
  def on_resbody(node); end

  def overwritten_constant(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
  def on_const(node); end

  def unqualified_const?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
  def on_send(node); end
  BLOCK_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def deprecated_class_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  DIR_ENV_FILE_CONSTANTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedConstants
  def on_const(node); end
  DO_NOT_USE_MSG = ::T.let(nil, ::T.untyped)
  SUGGEST_GOOD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  def algorithm_const(param0=T.unsafe(nil)); end

  def digest_const?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NO_ARG_ALGORITHM = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateBranch
  def on_branching_statement(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_if(node); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMatchPattern
  def on_case_match(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(param0=T.unsafe(nil)); end

  def method_alias?(param0=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(param0=T.unsafe(nil)); end
  DEF_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  def each_repeated_character_class_element_loc(node); end

  def on_regexp(node); end
  MSG_REPEATED_ELEMENT = ::T.let(nil, ::T.untyped)
  OCTAL_DIGITS_AFTER_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyBlock
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyClass
  def on_class(node); end

  def on_sclass(node); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  METACLASS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInPattern
  def on_case_match(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  def erb_new_with_non_keyword_arguments(param0=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
  def on_send(node); end
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(param0=T.unsafe(nil)); end

  def on_send(node); end
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  def id_as_hash_key?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler
  def io_select(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(param0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  def class_new_call?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ItWithoutArgumentsInBlock
  def deprecated_it_method?(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock
  def lambda_with_symbol_proc?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
  def message(node); end

  def on_case(case_node); end

  def on_case_match(case_match_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAssignmentInCondition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  def on_interpolation(begin_node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
  def class_new_block(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedCaseRange
  def each_unsafe_regexp_range(node); end

  def on_erange(node); end

  def on_irange(node); end

  def on_regexp(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RANGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  def on_regexp(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  def multiple_compare?(param0=T.unsafe(nil)); end

  def on_send(node); end
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SET_OPERATION_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def eval_call?(param0=T.unsafe(nil)); end

  def exec_call?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_block_body_of_reduce(param0=T.unsafe(nil)); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
  def on_lvasgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonAtomicFileOperation
  def explicit_not_force?(param0); end

  def force?(param0); end

  def on_send(node); end

  def receiver_and_method_name(param0=T.unsafe(nil)); end

  def send_exist_node(param0); end
  MAKE_FORCE_METHODS = ::T.let(nil, ::T.untyped)
  MAKE_METHODS = ::T.let(nil, ::T.untyped)
  MSG_CHANGE_FORCE_METHOD = ::T.let(nil, ::T.untyped)
  MSG_REMOVE_FILE_EXIST_CHECK = ::T.let(nil, ::T.untyped)
  RECURSIVE_REMOVE_METHODS = ::T.let(nil, ::T.untyped)
  REMOVE_FORCE_METHODS = ::T.let(nil, ::T.untyped)
  REMOVE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def loop_variable(param0=T.unsafe(nil)); end

  def method_require?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_numblock(node); end

  def unsorted_dir_block?(param0=T.unsafe(nil)); end

  def unsorted_dir_each?(param0=T.unsafe(nil)); end

  def unsorted_dir_each_pass?(param0=T.unsafe(nil)); end

  def unsorted_dir_glob_pass?(param0=T.unsafe(nil)); end

  def var_is_required?(param0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  def on_csend(node); end

  def on_send(node); end

  def to_method(param0=T.unsafe(nil)); end

  def to_method_symbol(param0=T.unsafe(nil)); end
  CONVERSION_METHODS = ::T.let(nil, ::T.untyped)
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberedParameterAssignment
  def on_lvasgn(node); end
  LVAR_MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_RANGE = ::T.let(nil, ::T.untyped)
  NUM_PARAM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrAssignmentToConstant
  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  def after_send(node); end

  def on_in_pattern(node); end

  def on_match_with_lvasgn(node); end

  def on_nth_ref(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  def exception?(param0=T.unsafe(nil)); end

  def exception_new_with_message?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  def initialize(config=T.unsafe(nil), options=T.unsafe(nil), offenses=T.unsafe(nil)); end

  def offenses_to_check(); end

  def offenses_to_check=(offenses_to_check); end
  COP_NAME = ::T.let(nil, ::T.untyped)
  DEPARTMENT_MARKER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantDirGlobSort
  def on_send(node); end
  GLOB_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRegexpQuantifiers
  def on_regexp(node); end
  MSG_REDUNDANT_QUANTIFIER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  def on_send(node); end

  def pp_const?(param0=T.unsafe(nil)); end

  def redundant_require_statement?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PRETTY_PRINT_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  RUBY_22_LOADED_FEATURES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  def conversion_with_default?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_or(node); end

  def respond_to_nil_specific_method?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_LITERAL = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(param0=T.unsafe(nil)); end

  def literal_expansion(param0=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  def on_interpolation(begin_node); end

  def on_send(node); end

  def to_s_without_args?(param0=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
  def on_block(node); end

  def on_numblock(node); end

  def redundant_with_index?(param0=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
  def on_block(node); end

  def on_numblock(node); end

  def redundant_with_object?(param0=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RefinementImportMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRangeParentheses
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRelativeSelfPath
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
  def autocorrect(corrector, node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  def bad_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PLUS_MINUS_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  def check(node); end

  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_csend(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  def on_send(node); end

  def send_with_mixin_argument?(param0=T.unsafe(nil)); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def uses_var?(param0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def find_conditional_node_from_ascendant(node); end

  def node_or_its_ascendant_conditional?(node); end

  def ractor_block?(param0=T.unsafe(nil)); end

  def same_conditions_node_different_branch?(variable, outer_local_variable); end

  def variable_node(variable); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
  def on_send(node); end

  def struct_new(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SymbolConversion
  def on_hash(node); end

  def on_send(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_CONSISTENCY = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToEnumArguments
  def enum_conversion_call?(param0=T.unsafe(nil)); end

  def method_name?(param0=T.unsafe(nil), param1); end

  def on_send(node); end

  def passing_keyword_arg?(param0=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TripleQuotes
  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
  def fixnum_or_bignum_const(param0=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
  def accumulator_index?(param0=T.unsafe(nil), param1); end

  def element_modified?(param0, param1); end

  def expression_values(param0); end

  def lvar_used?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_numblock(node); end

  def reduce_with_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
  def break_command?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_for(node); end

  def on_numblock(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  CONTINUE_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  def not_implemented?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(param0=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(param0=T.unsafe(nil)); end

  def dynamic_method_definition?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_sclass(node); end

  def static_method_definition?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(corrector, assignment); end

  def chained_assignment?(node); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def offense_range(assignment); end

  def operator_assignment_message(scope, assignment); end

  def remove_exception_assignment_part(corrector, node); end

  def remove_local_variable_assignment_part(corrector, node); end

  def remove_trailing_character_from_operator(corrector, node); end

  def rename_variable_with_underscore(corrector, node); end

  def replace_named_capture_group_with_non_capturing_group(corrector, node, variable_name); end

  def return_value_node_of_scope(scope); end

  def sequential_assignment?(node); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRescue
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRuby2Keywords
  def method_definition(param0=T.unsafe(nil), param1); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(param0=T.unsafe(nil)); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessTimes
  def block_arg(param0=T.unsafe(nil)); end

  def block_reassigns_arg?(param0, param1); end

  def on_send(node); end

  def times_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  CONST_MSG = ::T.let(nil, ::T.untyped)
  EXPRESSION_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  METHODS_REPLACEABLE_BY_EACH = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS_WITH_BANG_VERSION = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  def define_method?(param0=T.unsafe(nil)); end

  def max=(value); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_numblock(node); end
end

class RuboCop::Cop::Metrics::AbcSize
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
  def on_block(node); end

  def on_numblock(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
  def max=(value); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ClassLength
  def on_casgn(node); end

  def on_class(node); end

  def on_sclass(node); end
end

class RuboCop::Cop::Metrics::CollectionLiteralLength
  def on_array(node); end

  def on_hash(node); end

  def on_index(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_numblock(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ModuleLength
  def module_definition?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ParameterLists
  def argument_to_lambda_or_proc?(param0=T.unsafe(nil)); end

  def max=(value); end

  def max_optional_parameters=(value); end

  def on_args(node); end

  def on_def(node); end

  def on_defs(node); end

  def struct_new_or_data_define_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPTIONAL_PARAMETERS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  def calculate(); end

  def else_branch?(node); end

  def evaluate_condition_node(node); end
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node, discount_repeated_attributes: T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  def calculate(); end

  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  def block_method_name(node); end

  def iterating_block?(node); end

  def iterating_method?(name); end
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  def attribute_call?(param0=T.unsafe(nil)); end

  def calculate_node(node); end

  def discount_repeated_attributes?(); end

  def evaluate_branch_nodes(node); end

  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  def root_node?(param0=T.unsafe(nil)); end
  VAR_SETTER_TO_GETTER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def discount_for_repeated_csend?(csend_node); end

  def reset_on_lvasgn(node); end

  def reset_repeated_csend(); end
end

class RuboCop::Cop::Migration::DepartmentName
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MigrationsHelper
  def in_migration?(node); end

  def migration_class?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_csend(node); end

  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  def call(); end

  def initialize(corrector, node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  def self.correct(corrector, node, processed_source); end
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(param0=T.unsafe(nil)); end
  EXCLUDED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockForwarding
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockParameterName
  def on_block(node); end
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(param0=T.unsafe(nil)); end

  def literal_receiver?(param0=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
  def struct_definition(param0=T.unsafe(nil)); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::InclusiveLanguage
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_FILE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation
  def position(); end

  def position=(_); end

  def word(); end

  def word=(_); end
end

class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  def defined_memoized?(param0=T.unsafe(nil), param1); end

  def method_definition?(param0=T.unsafe(nil)); end

  def on_defined?(node); end

  def on_or_asgn(node); end
  DYNAMIC_DEFINE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def str_name(param0=T.unsafe(nil)); end

  def sym_name(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodParameterName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(param0=T.unsafe(nil)); end

  def single_negative?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def corrector(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil), corrector=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::RangeHelp
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

class RuboCop::Cop::ParenthesesCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(corrector, node); end
end

class RuboCop::Cop::PercentLiteralCorrector
  def config(); end

  def correct(corrector, node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(corrector, token); end

  def self.remove_space(corrector, space_before); end

  def self.swap_comma(corrector, range); end
end

class RuboCop::Cop::Rails::ActionControllerFlashBeforeRender
  def action_controller?(param0); end

  def flash_assignment?(param0); end

  def on_send(flash_node); end

  def render?(param0); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActionControllerTestCase
  def action_controller_test_case?(param0=T.unsafe(nil)); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActionFilter
  def on_block(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActionOrder
  def action_declarations(param0, param1); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveRecordAliases
  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveRecordCallbacksOrder
  def on_class(class_node); end
  CALLBACKS_IN_ORDER = ::T.let(nil, ::T.untyped)
  CALLBACKS_ORDER_MAP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveRecordOverride
  def on_def(node); end
end

class RuboCop::Cop::Rails::ActiveSupportAliases
  def append(param0=T.unsafe(nil)); end

  def ends_with?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def prepend(param0=T.unsafe(nil)); end

  def starts_with?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveSupportOnLoad
  def hook_for_const(const_name); end

  def on_send(node); end
  LOAD_HOOKS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RAILS_5_2_LOAD_HOOKS = ::T.let(nil, ::T.untyped)
  RAILS_7_1_LOAD_HOOKS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::AddColumnIndex
  def add_column_with_index(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::AfterCommitOverride
  def on_class(class_node); end
  AFTER_COMMIT_CALLBACKS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Rails::AllowedReceivers
  def allowed_receiver?(receiver); end

  def allowed_receivers(); end

  def receiver_name(receiver); end
end

class RuboCop::Cop::Rails::ApplicationController
  def class_definition(param0=T.unsafe(nil)); end

  def class_new_definition(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ApplicationJob
  def autocorrect(node); end

  def class_definition(param0=T.unsafe(nil)); end

  def class_new_definition(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ApplicationMailer
  def class_definition(param0=T.unsafe(nil)); end

  def class_new_definition(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ApplicationRecord
  def class_definition(param0=T.unsafe(nil)); end

  def class_new_definition(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ArelStar
  def on_send(node); end

  def star_bracket?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::AssertNot
  def offensive?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::AttributeDefaultBlockValue
  def attribute(param0=T.unsafe(nil)); end

  def default_attribute(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TYPE_OFFENDERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::BelongsTo
  def match_belongs_to_with_options(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Blank
  def defining_blank?(param0=T.unsafe(nil)); end

  def nil_or_empty?(param0=T.unsafe(nil)); end

  def not_present?(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def unless_present?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::BulkChangeTable
  def on_def(node); end

  def on_send(node); end
end

class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
  def flush(); end

  def offensive_nodes(); end

  def process(new_node); end
end

class RuboCop::Cop::Rails::CompactBlank
  def on_send(node); end

  def reject_with_block?(param0=T.unsafe(nil)); end

  def reject_with_block_pass?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ContentTag
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::CreateTableWithTimestamps
  def create_table_with_timestamps_proc?(param0=T.unsafe(nil)); end

  def created_at_or_updated_at_included?(param0); end

  def on_send(node); end

  def timestamps_included?(param0); end

  def use_id_false_option?(param0); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DangerousColumnNames
  def on_send(node); end
  COLUMN_TYPE_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  DANGEROUS_COLUMN_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Date
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DefaultScope
  def class_method_definition?(param0=T.unsafe(nil)); end

  def eigenclass_method_definition?(param0=T.unsafe(nil)); end

  def method_call?(param0=T.unsafe(nil)); end

  def on_defs(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Delegate
  def delegate?(param0=T.unsafe(nil)); end

  def on_def(node); end
end

class RuboCop::Cop::Rails::DelegateAllowBlank
  def allow_blank_option(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DeprecatedActiveModelErrorsMethods
  def any_manipulation?(param0=T.unsafe(nil)); end

  def errors_deprecated?(param0=T.unsafe(nil)); end

  def messages_details_assignment?(param0=T.unsafe(nil)); end

  def messages_details_manipulation?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def receiver_matcher_inside_model(param0=T.unsafe(nil)); end

  def receiver_matcher_outside_model(param0=T.unsafe(nil)); end

  def root_assignment?(param0=T.unsafe(nil)); end

  def root_manipulation?(param0=T.unsafe(nil)); end
  AUTOCORRECTABLE_METHODS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_METHODS = ::T.let(nil, ::T.untyped)
  MANIPULATIVE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DotSeparatedKeys
  def on_send(node); end

  def translate_with_scope?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  TRANSLATE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DuplicateAssociation
  def association(param0=T.unsafe(nil)); end

  def class_name(param0=T.unsafe(nil)); end

  def on_class(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_CLASS_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DuplicateScope
  def on_class(class_node); end

  def scope(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DurationArithmetic
  def duration?(param0=T.unsafe(nil)); end

  def duration_arithmetic_argument?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def time_current?(param0=T.unsafe(nil)); end
  DURATIONS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DynamicFindBy
  def on_csend(node); end

  def on_send(node); end
  IGNORED_ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EagerEvaluationLogMessage
  def interpolated_string_passed_to_debug(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnumHash
  def array_pair?(param0=T.unsafe(nil)); end

  def enum?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnumUniqueness
  def enum?(param0=T.unsafe(nil)); end

  def enum_values(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnvLocal
  def on_or(node); end

  def rails_env_local_candidate?(param0=T.unsafe(nil)); end
  LOCAL_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnvironmentComparison
  def comparing_str_env_with_rails_env_on_lhs?(param0=T.unsafe(nil)); end

  def comparing_str_env_with_rails_env_on_rhs?(param0=T.unsafe(nil)); end

  def comparing_sym_env_with_rails_env_on_lhs?(param0=T.unsafe(nil)); end

  def comparing_sym_env_with_rails_env_on_rhs?(param0=T.unsafe(nil)); end

  def content(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnvironmentVariableAccess
  def env_read?(param0); end

  def env_write?(param0); end

  def on_const(node); end
  READ_MSG = ::T.let(nil, ::T.untyped)
  WRITE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Exit
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ExpandedDateRange
  def on_irange(node); end
  MAPPED_DATE_RANGE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FilePath
  def file_join_nodes?(param0=T.unsafe(nil)); end

  def on_dstr(node); end

  def on_send(node); end

  def rails_root_join_nodes?(param0=T.unsafe(nil)); end

  def rails_root_nodes?(param0); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindBy
  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindById
  def find_by?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def where_take?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindEach
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FreezeTime
  def on_send(node); end

  def time_now?(param0=T.unsafe(nil)); end

  def zoned_time_now?(param0=T.unsafe(nil)); end
  CONVERT_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NOW_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HasAndBelongsToMany
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HasManyOrHasOneDependent
  def active_resource_class?(param0); end

  def association_extension_block?(param0=T.unsafe(nil)); end

  def association_with_options?(param0=T.unsafe(nil)); end

  def association_without_options?(param0=T.unsafe(nil)); end

  def dependent_option?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def present_option?(param0=T.unsafe(nil)); end

  def readonly?(param0=T.unsafe(nil)); end

  def with_options_block(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HelperInstanceVariable
  def form_builder_class?(param0=T.unsafe(nil)); end

  def on_ivar(node); end

  def on_ivasgn(node); end
end

class RuboCop::Cop::Rails::HttpPositionalArguments
  def http_request?(param0=T.unsafe(nil)); end

  def include_rack_test_methods?(param0=T.unsafe(nil)); end

  def kwsplat_hash?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ROUTING_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpStatus
  def http_status(param0=T.unsafe(nil)); end

  def on_send(node); end

  def status_code(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
  def initialize(node); end

  def message(); end

  def node(); end

  def offensive?(); end

  def preferred_style(); end
end

class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
  def initialize(node); end

  def message(); end

  def node(); end

  def offensive?(); end

  def preferred_style(); end
end

class RuboCop::Cop::Rails::I18nLazyLookup
  def on_send(node); end

  def translate_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::I18nLocaleAssignment
  def i18n_locale_assignment?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::I18nLocaleTexts
  def flash_assignment?(param0=T.unsafe(nil)); end

  def mail_subject(param0); end

  def on_send(node); end

  def redirect_to_flash(param0); end

  def validation_message(param0); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::IgnoredColumnsAssignment
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption
  def filter_options(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::IndexBy
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::IndexWith
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::Inquiry
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::InverseOf
  def as_option?(param0=T.unsafe(nil)); end

  def association_recv_arguments(param0=T.unsafe(nil)); end

  def conditions_option?(param0=T.unsafe(nil)); end

  def foreign_key_option?(param0=T.unsafe(nil)); end

  def inverse_of_nil_option?(param0=T.unsafe(nil)); end

  def inverse_of_option?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def options_contain_inverse_of?(options); end

  def options_from_argument(param0=T.unsafe(nil)); end

  def options_ignoring_inverse_of?(options); end

  def options_requiring_inverse_of?(options); end

  def polymorphic_option?(param0=T.unsafe(nil)); end

  def same_context_in_with_options?(arg, recv); end

  def scope?(arguments); end

  def through_option?(param0=T.unsafe(nil)); end

  def with_options_arguments(recv, node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::LexicallyScopedActionFilter
  def on_send(node); end

  def only_or_except_filter_methods(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::LinkToBlank
  def blank_target?(param0=T.unsafe(nil)); end

  def includes_noopener?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def rel_node?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::MailerName
  def class_definition?(param0=T.unsafe(nil)); end

  def class_new_definition?(param0=T.unsafe(nil)); end

  def mailer_base_class?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::MatchRoute
  def match_method_call?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def routes_draw?(param0=T.unsafe(nil)); end
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::MigrationClassName
  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::NegateInclude
  def negate_include_call?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::NotNullColumn
  def add_not_null_column?(param0=T.unsafe(nil)); end

  def add_not_null_reference?(param0=T.unsafe(nil)); end

  def default_option?(param0=T.unsafe(nil)); end

  def null_false?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::OrderById
  def on_send(node); end

  def order_by_id?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Output
  def io_output?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def output?(param0=T.unsafe(nil)); end
  ALLOWED_TYPES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::OutputSafety
  def i18n_method?(param0); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Pick
  def on_csend(node); end

  def on_send(node); end

  def pick_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Pluck
  def on_block(node); end

  def on_numblock(node); end

  def pluck_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::PluckId
  def on_csend(node); end

  def on_send(node); end

  def pluck_id_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::PluckInWhere
  def on_csend(node); end

  def on_send(node); end
  MSG_IDS = ::T.let(nil, ::T.untyped)
  MSG_SELECT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::PluralizationGrammar
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Presence
  def on_if(node); end

  def redundant_negative_receiver_and_other(param0=T.unsafe(nil)); end

  def redundant_receiver_and_other(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::Present
  def autocorrect(corrector, node); end

  def exists_and_not_empty?(param0=T.unsafe(nil)); end

  def not_blank?(param0=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def unless_blank?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RakeEnvironment
  def on_block(node); end

  def task_definition?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ReadWriteAttribute
  def on_send(node); end

  def read_write_attribute?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantActiveRecordAllMethod
  def followed_by_query_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  POSSIBLE_ENUMERABLE_BLOCK_METHODS = ::T.let(nil, ::T.untyped)
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SENSITIVE_METHODS_ON_ASSOCIATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantAllowNil
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantForeignKey
  def association_with_foreign_key(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantPresenceValidationOnBelongsTo
  def any_belongs_to?(param0=T.unsafe(nil), association:); end

  def belongs_to?(param0=T.unsafe(nil), key:, fk:); end

  def belongs_to_with_a_matching_fk?(param0=T.unsafe(nil), param1); end

  def belongs_to_without_fk?(param0=T.unsafe(nil), param1); end

  def on_send(node); end

  def optional?(param0=T.unsafe(nil)); end

  def optional_option?(param0=T.unsafe(nil)); end

  def presence_validation?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions
  def all_block_nodes_in(param0); end

  def all_send_nodes_in(param0); end

  def on_block(node); end

  def on_numblock(node); end
end

class RuboCop::Cop::Rails::RedundantTravelBack
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReflectionClassName
  def association_with_reflection(param0=T.unsafe(nil)); end

  def const_or_string(param0=T.unsafe(nil)); end

  def on_send(node); end

  def reflection_class_name(param0=T.unsafe(nil)); end
  ALLOWED_REFLECTION_CLASS_TYPES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RefuteMethods
  def offensive?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RelativeDateConstant
  def on_casgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end

  def relative_date(param0=T.unsafe(nil)); end

  def relative_date_or_assignment(param0=T.unsafe(nil)); end
  RELATIVE_DATE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RenderInline
  def on_send(node); end

  def render_with_inline_option?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RenderPlainText
  def on_send(node); end

  def render_plain_text?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RequestReferer
  def on_send(node); end

  def referer?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RequireDependency
  def on_send(node); end

  def require_dependency_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ResponseParsedBody
  def json_parse_response_body?(param0=T.unsafe(nil)); end

  def nokogiri_html_parse_response_body(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReversibleMigration
  def change_table_call(param0=T.unsafe(nil)); end

  def drop_table_call(param0=T.unsafe(nil)); end

  def irreversible_schema_statement_call(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_numblock(node); end

  def on_send(node); end

  def remove_column_call(param0=T.unsafe(nil)); end

  def remove_columns_call(param0=T.unsafe(nil)); end

  def remove_foreign_key_call(param0=T.unsafe(nil)); end

  def remove_index_call(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ReversibleMigrationMethodDefinition
  def change_method?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def up_and_down_methods?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RootJoinChain
  def join?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def rails_root?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RootPathnameMethods
  def dir_glob?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_method_for_ruby_2_4_or_lower(param0=T.unsafe(nil)); end

  def pathname_method_for_ruby_2_5_or_higher(param0=T.unsafe(nil)); end

  def rails_root?(param0=T.unsafe(nil)); end

  def rails_root_pathname?(param0=T.unsafe(nil)); end
  DIR_GLOB_METHODS = ::T.let(nil, ::T.untyped)
  DIR_METHODS = ::T.let(nil, ::T.untyped)
  DIR_NON_GLOB_METHODS = ::T.let(nil, ::T.untyped)
  FILE_METHODS = ::T.let(nil, ::T.untyped)
  FILE_TEST_METHODS = ::T.let(nil, ::T.untyped)
  FILE_UTILS_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RootPublicPath
  def on_send(node); end

  def rails_root_public(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SafeNavigation
  def on_send(node); end

  def try_call(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SafeNavigationWithBlank
  def on_if(node); end

  def safe_navigation_blank_in_conditional?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::SaveBang
  def after_leaving_scope(scope, _variable_table); end

  def check_assignment(assignment); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SchemaComment
  def add_column?(param0=T.unsafe(nil)); end

  def add_column_with_comment?(param0=T.unsafe(nil)); end

  def comment_present?(param0=T.unsafe(nil)); end

  def create_table?(param0=T.unsafe(nil)); end

  def create_table_with_comment?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def t_column?(param0=T.unsafe(nil)); end

  def t_column_with_comment?(param0=T.unsafe(nil)); end
  COLUMN_MSG = ::T.let(nil, ::T.untyped)
  CREATE_TABLE_COLUMN_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TABLE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ScopeArgs
  def on_send(node); end

  def scope?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SelectMap
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ShortI18n
  def long_i18n?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SkipsModelValidations
  def good_insert?(param0=T.unsafe(nil)); end

  def good_touch?(param0=T.unsafe(nil)); end

  def initialize(*arg); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Rails::SquishedSQLHeredocs
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SQL = ::T.let(nil, ::T.untyped)
  SQL_IDENTIFIER_MARKERS = ::T.let(nil, ::T.untyped)
  SQUISH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::StripHeredoc
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::TableNameAssignment
  def base_class?(param0=T.unsafe(nil)); end

  def on_class(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ThreeStateBooleanColumn
  def change_column_null?(param0, param1, param2); end

  def on_send(node); end

  def required_options?(param0=T.unsafe(nil)); end

  def three_state_boolean?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::TimeZone
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG_STRING_TO_TIME = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TIMEZONE_SPECIFIER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::TimeZoneAssignment
  def on_send(node); end

  def time_zone_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ToFormattedS
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ToSWithArgument
  def on_csend(node); end

  def on_send(node); end
  EXTENDED_FORMAT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::TopLevelHashWithIndifferentAccess
  def on_const(node); end

  def top_level_hash_with_indifferent_access?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::TransactionExitStatement
  def exit_statements(param0); end

  def on_send(node); end

  def rescue_body_return_node?(param0=T.unsafe(nil)); end
  BUILT_IN_TRANSACTION_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UniqBeforePluck
  def aggressive_node_match(param0=T.unsafe(nil)); end

  def conservative_node_match(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UniqueValidationWithoutIndex
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UnknownEnv
  def on_send(node); end

  def rails_env?(param0=T.unsafe(nil)); end

  def unknown_environment_equal?(param0=T.unsafe(nil)); end

  def unknown_environment_predicate?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::UnusedIgnoredColumns
  def appended_ignored_columns(param0=T.unsafe(nil)); end

  def column_name(param0=T.unsafe(nil)); end

  def ignored_columns(param0=T.unsafe(nil)); end

  def on_op_asgn(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UnusedRenderContent
  def non_content_status?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def unused_render_content?(param0=T.unsafe(nil)); end
  BODY_OPTIONS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NON_CONTENT_STATUSES = ::T.let(nil, ::T.untyped)
  NON_CONTENT_STATUS_CODES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Validation
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::WhereEquals
  def on_csend(node); end

  def on_send(node); end

  def where_method_call?(param0=T.unsafe(nil)); end
  EQ_ANONYMOUS_RE = ::T.let(nil, ::T.untyped)
  EQ_NAMED_RE = ::T.let(nil, ::T.untyped)
  IN_ANONYMOUS_RE = ::T.let(nil, ::T.untyped)
  IN_NAMED_RE = ::T.let(nil, ::T.untyped)
  IS_NULL_RE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::WhereExists
  def exists_with_args?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def where_exists_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::WhereMissing
  def missing_relationship(param0); end

  def on_send(node); end

  def where_node_and_argument(param0); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::WhereNot
  def on_csend(node); end

  def on_send(node); end

  def where_method_call?(param0=T.unsafe(nil)); end
  IS_NOT_NULL_RE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NOT_EQ_ANONYMOUS_RE = ::T.let(nil, ::T.untyped)
  NOT_EQ_NAMED_RE = ::T.let(nil, ::T.untyped)
  NOT_IN_ANONYMOUS_RE = ::T.let(nil, ::T.untyped)
  NOT_IN_NAMED_RE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::WhereNotWithMultipleConditions
  def on_send(node); end

  def where_not_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Registry
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def cops_for_department(department); end

  def department?(name); end

  def department_missing?(badge, name); end

  def departments(); end

  def disabled(config); end

  def dismiss(cop); end

  def each(&block); end

  def enabled(config); end

  def enabled?(cop, config); end

  def enabled_pending_cop?(cop_cfg, config); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def find_cops_by_directive(directive); end

  def initialize(cops=T.unsafe(nil), options=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def names_for_department(department); end

  def options(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end

  def qualify_badge(badge); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
  def self.all(); end

  def self.global(); end

  def self.qualified_cop?(name); end

  def self.qualified_cop_name(name, origin); end

  def self.reset!(); end

  def self.with_temporary_global(temp_global=T.unsafe(nil)); end
end

module RuboCop::Cop::RequireLibrary
  def ensure_required(corrector, node, library_name); end

  def on_send(node); end

  def remove_subsequent_requires(corrector, node, library_name); end

  def require_any_library?(param0=T.unsafe(nil)); end

  def require_library_name?(param0=T.unsafe(nil), param1); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RequireLibraryCorrector
  def self.correct(corrector, node, library_name); end

  def self.require_statement(library_name); end
end

module RuboCop::Cop::RescueNode
  def modifier_locations(); end
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(param0=T.unsafe(nil)); end

  def safe_assignment?(param0=T.unsafe(nil)); end

  def setter_method?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::CompoundHash
  def bad_hash_combinator?(param0=T.unsafe(nil)); end

  def contained_in_hash_method?(node, &block); end

  def dynamic_hash_method_definition?(param0=T.unsafe(nil)); end

  def hash_method_definition?(param0=T.unsafe(nil)); end

  def monuple_hash?(param0=T.unsafe(nil)); end

  def on_op_asgn(node); end

  def on_send(node); end

  def outer_bad_hash_combinator?(node); end

  def redundant_hash?(param0=T.unsafe(nil)); end

  def static_hash_method_definition?(param0=T.unsafe(nil)); end
  COMBINATOR_IN_HASH_MSG = ::T.let(nil, ::T.untyped)
  MONUPLE_HASH_MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_HASH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
  def eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::IoMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  def json_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  def on_send(node); end

  def yaml_load(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def on_new_investigation(); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
  def on_new_investigation(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::SpaceCorrector
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

class RuboCop::Cop::StringLiteralCorrector
  def self.correct(corrector, node, style); end
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  def access_modifier_with_symbol?(param0=T.unsafe(nil)); end

  def on_send(node); end
  ALLOWED_NODE_TYPES = ::T.let(nil, ::T.untyped)
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding
  def on_def(node); end

  def on_defs(node); end
  ADDITIONAL_ARG_TYPES = ::T.let(nil, ::T.untyped)
  ARGS_MSG = ::T.let(nil, ::T.untyped)
  BLOCK_MSG = ::T.let(nil, ::T.untyped)
  FORWARDING_LVAR_TYPES = ::T.let(nil, ::T.untyped)
  FORWARDING_MSG = ::T.let(nil, ::T.untyped)
  KWARGS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding::SendNodeClassifier
  def classification(); end

  def extract_forwarded_kwrest_arg(param0=T.unsafe(nil), param1); end

  def forwarded_block_arg(); end

  def forwarded_block_arg?(param0=T.unsafe(nil), param1); end

  def forwarded_kwrest_arg(); end

  def forwarded_rest_arg(); end

  def forwarded_rest_arg?(param0=T.unsafe(nil), param1); end

  def initialize(def_node, send_node, referenced_lvars, forwardable_args, **config); end
end

class RuboCop::Cop::Style::ArrayCoercion
  def array_splat?(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_if(node); end

  def unless_array?(param0=T.unsafe(nil)); end
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayFirstLast
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayIntersect
  def active_support_bad_intersection_check?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def regular_bad_intersection_check?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRAIGHT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  def join_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  def class_eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def file_open_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  def after_class(class_node); end

  def after_module(class_node); end

  def after_sclass(class_node); end

  def on_class(class_node); end

  def on_module(class_node); end

  def on_sclass(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  def all_bisected?(); end

  def attr_names(); end

  def attrs(); end

  def bisect(*names); end

  def bisected_names(); end

  def bisection(); end

  def initialize(node); end

  def node(); end

  def reader?(); end

  def rest(); end

  def visibility(); end

  def writer?(); end
end

class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  def self.macro?(node); end
end

class RuboCop::Cop::Style::BlockComments
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
  def on_block(node); end

  def on_numblock(node); end

  def on_send(node); end
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def self_class?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
  def autocorrect(corrector, node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  def message(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  def class_comparison_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  CLASS_NAME_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  def on_defs(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
  def on_cvasgn(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionCompact
  def grep_v_with_nil?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def reject_method?(param0=T.unsafe(nil)); end

  def reject_method_with_block_pass?(param0=T.unsafe(nil)); end

  def select_method?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TO_ENUM_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  def on_block(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
  def java_type_node?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
  def on_block(node); end

  def on_for(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG_COLON_STYLE = ::T.let(nil, ::T.untyped)
  MSG_SPACE_STYLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ComparableClamp
  def array_min_max?(param0=T.unsafe(nil)); end

  def if_elsif_else_condition?(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MIN_MAX = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConcatArrayLiterals
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_PERCENT_LITERALS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  def assignment_type?(param0=T.unsafe(nil)); end

  def candidate_condition?(param0=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(param0=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DataInheritance
  def data_define?(param0=T.unsafe(nil)); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
  def date_time?(param0=T.unsafe(nil)); end

  def historic_date?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def to_datetime?(param0=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  def dir_replacement?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DirEmpty
  def offensive?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
  def on_send(node); end
  BLOCK_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
  def constant_definition?(param0=T.unsafe(nil)); end

  def constant_visibility_declaration?(param0=T.unsafe(nil)); end

  def include_statement?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
  def modifier_node?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def each_range(param0=T.unsafe(nil)); end

  def each_range_with_zero_origin?(param0=T.unsafe(nil)); end

  def each_range_without_block_argument?(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
  def each_with_object_block_candidate?(param0=T.unsafe(nil)); end

  def each_with_object_numblock_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_numblock(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
  NOT_SUPPORTED_PARENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyHeredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  def array_node(param0=T.unsafe(nil)); end

  def array_with_block(param0=T.unsafe(nil)); end

  def hash_node(param0=T.unsafe(nil)); end

  def hash_with_block(param0=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(param0=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndlessMethod
  def on_def(node); end
  CORRECTION_STYLES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EnvHome
  def env_home?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
  def line_with_offset?(param0=T.unsafe(nil), param1, param2); end

  def on_send(node); end

  def valid_eval_receiver?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EVAL = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_FILE = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  def even_odd_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExactRegexpMatch
  def exact_regexp_match(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  def file_expand_path(param0=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(param0=T.unsafe(nil)); end

  def pathname_parent_expand_path(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  def on_yield(node); end

  def yielding_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
  def on_float(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FetchEnvVar
  def env_with_bracket?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileEmpty
  def offensive?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileRead
  def block_read?(param0=T.unsafe(nil)); end

  def file_open?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def send_read?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  READ_FILE_START_TO_FINISH_MODES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileWrite
  def block_write?(param0=T.unsafe(nil)); end

  def evidence(node); end

  def file_open?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def send_write?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TRUNCATING_WRITE_MODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
  def any_coerce?(param0=T.unsafe(nil)); end

  def both_coerce?(param0=T.unsafe(nil)); end

  def left_coerce?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(param0=T.unsafe(nil)); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
  def on_block(node); end

  def on_for(node); end

  def on_numblock(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  def formatter(param0=T.unsafe(nil)); end

  def on_send(node); end

  def variable_argument?(param0=T.unsafe(nil)); end
  AUTOCORRECTABLE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatStringToken
  def format_string_in_typical_context?(param0=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  def const_to_gvar_assignment?(param0=T.unsafe(nil), param1); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  def on_hash(node); end
end

class RuboCop::Cop::Style::HashConversion
  def hash_from_array?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG_LITERAL_HASH_ARG = ::T.let(nil, ::T.untyped)
  MSG_LITERAL_MULTI_ARG = ::T.let(nil, ::T.untyped)
  MSG_SPLAT = ::T.let(nil, ::T.untyped)
  MSG_TO_H = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
  def check_unused_block_args(node, key, value); end

  def each_arguments(param0=T.unsafe(nil)); end

  def kv_each(param0=T.unsafe(nil)); end

  def kv_each_with_block_pass(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_numblock(node); end
  ARRAY_CONVERTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  UNUSED_BLOCK_ARG_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashExcept
  def bad_method_with_active_support?(param0=T.unsafe(nil)); end

  def bad_method_with_poro?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
  def hash_like_case?(param0=T.unsafe(nil)); end

  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashTransformKeys
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformValues
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_case_match(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
  def on_if(node); end
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithBooleanLiteralBranches
  def double_negative?(param0=T.unsafe(nil)); end

  def if_with_boolean_literal_branches?(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_ELSIF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
  def on_normal_if_unless(node); end
  MSG_IF_ELSE = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InPatternThen
  def on_in_pattern(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
  def inverse_block?(param0=T.unsafe(nil)); end

  def inverse_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_numblock(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InvertibleUnlessCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  def on_kwoptarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
  def on_block(node); end

  def on_numblock(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MagicCommentFormat
  KEBAB_SEPARATOR = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_VALUE = ::T.let(nil, ::T.untyped)
  SNAKE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MagicCommentFormat::CommentRange
  def comment(); end

  def directives(); end

  def initialize(comment); end

  def loc(*args, **arg, &block); end

  def text(*args, **arg, &block); end

  def values(); end
  DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  VALUE_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapCompactWithConditionalBlock
  def map_and_compact?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapIntoArray
  def after_leaving_scope(scope, _variable_table); end

  def each_block_with_push?(param0=T.unsafe(nil)); end

  def empty_array_asgn?(param0=T.unsafe(nil)); end

  def lvar_ref?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToHash
  def map_to_h(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToSet
  def map_to_set?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  def on_csend(node); end

  def on_send(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  def on_block(node); end

  def on_csend(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
  def min_max_candidate(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMaxComparison
  def on_if(node); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  GRATER_OPERATORS = ::T.let(nil, ::T.untyped)
  LESS_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
  def on_case(node); end

  def on_case_match(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
  def in_top_level_scope?(param0=T.unsafe(nil)); end

  def include_statement(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  def extend_self_node?(param0=T.unsafe(nil)); end

  def module_function_node?(param0=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(param0=T.unsafe(nil)); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineInPatternThen
  def on_in_pattern(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  def message(_node); end

  def on_or_asgn(node); end
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG_IF = ::T.let(nil, ::T.untyped)
  MSG_SINGLE_LINE = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison_lhs?(param0=T.unsafe(nil)); end

  def simple_comparison_rhs?(param0=T.unsafe(nil)); end

  def simple_double_comparison?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
  def on_casgn(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(param0=T.unsafe(nil)); end

  def splat_value(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  def self.magic_comment_in_scope(node); end

  def self.recent_shareable_value?(node); end
end

class RuboCop::Cop::Style::NegatedIf
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  def double_negation?(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NegatedUnless
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedWhile
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NestedFileDirname
  def file_dirname?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
  def on_block(node); end

  def on_for(node); end

  def on_numblock(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  def nil_check?(param0=T.unsafe(nil)); end

  def nil_comparison?(param0=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilLambda
  def nil_return?(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  def nil_check?(param0=T.unsafe(nil)); end

  def not_and_nil_check?(param0=T.unsafe(nil)); end

  def not_equal_to_nil?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(param0=T.unsafe(nil)); end
  MSG_FOR_REDUNDANCY = ::T.let(nil, ::T.untyped)
  MSG_FOR_REPLACEMENT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParameters
  def on_numblock(node); end
  MSG_DISALLOW = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParametersLimit
  def max=(value); end

  def on_numblock(node); end
  DEFAULT_MAX_VALUE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
  def min_digits=(value); end

  def on_float(node); end

  def on_int(node); end
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  def comparison(param0=T.unsafe(nil)); end

  def inverted_comparison(param0=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ObjectThen
  def on_block(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OpenStructUse
  def on_const(node); end

  def uses_open_struct?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OperatorMethodCall
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(param0=T.unsafe(nil)); end

  def unless_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment
  def implicit_self_getter?(param0=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(param0, param1, param2); end

  def tsort_each_child(assignment); end

  def tsort_each_node(*arg, **arg1, &arg2); end

  def uses_var?(param0, param1); end

  def var_name(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, rhs, modifier, config, new_elements); end

  def node(); end

  def rescue_result(); end

  def rhs(); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  def control_op_condition(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentQLiterals
  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
  def on_back_ref(node); end

  def on_gvar(node); end

  def on_nth_ref(node); end
  MESSAGE_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
  def on_block(node); end

  def on_numblock(node); end

  def proc_new?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::QuotedSymbols
  def on_sym(node); end
  MSG_DOUBLE = ::T.let(nil, ::T.untyped)
  MSG_SINGLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  def integer_op_rand?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(param0=T.unsafe(nil)); end

  def rand_op_integer?(param0=T.unsafe(nil)); end

  def random_call(param0=T.unsafe(nil)); end

  def to_int(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArgument
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NO_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArrayConstructor
  def on_send(node); end

  def redundant_array_constructor(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  def on_def(node); end

  def on_defs(node); end

  def redundant_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
  def offensive_kwbegins(param0); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
  def on_if(node); end
  ARGUMENT_WITH_OPERATOR_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  def on_if(node); end

  def redundant_condition?(param0=T.unsafe(nil)); end

  def redundant_condition_inverted?(param0=T.unsafe(nil)); end
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConstantBase
  def on_cbase(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCurrentDirectoryInPath
  def on_send(node); end
  CURRENT_DIRECTORY_PATH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantDoubleSplatHashBraces
  def on_hash(node); end
  MERGE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantEach
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  def compact?(param0=T.unsafe(nil)); end

  def exploded?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  def on_block(node); end

  def rails_cache?(param0=T.unsafe(nil)); end

  def redundant_fetch_block_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFilterChain
  def on_csend(node); end

  def on_send(node); end

  def select_predicate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RAILS_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  def on_send(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_OR_ESCAPED_CHARACTER_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInitialize
  def initialize_forwards?(param0=T.unsafe(nil)); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantLineContinuation
  ALLOWED_STRING_TOKENS = ::T.let(nil, ::T.untyped)
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantParentheses
  def allowed_pin_operator?(param0=T.unsafe(nil)); end

  def arg_in_call_with_block?(param0=T.unsafe(nil)); end

  def first_send_argument?(param0=T.unsafe(nil)); end

  def first_super_argument?(param0=T.unsafe(nil)); end

  def first_yield_argument?(param0=T.unsafe(nil)); end

  def interpolation?(param0=T.unsafe(nil)); end

  def method_node_and_args(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def rescue?(param0=T.unsafe(nil)); end

  def square_brackets?(param0=T.unsafe(nil)); end
  ALLOWED_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpArgument
  def on_csend(node); end

  def on_send(node); end
  DETERMINISTIC_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_SPECIAL_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  def on_regexp(node); end
  MSG_REDUNDANT_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpConstructor
  def on_send(node); end

  def redundant_regexp_constructor(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  def on_regexp(node); end
  ALLOWED_ALWAYS_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  MSG_REDUNDANT_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end

  def on_in_pattern(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end

  def on_until(node); end

  def on_while(node); end
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_send(node); end

  def redundant_nonself_assignment?(param0=T.unsafe(nil), param1, param2); end

  def redundant_self_assignment?(param0=T.unsafe(nil), param1); end
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignmentBranch
  def bad_method?(param0=T.unsafe(nil)); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  def on_csend(node); end

  def on_send(node); end

  def redundant_sort?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  def on_block(node); end

  def on_numblock(node); end

  def redundant_sort_by_block(param0=T.unsafe(nil)); end

  def redundant_sort_by_numblock(param0=T.unsafe(nil)); end
  MSG_BLOCK = ::T.let(nil, ::T.untyped)
  MSG_NUMBLOCK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantStringEscape
  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RequireOrder
  def if_inside_only_require(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
  def on_resbody(node); end

  def rescue_standard_error?(param0=T.unsafe(nil)); end

  def rescue_without_error_class?(param0=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(param0=T.unsafe(nil)); end

  def return_node?(param0=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNilInPredicateMethodDefinition
  def on_def(node); end

  def on_defs(node); end

  def return_nil?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  def modifier_if_safe_navigation_candidate(param0=T.unsafe(nil)); end

  def not_nil_check?(param0=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def ternary_safe_navigation_candidate(param0=T.unsafe(nil)); end
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  def on_csend(node); end

  def on_send(node); end

  def sample_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelectByRegexp
  def calls_lvar?(param0=T.unsafe(nil), param1); end

  def creates_hash?(param0=T.unsafe(nil)); end

  def env_const?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def regexp_match?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_REPLACEMENTS = ::T.let(nil, ::T.untyped)
  REGEXP_METHODS = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  def custom_fail_methods(param0); end

  def kernel_call?(param0=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  def on_send(node); end

  def single_argument_dig?(param0=T.unsafe(nil)); end
  IGNORED_ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineDoEndBlock
  def on_block(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  def on_send(node); end

  def range_from_zero?(param0=T.unsafe(nil)); end

  def range_from_zero_till_minus_one?(param0=T.unsafe(nil)); end

  def range_till_minus_one?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_USELESS_RANGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
  def autocorrect(corrector, node, global_var); end

  def message(global_var); end

  def on_gvar(node); end
  BUILTIN_VARS = ::T.let(nil, ::T.untyped)
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
  STYLE_VARS_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StaticClass
  def on_class(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  def on_send(node); end

  def stderr_puts?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringChars
  def on_csend(node); end

  def on_send(node); end
  BAD_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  def on_send(node); end

  def string_concatenation?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
  def on_pair(node); end

  def receive_environments_method?(param0=T.unsafe(nil)); end

  def string_hash_key?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  def autocorrect(corrector, node); end
end

class RuboCop::Cop::Style::StringMethods
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  def lstrip_rstrip(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
  def on_class(node); end

  def struct_constructor?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SuperWithArgsParentheses
  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SwapValues
  def on_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  DELIMITERS = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
  REDEFINABLE_OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIAL_GVARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def on_numblock(node); end

  def proc_node?(param0=T.unsafe(nil)); end

  def symbol_proc?(param0=T.unsafe(nil)); end

  def symbol_proc_receiver?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  def method_name(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TopLevelMethodDefinition
  def define_method_block?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  def on_class(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
  def looks_like_trivial_writer?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessLogicalOperators
  def and_with_or?(param0=T.unsafe(nil)); end

  def logical_operator?(param0=T.unsafe(nil)); end

  def on_if(node); end

  def or_with_and?(param0=T.unsafe(nil)); end
  FORBID_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
  FORBID_MIXED_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  def on_csend(node); end

  def on_send(node); end

  def unpack_and_first_element?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YAMLFileRead
  def on_send(node); end

  def yaml_file_read?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
  def file_constant_equal_program_name?(param0=T.unsafe(nil)); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaExpression
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def non_polymorphic_collection?(param0=T.unsafe(nil)); end

  def nonzero_length_comparison(param0=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(param0=T.unsafe(nil)); end

  def zero_length_comparison(param0=T.unsafe(nil)); end

  def zero_length_predicate(param0=T.unsafe(nil)); end

  def zero_length_receiver(param0=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SymbolHelp
  def hash_key?(node); end
end

module RuboCop::Cop::TargetRailsVersion
  def minimum_target_rails_version(version); end

  def support_target_rails_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def required_minimum_ruby_version(); end

  def support_target_ruby_version?(version); end
end

class RuboCop::Cop::Team
  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def initialize(cops, config=T.unsafe(nil), options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def investigate(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
end

class RuboCop::Cop::Team
  def self.forces_for(cops); end

  def self.mobilize(cop_classes, config, options=T.unsafe(nil)); end

  def self.mobilize_cops(cop_classes, config, options=T.unsafe(nil)); end

  def self.new(cop_or_classes, config, options=T.unsafe(nil)); end
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingComma
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::UnusedArgCorrector
  def self.correct(corrector, processed_source, node); end

  def self.correct_for_blockarg_type(corrector, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  def self.add_parentheses(node, corrector); end

  def self.any_descendant?(node, *types); end

  def self.args_begin(node); end

  def self.args_end(node); end

  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.comment_lines?(node); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.indent(node, offset: T.unsafe(nil)); end

  def self.interpret_string_escapes(string); end

  def self.line(node_or_range); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.trim_string_interpolation_escape_character(str); end
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end

  def valid?(); end
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def width(); end
end

class RuboCop::Cop::Utils::RegexpRanges
  def compound_token(); end

  def initialize(root); end

  def pairs(); end

  def root(); end
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  REST_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  def exception_assignment?(); end

  def for_assignment?(); end

  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def rest_assignment?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*arg); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.keyword_init?(); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::CaseMatch
  def else_body?(); end

  def in_pattern?(); end

  def target?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  def ensure_body?(); end

  def main_body?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
  def falsey_body?(); end

  def truthy_body?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  def loop_body?(); end
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

class RuboCop::Cop::VariableForce::Reference
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_conditional?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

module RuboCop::Cop::VisibilityHelp
  def visibility_block?(param0=T.unsafe(nil)); end

  def visibility_inline_on_def?(param0=T.unsafe(nil)); end

  def visibility_inline_on_method_name?(param0=T.unsafe(nil), method_name:); end
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::DirectiveComment
  def all_cops?(); end

  def comment(); end

  def cop_names(); end

  def cop_registry(); end

  def cops(); end

  def department_names(); end

  def directive_count(); end

  def disabled?(); end

  def disabled_all?(); end

  def enabled?(); end

  def enabled_all?(); end

  def in_directive_department?(cop); end

  def initialize(comment, cop_registry=T.unsafe(nil)); end

  def line_number(); end

  def match?(cop_names); end

  def match_captures(); end

  def mode(); end

  def overridden_by_department?(cop); end

  def range(); end

  def single_line?(); end
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  DIRECTIVE_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  LINT_DEPARTMENT = ::T.let(nil, ::T.untyped)
  LINT_REDUNDANT_DIRECTIVE_COP = ::T.let(nil, ::T.untyped)
  LINT_SYNTAX_COP = ::T.let(nil, ::T.untyped)
end

class RuboCop::DirectiveComment
  def self.before_comment(line); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

module RuboCop::ExcludeLimit
  def exclude_limit(parameter_name, method_name: T.unsafe(nil)); end
end

module RuboCop::Ext::Comment
  def source(); end

  def source_range(); end
end

module RuboCop::Ext::ProcessedSource
  def comment_config(); end

  def config(); end

  def config=(config); end

  def disabled_line_ranges(); end

  def registry(); end

  def registry=(registry); end
end

module RuboCop::Ext::Range
  def single_line?(); end
end

module RuboCop::Ext::RegexpNode
  def assign_properties(*arg); end

  def each_capture(named: T.unsafe(nil)); end

  def parsed_tree(); end
end

module RuboCop::Ext::RegexpParser::Expression::Base
  def expression(); end

  def loc(); end

  def origin(); end

  def origin=(origin); end
end

module RuboCop::Ext::RegexpParser::Expression::CharacterSet
  def build_location(); end
end

class RuboCop::Ext::RegexpParser::Map
  def begin(); end

  def body(); end

  def end(); end

  def initialize(expression, body:, quantifier: T.unsafe(nil), begin_l: T.unsafe(nil), end_l: T.unsafe(nil)); end

  def quantifier(); end
end

class RuboCop::FeatureLoader
  def initialize(config_directory_path:, feature:); end

  def load(); end
end

class RuboCop::FeatureLoader
  def self.load(config_directory_path:, feature:); end
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end

  def find_last_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end
end

module RuboCop::FileFinder
  def self.root_level(); end

  def self.root_level=(root_level); end
end

class RuboCop::FilePatterns
  def initialize(patterns); end

  def match?(path); end
end

class RuboCop::FilePatterns
  def self.from(patterns); end
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, options); end

  def finished(_inspected_files); end
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::GitHubActionsFormatter
  def finished(_inspected_files); end

  def started(_target_files); end
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  CSS_PATH = ::T.let(nil, ::T.untyped)
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::CSSContext
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlight_source_tag(offense); end

  def highlighted_source_line(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def render_css(); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::FileOffenses
  def offenses(); end

  def offenses=(_); end

  def path(); end

  def path=(_); end
end

class RuboCop::Formatter::HTMLFormatter::FileOffenses
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::Summary
  def inspected_files(); end

  def inspected_files=(_); end

  def offense_count(); end

  def offense_count=(_); end

  def target_files(); end

  def target_files=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Summary
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::JSONFormatter
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JUnitFormatter
  def add_testcase_element_to_testsuite_element(file, target_offenses, cop); end

  def classname_attribute_value(file); end

  def finished(_inspected_files); end

  def offenses_for_cop(all_offenses, cop); end

  def relevant_for_output?(options, target_offenses); end
end

class RuboCop::Formatter::MarkdownFormatter
  def files(); end

  def summary(); end
end

class RuboCop::Formatter::OffenseCountFormatter
  def cop_information(cop_name); end

  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts, offending_files_count); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::PacmanFormatter
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count, correctable_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_autocorrect: T.unsafe(nil)); end

  def summary(); end
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::LSP::Logger
  def self.log(message); end
end

class RuboCop::LSP::Routes
  def for(name); end

  def handle_initialize(request); end

  def handle_initialized(_request); end

  def handle_method_missing(request); end

  def handle_shutdown(request); end

  def handle_unsupported_method(request, method=T.unsafe(nil)); end

  def initialize(server); end
end

class RuboCop::LSP::Runtime
  def format(path, text, command:); end

  def initialize(config_store); end

  def layout_mode=(layout_mode); end

  def lint_mode=(lint_mode); end

  def offenses(path, text); end

  def safe_autocorrect=(safe_autocorrect); end
end

class RuboCop::LSP::Server
  def configure(options); end

  def format(path, text, command:); end

  def initialize(config_store); end

  def offenses(path, text); end

  def start(); end

  def stop(&block); end

  def write(response); end
end

class RuboCop::LSP::Severity
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::LSP::Severity
  def self.find_by(rubocop_severity); end
end

module RuboCop::LSP
  def self.disable(); end

  def self.enable(); end

  def self.enabled?(); end
end

class RuboCop::Lockfile
  def dependencies(); end

  def gem_versions(include_transitive_dependencies: T.unsafe(nil)); end

  def gems(); end

  def includes_gem?(name); end

  def initialize(lockfile_path=T.unsafe(nil)); end
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def shareable_constant_value(); end

  def shareable_constant_value_specified?(); end

  def typed(); end

  def typed_specified?(); end

  def valid?(); end

  def valid_literal_value?(); end

  def valid_shareable_constant_value?(); end
  KEYWORDS = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
  def encoding(); end

  def without(type); end
end

class RuboCop::MagicComment::EmacsComment
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end

  def without(type); end
  FSTRING_LITERAL_COMMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
  def extract_typed(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
  def self.find_similar_name(target_name, names); end

  def self.find_similar_names(target_name, names); end
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def disable_parallel_when_invalid_option_combo(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def invalid_arguments_for_parallel(); end

  def only_includes_redundant_disable?(); end

  def validate_auto_gen_config(); end

  def validate_autocorrect(); end

  def validate_cache_enabled_for_cache_root(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_display_only_correctable_and_autocorrect(); end

  def validate_display_only_failed(); end

  def validate_display_only_failed_and_display_only_correctable(); end

  def validate_exclude_limit_option(); end

  def validate_lsp_and_editor_mode(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
  HIDDEN_FILE_PATTERN = ::T.let(nil, ::T.untyped)
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.glob?(path); end

  def self.hidden_dir?(path); end

  def self.hidden_file?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.maybe_hidden_file?(path); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.relative_paths_cache(); end

  def self.relative_paths_cache=(relative_paths_cache); end

  def self.smart_path(path); end
end

module RuboCop::Platform
  def self.windows?(); end
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

module RuboCop::Rails::Inject
  def self.defaults!(); end
end

module RuboCop::Rails::SchemaLoader
  def db_schema_path(); end

  def load(target_ruby_version, parser_engine); end

  def reset!(); end
end

class RuboCop::Rails::SchemaLoader::AddIndex
  def table_name(); end
end

class RuboCop::Rails::SchemaLoader::Column
  def initialize(node); end

  def name(); end

  def not_null(); end

  def type(); end
end

class RuboCop::Rails::SchemaLoader::Index
  def columns(); end

  def expression(); end

  def initialize(node); end

  def name(); end

  def unique(); end
end

class RuboCop::Rails::SchemaLoader::Schema
  def add_indices(); end

  def add_indices_by(table_name:); end

  def initialize(ast); end

  def table_by(name:); end

  def tables(); end
end

class RuboCop::Rails::SchemaLoader::Table
  def columns(); end

  def indices(); end

  def initialize(node); end

  def name(); end

  def with_column?(name:); end
end

module RuboCop::Rails::Version
  def self.document_version(); end
end

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def debug?(); end

  def initialize(file, team, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def path(); end

  def save(offenses); end

  def valid?(); end
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.rubocop_required_features(); end

  def self.rubocop_required_features=(rubocop_required_features); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
  REDUNDANT_COP_DISABLE_DIRECTIVE_RULES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses_by_iteration, loop_start: T.unsafe(nil)); end

  def offenses(); end
end

class RuboCop::Runner
  def self.ruby_extractors(); end
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

class RuboCop::TargetFinder
  def find(args, mode); end

  def find_files(base_dir, flags); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::GemspecFile
  def gem_requirement_versions(param0=T.unsafe(nil)); end

  def required_ruby_version(param0); end
  GEMSPEC_EXTENSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
  RUBY_VERSION_FILENAME = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::ToolVersionsFile
  TOOL_VERSIONS_FILENAME = ::T.let(nil, ::T.untyped)
  TOOL_VERSIONS_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

RuboCop::Token = RuboCop::AST::Token

module RuboCop::Util
  def self.silence_warnings(); end
end

module RuboCop::Version
  CANONICAL_FEATURE_NAMES = ::T.let(nil, ::T.untyped)
  EXTENSION_PATH_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.document_version(); end

  def self.extension_versions(env); end

  def self.feature_version(feature); end

  def self.parser_version(); end

  def self.server_mode(); end

  def self.version(debug: T.unsafe(nil), env: T.unsafe(nil)); end
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

RubyLex = IRB::RubyLex

module RubyLsp
  VERSION = ::T.let(nil, ::T.untyped)
end

module RubyLsp::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class RubyVM::AbstractSyntaxTree::Node
  def ==(other); end

  def all_tokens(); end

  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end

  def to_sexp(); end

  def tokens(); end
end

module RubyVM::AbstractSyntaxTree
  def self.node_id_for_backtrace_location(backtrace_location); end
end

RubyVM::DebugInspector = DebugInspector

class RubyVM::InstructionSequence
  def script_lines(); end
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
  def self.compile_file_prism(*arg); end

  def self.compile_prism(*arg); end
end

module RubyVM::RJIT
end

module RubyVM::RJIT
  def self.enable(); end

  def self.enabled?(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

module SAXMachine
  VERSION = ::T.let(nil, ::T.untyped)
end

module SAXMachine::SAXAbstractHandler
  NO_BUFFER = ::T.let(nil, ::T.untyped)
end

SE = PryStackExplorer

module SSHKit
  PARSERS = ::T.let(nil, ::T.untyped)
end

class SSHKit::Backend::Abstract
  def as(who, &_block); end

  def background(*args); end

  def capture(*args); end

  def debug(*args, **arg, &block); end

  def download!(_remote, _local=T.unsafe(nil), _options=T.unsafe(nil)); end

  def error(*args, **arg, &block); end

  def execute(*args); end

  def fatal(*args, **arg, &block); end

  def host(); end

  def info(*args, **arg, &block); end

  def initialize(host, &block); end

  def log(*args, **arg, &block); end

  def make(commands=T.unsafe(nil)); end

  def rake(commands=T.unsafe(nil)); end

  def redact(arg); end

  def run(); end

  def test(*args); end

  def upload!(_local, _remote, _options=T.unsafe(nil)); end

  def warn(*args, **arg, &block); end

  def with(environment, &_block); end

  def within(directory, &_block); end
end

class SSHKit::Backend::Abstract
  def self.config(); end

  def self.configure(); end
end

class SSHKit::Backend::ConnectionPool
  def caches(); end

  def close_connections(); end

  def flush_connections(); end

  def idle_timeout(); end

  def idle_timeout=(idle_timeout); end

  def initialize(idle_timeout=T.unsafe(nil)); end

  def timed_out_connections(); end

  def with(connection_factory, *args); end
end

class SSHKit::Backend::ConnectionPool::Cache
  def clear(); end

  def closer(); end

  def connections(); end

  def evict(); end

  def idle_timeout(); end

  def initialize(key, idle_timeout, closer); end

  def key(); end

  def key=(key); end

  def pop(); end

  def push(conn); end

  def same_key?(other_key); end
end

class SSHKit::Backend::ConnectionPool::NilCache
  def closer(); end

  def closer=(_); end

  def pop(); end

  def push(conn); end

  def same_key?(_key); end
end

class SSHKit::Backend::ConnectionPool::NilCache
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class SSHKit::Backend::Local
  def download!(remote, local=T.unsafe(nil), _options=T.unsafe(nil)); end

  def initialize(_=T.unsafe(nil), &block); end

  def upload!(local, remote, options=T.unsafe(nil)); end
end

class SSHKit::Backend::Netssh
  def download!(remote, local=T.unsafe(nil), options=T.unsafe(nil)); end

  def upload!(local, remote, options=T.unsafe(nil)); end
end

class SSHKit::Backend::Netssh::Configuration
  def connection_timeout(); end

  def connection_timeout=(connection_timeout); end

  def pty(); end

  def pty=(pty); end

  def ssh_options(); end

  def ssh_options=(ssh_options); end

  def transfer_method(); end

  def transfer_method=(method); end
end

class SSHKit::Backend::Netssh::KnownHosts
  def add(*args); end

  def initialize(); end

  def lock(); end

  def locked?(); end

  def search_for(host, options=T.unsafe(nil)); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class SSHKit::Backend::Netssh::KnownHostsKeys
  def initialize(path); end

  def keys_for(hostlist); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class SSHKit::Backend::Netssh
  def self.assert_valid_transfer_method!(method); end

  def self.pool(); end

  def self.pool=(pool); end
end

class SSHKit::Backend::Printer
  def download!(*args); end

  def execute_command(cmd); end

  def test(*arg); end

  def upload!(*args); end
end

class SSHKit::Backend::Skipper
  def debug(_messages); end

  def download!(*args); end

  def error(_messages); end

  def execute_command(cmd); end

  def fatal(_messages); end

  def info(_messages); end

  def initialize(&block); end

  def log(_messages); end

  def upload!(*args); end
end

module SSHKit::Backend
  def self.current(); end
end

class SSHKit::Color
  def colorize(obj, color, mode=T.unsafe(nil)); end

  def colorize?(); end

  def initialize(output, env=T.unsafe(nil)); end
  COLOR_CODES = ::T.let(nil, ::T.untyped)
end

class SSHKit::Command
  def args(); end

  def command(); end

  def complete?(); end

  def environment_hash(); end

  def environment_string(); end

  def exit_status(); end

  def exit_status=(new_exit_status); end

  def failed?(); end

  def failure?(); end

  def finished?(); end

  def full_stderr(); end

  def full_stdout(); end

  def group(&_block); end

  def host(); end

  def in_background(&_block); end

  def initialize(*args); end

  def on_stderr(channel, data); end

  def on_stdout(channel, data); end

  def options(); end

  def runtime(); end

  def should_map?(); end

  def started(); end

  def started=(new_started); end

  def started?(); end

  def started_at(); end

  def stderr(); end

  def stderr=(new_value); end

  def stdout(); end

  def stdout=(new_value); end

  def success?(); end

  def successful?(); end

  def to_command(); end

  def to_hash(); end

  def umask(&_block); end

  def user(&_block); end

  def uuid(); end

  def verbosity(); end

  def with(&_block); end

  def with_redaction(); end

  def within(&_block); end
end

class SSHKit::Command
  def self.shellescape_except_tilde(file); end
end

class SSHKit::CommandMap
  def [](command); end

  def []=(command, new_command); end

  def clear(); end

  def defaults(); end

  def initialize(value=T.unsafe(nil)); end

  def prefix(); end
  TO_VALUE = ::T.let(nil, ::T.untyped)
end

class SSHKit::CommandMap::CommandHash
  def [](key); end

  def []=(key, value); end

  def initialize(defaults=T.unsafe(nil)); end
end

class SSHKit::CommandMap::PrefixProvider
  def [](command); end
end

class SSHKit::Configuration
  def backend(); end

  def backend=(backend); end

  def command_map(); end

  def command_map=(value); end

  def default_env(); end

  def default_env=(default_env); end

  def default_runner(); end

  def default_runner=(default_runner); end

  def default_runner_config(); end

  def default_runner_config=(config_hash); end

  def deprecation_logger(); end

  def deprecation_output=(out); end

  def format=(format); end

  def output(); end

  def output=(output); end

  def output_verbosity(); end

  def output_verbosity=(verbosity); end

  def umask(); end

  def umask=(umask); end

  def use_format(formatter, *args); end
end

class SSHKit::Coordinator
  def each(options=T.unsafe(nil), &block); end

  def hosts(); end

  def hosts=(hosts); end

  def initialize(raw_hosts); end
end

module SSHKit::DSL
  def on(hosts, options=T.unsafe(nil), &block); end

  def run_locally(&block); end
end

class SSHKit::DeprecationLogger
  def initialize(out); end

  def log(message); end
end

class SSHKit::Formatter::Abstract
  def <<(obj); end

  def colorize(*args, **arg, &block); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(output, options=T.unsafe(nil)); end

  def log(message); end

  def log_command_data(command, _stream_type, _stream_data); end

  def log_command_exit(command); end

  def log_command_start(command); end

  def options(); end

  def original_output(); end

  def read(*args, **arg, &block); end

  def rewind(*args, **arg, &block); end

  def warn(message); end

  def write(_obj); end
end

class SSHKit::Formatter::Pretty
  def format_message(verbosity, message, uuid=T.unsafe(nil)); end

  def log_command_data(command, stream_type, stream_data); end

  def write(obj); end
  LEVEL_COLORS = ::T.let(nil, ::T.untyped)
  LEVEL_NAMES = ::T.let(nil, ::T.untyped)
end

class SSHKit::Formatter::SimpleText
  def colorize(obj, _color, _mode=T.unsafe(nil)); end

  def format_message(_verbosity, message, _uuid=T.unsafe(nil)); end
end

class SSHKit::Host
  def ==(other_host); end

  def eql?(other_host); end

  def equal?(other_host); end

  def first_suitable_parser(host); end

  def hostname(); end

  def hostname=(hostname); end

  def initialize(host_string_or_options_hash); end

  def key=(new_key); end

  def keys(); end

  def keys=(new_keys); end

  def local?(); end

  def netssh_options(); end

  def password(); end

  def password=(password); end

  def port(); end

  def port=(port); end

  def properties(); end

  def ssh_options(); end

  def ssh_options=(ssh_options); end

  def transfer_method(); end

  def transfer_method=(method); end

  def user(); end

  def user=(user); end

  def username(); end
end

class SSHKit::IPv6HostWithPortParser
  IPV6_REGEX = ::T.let(nil, ::T.untyped)
end

class SSHKit::LogMessage
  def initialize(verbosity, message); end

  def message(); end

  def verbosity(); end
end

class SSHKit::Logger
  DEBUG = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FATAL = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  WARN = ::T.let(nil, ::T.untyped)
end

class SSHKit::MappingInteractionHandler
  def initialize(mapping, log_level=T.unsafe(nil)); end

  def on_data(_command, stream_name, data, channel); end
end

class SSHKit::Runner::Abstract
  def block(); end

  def hosts(); end

  def initialize(hosts, options=T.unsafe(nil), &block); end

  def options(); end
end

class SSHKit::Runner::ExecuteError
  def initialize(cause); end
end

class SSHKit::Runner::Group
  def group_size(); end

  def group_size=(group_size); end
end

class SSHKit::Runner::Null
  def execute(); end
end

class SSHKit::Runner::Parallel
  def execute(); end
end

class SSHKit::Runner::Sequential
  def execute(); end

  def wait_interval(); end

  def wait_interval=(wait_interval); end
end

class SSHKit::SimpleHostParser
  def attributes(); end

  def hostname(); end

  def initialize(host_string); end

  def port(); end

  def username(); end
end

class SSHKit::SimpleHostParser
  def self.suitable?(host_string); end
end

module SSHKit
  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.reset_configuration!(); end
end

ScanError = StringScanner::Error

module Seahorse::Client::H2
  DNS_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::H2::Connection
  CHUNKSIZE = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  SOCKET_FAMILY = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::HandlerListEntry
  STEPS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::ConnectionPool
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::NetHttp::Handler
  DNS_ERROR_MESSAGES = ::T.let(nil, ::T.untyped)
  NETWORK_ERRORS = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::Plugins::ContentLength::Handler
  METHODS_WITHOUT_BODY = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::Response
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  BASE36_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  def self.base36(n=T.unsafe(nil)); end

  def self.base58(n=T.unsafe(nil)); end
end

module Selenium::WebDriver
  VERSION = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::ActionBuilder
  def add_key_input(name); end

  def add_pointer_input(kind, name); end

  def add_wheel_input(name); end

  def clear_all_actions(); end

  def device(name: T.unsafe(nil), type: T.unsafe(nil)); end

  def devices(); end

  def initialize(bridge, devices: T.unsafe(nil), async: T.unsafe(nil), duration: T.unsafe(nil)); end

  def key_inputs(); end

  def pause(device: T.unsafe(nil), duration: T.unsafe(nil)); end

  def pauses(device: T.unsafe(nil), number: T.unsafe(nil), duration: T.unsafe(nil)); end

  def perform(); end

  def pointer_inputs(); end

  def release_actions(); end

  def wheel_inputs(); end
end

class Selenium::WebDriver::Alert
  def accept(); end

  def dismiss(); end

  def initialize(bridge); end

  def send_keys(keys); end

  def text(); end
end

module Selenium::WebDriver::Atoms
  def atom_script(function_name); end
end

class Selenium::WebDriver::BiDi
  def callbacks(); end

  def close(); end

  def error_message(message); end

  def initialize(url:); end

  def send_cmd(method, **params); end

  def session(); end
end

class Selenium::WebDriver::BiDi::BrowsingContext
  def close(); end

  def get_tree(max_depth: T.unsafe(nil)); end

  def id(); end

  def id=(id); end

  def initialize(driver:, browsing_context_id: T.unsafe(nil), type: T.unsafe(nil), reference_context: T.unsafe(nil)); end

  def navigate(url:, readiness_state: T.unsafe(nil)); end
  READINESS_STATE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::BiDi::BrowsingContext
end

class Selenium::WebDriver::BiDi::LogInspector
  def initialize(driver, browsing_context_ids=T.unsafe(nil)); end

  def on_console_entry(filter_by=T.unsafe(nil), &block); end

  def on_javascript_exception(&block); end

  def on_javascript_log(filter_by=T.unsafe(nil), &block); end

  def on_log(filter_by=T.unsafe(nil), &block); end
  EVENTS = ::T.let(nil, ::T.untyped)
  LOG_LEVEL = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::BiDi::LogInspector
end

class Selenium::WebDriver::BiDi::Session
  def initialize(bidi); end

  def status(); end

  def subscribe(events, browsing_contexts=T.unsafe(nil)); end

  def unsubscribe(events, browsing_contexts=T.unsafe(nil)); end
end

class Selenium::WebDriver::BiDi::Session::Status
  def message(); end

  def message=(_); end

  def ready(); end

  def ready=(_); end
end

class Selenium::WebDriver::BiDi::Session::Status
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Selenium::WebDriver::BiDi::Session
end

class Selenium::WebDriver::BiDi
end

class Selenium::WebDriver::ChildProcess
  def alive?(); end

  def detach(); end

  def detach=(detach); end

  def exited?(); end

  def initialize(*command); end

  def io(); end

  def io=(io); end

  def poll_for_exit(timeout); end

  def start(); end

  def stop(timeout=T.unsafe(nil)); end

  def wait(); end
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
  SIGKILL = ::T.let(nil, ::T.untyped)
  SIGTERM = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::ChildProcess
  def self.build(*command); end
end

class Selenium::WebDriver::Chrome::Driver
  include ::Selenium::WebDriver::LocalDriver
  def initialize(options: T.unsafe(nil), service: T.unsafe(nil), url: T.unsafe(nil), **opts); end
end

class Selenium::WebDriver::Chrome::Driver
end

module Selenium::WebDriver::Chrome::Features
  include ::Selenium::WebDriver::Chromium::Features
  def command_list(); end

  def commands(command); end
  CHROME_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Chrome::Features
end

class Selenium::WebDriver::Chrome::Options
  BROWSER = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Options
end

class Selenium::WebDriver::Chrome::Profile
end

class Selenium::WebDriver::Chrome::Profile
end

class Selenium::WebDriver::Chrome::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Service
end

module Selenium::WebDriver::Chrome
  def self.path(); end

  def self.path=(path); end
end

module Selenium::WebDriver::Chromium
end

class Selenium::WebDriver::Chromium::Driver
  def devtools_url(); end

  def devtools_version(); end
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chromium::Driver
end

module Selenium::WebDriver::Chromium::Features
  def available_log_types(); end

  def cast_issue_message(); end

  def cast_sink_to_use=(name); end

  def cast_sinks(); end

  def delete_network_conditions(); end

  def launch_app(id); end

  def log(type); end

  def network_conditions(); end

  def network_conditions=(conditions); end

  def send_command(command_params); end

  def set_permission(name, value); end

  def start_cast_desktop_mirroring(name); end

  def start_cast_tab_mirroring(name); end

  def stop_casting(name); end
  CHROMIUM_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Chromium::Features
end

class Selenium::WebDriver::Chromium::Options
  def add_argument(arg); end

  def add_emulation(**opts); end

  def add_encoded_extension(encoded); end

  def add_extension(path); end

  def add_preference(name, value); end

  def binary_path(); end

  def camelize?(key); end

  def enable_android(package: T.unsafe(nil), serial_number: T.unsafe(nil), use_running_app: T.unsafe(nil), activity: T.unsafe(nil)); end

  def encode_extension(path); end

  def extensions(); end

  def extensions=(extensions); end

  def initialize(profile: T.unsafe(nil), **opts); end

  def logging_prefs(); end

  def logging_prefs=(logging_prefs); end

  def process_browser_options(browser_options); end

  def profile(); end

  def profile=(profile); end

  def validate_extension(path); end
  CAPABILITIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chromium::Options
end

class Selenium::WebDriver::Chromium::Profile
  include ::Selenium::WebDriver::ProfileHelper
  def [](key); end

  def []=(key, value); end

  def add_encoded_extension(encoded); end

  def add_extension(path); end

  def directory(); end

  def initialize(model=T.unsafe(nil)); end

  def layout_on_disk(); end
end

class Selenium::WebDriver::Chromium::Profile
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods
end

module Selenium::WebDriver::Chromium
end

class Selenium::WebDriver::Credential
  def as_json(*arg); end

  def id(); end

  def initialize(id:, resident_credential:, rp_id:, private_key:, **opts); end

  def private_key(); end

  def resident_credential(); end

  def resident_credential?(); end

  def rp_id(); end

  def sign_count(); end

  def user_handle(); end
end

class Selenium::WebDriver::Credential
  def self.decode(base64); end

  def self.encode(byte_array); end

  def self.from_json(opts); end

  def self.non_resident(**opts); end

  def self.resident(**opts); end
end

class Selenium::WebDriver::DevTools
  def callbacks(); end

  def close(); end

  def initialize(url:); end

  def method_missing(method, *_args); end

  def send_cmd(method, **params); end
end

class Selenium::WebDriver::DevTools::ConsoleEvent
  def args(); end

  def args=(args); end

  def initialize(type:, timestamp:, args:); end

  def timestamp(); end

  def timestamp=(timestamp); end

  def type(); end

  def type=(type); end
end

class Selenium::WebDriver::DevTools::ConsoleEvent
end

class Selenium::WebDriver::DevTools::ExceptionEvent
  def description(); end

  def description=(description); end

  def initialize(description:, timestamp:, stacktrace:); end

  def stacktrace(); end

  def stacktrace=(stacktrace); end

  def timestamp(); end

  def timestamp=(timestamp); end
end

class Selenium::WebDriver::DevTools::ExceptionEvent
end

class Selenium::WebDriver::DevTools::MutationEvent
  def attribute_name(); end

  def attribute_name=(attribute_name); end

  def current_value(); end

  def current_value=(current_value); end

  def element(); end

  def element=(element); end

  def initialize(element:, attribute_name:, current_value:, old_value:); end

  def old_value(); end

  def old_value=(old_value); end
end

class Selenium::WebDriver::DevTools::MutationEvent
end

class Selenium::WebDriver::DevTools::NetworkInterceptor
  def initialize(devtools); end

  def intercept(&block); end
  CANNOT_GET_BODY_ON_REDIRECT_ERROR_CODE = ::T.let(nil, ::T.untyped)
  INVALID_INTERCEPTION_ID_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::DevTools::NetworkInterceptor
end

class Selenium::WebDriver::DevTools::PinnedScript
  def callable(); end

  def devtools_identifier(); end

  def devtools_identifier=(devtools_identifier); end

  def initialize(script); end

  def key(); end

  def key=(key); end

  def remove(); end

  def script(); end

  def script=(script); end

  def to_json(*arg); end
end

class Selenium::WebDriver::DevTools::PinnedScript
end

class Selenium::WebDriver::DevTools::Request
  def ==(other); end

  def headers(); end

  def headers=(headers); end

  def id(); end

  def initialize(id:, url:, method:, headers:, post_data:); end

  def method(); end

  def method=(method); end

  def post_data(); end

  def post_data=(post_data); end

  def url(); end

  def url=(url); end
end

class Selenium::WebDriver::DevTools::Request
  def self.from(id, params); end
end

class Selenium::WebDriver::DevTools::Response
  def ==(other); end

  def body(); end

  def body=(body); end

  def code(); end

  def code=(code); end

  def headers(); end

  def headers=(headers); end

  def id(); end

  def initialize(id:, code:, body:, headers:); end
end

class Selenium::WebDriver::DevTools::Response
  def self.from(id, encoded_body, params); end
end

class Selenium::WebDriver::DevTools
end

class Selenium::WebDriver::Dimension
  def height(); end

  def height=(_); end

  def width(); end

  def width=(_); end
end

class Selenium::WebDriver::Dimension
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Selenium::WebDriver::Driver
  def [](sel); end

  def action(**opts); end

  def add_virtual_authenticator(options); end

  def all(*args); end

  def browser(); end

  def capabilities(); end

  def close(); end

  def current_url(); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def first(*args); end

  def get(url); end

  def initialize(bridge: T.unsafe(nil), listener: T.unsafe(nil), **opts); end

  def manage(); end

  def navigate(); end

  def page_source(); end

  def quit(); end

  def ref(); end

  def script(script, *args); end

  def status(); end

  def switch_to(); end

  def title(); end

  def window_handle(); end

  def window_handles(); end
end

class Selenium::WebDriver::Driver
  def self.for(browser, opts=T.unsafe(nil)); end
end

module Selenium::WebDriver::DriverExtensions::DownloadsFiles
  def download_path=(path); end
end

module Selenium::WebDriver::DriverExtensions::FullPageScreenshot
  def save_full_page_screenshot(path); end
end

module Selenium::WebDriver::DriverExtensions::HasAddons
  def install_addon(path, temporary=T.unsafe(nil)); end

  def uninstall_addon(id); end
end

module Selenium::WebDriver::DriverExtensions::HasApplePermissions
  def permissions(); end

  def permissions=(permissions); end
end

module Selenium::WebDriver::DriverExtensions::HasAuthentication
  def register(username:, password:, uri: T.unsafe(nil)); end
end

module Selenium::WebDriver::DriverExtensions::HasBiDi
  def bidi(); end
end

module Selenium::WebDriver::DriverExtensions::HasCDP
  def execute_cdp(cmd, **params); end
end

module Selenium::WebDriver::DriverExtensions::HasCasting
  def cast_issue_message(); end

  def cast_sink_to_use=(name); end

  def cast_sinks(); end

  def start_cast_desktop_mirroring(name); end

  def start_cast_tab_mirroring(name); end

  def stop_casting(name); end
end

module Selenium::WebDriver::DriverExtensions::HasContext
  def context(); end

  def context=(value); end
end

module Selenium::WebDriver::DriverExtensions::HasDebugger
  def attach_debugger(); end
end

module Selenium::WebDriver::DriverExtensions::HasDevTools
  def devtools(); end
end

module Selenium::WebDriver::DriverExtensions::HasFileDownloads
  def delete_downloadable_files(); end

  def download_file(file_name, target_directory); end

  def downloadable_files(); end
end

module Selenium::WebDriver::DriverExtensions::HasLaunching
  def launch_app(id); end
end

module Selenium::WebDriver::DriverExtensions::HasLogEvents
  def on_log_event(kind, &block); end
  KINDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::DriverExtensions::HasLogs
  def logs(); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConditions
  def delete_network_conditions(); end

  def network_conditions(); end

  def network_conditions=(conditions); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkInterception
  def intercept(&block); end
end

module Selenium::WebDriver::DriverExtensions::HasPermissions
  def add_permission(name, value); end

  def add_permissions(opt); end
end

module Selenium::WebDriver::DriverExtensions::HasPinnedScripts
  def pin_script(script); end

  def pinned_scripts(); end

  def unpin_script(script); end
end

module Selenium::WebDriver::DriverExtensions::HasSessionId
  def session_id(); end
end

module Selenium::WebDriver::DriverExtensions::HasWebStorage
  def local_storage(); end

  def session_storage(); end
end

module Selenium::WebDriver::DriverExtensions::PrintsPage
  def print_page(**options); end

  def save_print_page(path, **options); end
end

module Selenium::WebDriver::DriverExtensions::UploadsFiles
  def file_detector=(detector); end
end

class Selenium::WebDriver::DriverFinder
  def browser_path(); end

  def browser_path?(); end

  def driver_path(); end

  def initialize(options, service); end
end

class Selenium::WebDriver::DriverFinder
  def self.path(options, service_class); end
end

module Selenium::WebDriver::Edge
end

class Selenium::WebDriver::Edge::Driver
  include ::Selenium::WebDriver::LocalDriver
  def initialize(options: T.unsafe(nil), service: T.unsafe(nil), url: T.unsafe(nil), **opts); end
end

class Selenium::WebDriver::Edge::Driver
end

module Selenium::WebDriver::Edge::Features
  include ::Selenium::WebDriver::Chromium::Features
  def command_list(); end

  def commands(command); end
  EDGE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Edge::Features
end

class Selenium::WebDriver::Edge::Options
  def webview2!(); end
  BROWSER = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Edge::Options
end

class Selenium::WebDriver::Edge::Profile
end

class Selenium::WebDriver::Edge::Profile
end

class Selenium::WebDriver::Edge::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Edge::Service
end

module Selenium::WebDriver::Edge
  def self.path(); end

  def self.path=(path); end
end

class Selenium::WebDriver::Element
  def ==(other); end

  def [](name); end

  def accessible_name(); end

  def all(*args); end

  def aria_role(); end

  def as_json(*arg); end

  def attribute(name); end

  def clear(); end

  def click(); end

  def css_value(prop); end

  def displayed?(); end

  def dom_attribute(name); end

  def enabled?(); end

  def eql?(other); end

  def first(*args); end

  def initialize(bridge, id); end

  def location(); end

  def location_once_scrolled_into_view(); end

  def property(name); end

  def rect(); end

  def ref(); end

  def selected?(); end

  def send_key(*args); end

  def send_keys(*args); end

  def shadow_root(); end

  def size(); end

  def style(prop); end

  def submit(); end

  def tag_name(); end

  def text(); end

  def to_json(*arg); end
  ELEMENT_KEY = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Error
  ERROR_URL = ::T.let(nil, ::T.untyped)
  SUPPORT_MSG = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Error::InvalidSelectorError
  def initialize(msg=T.unsafe(nil)); end
end

class Selenium::WebDriver::Error::NoSuchDriverError
  def initialize(msg=T.unsafe(nil)); end
end

class Selenium::WebDriver::Error::NoSuchElementError
  def initialize(msg=T.unsafe(nil)); end
end

class Selenium::WebDriver::Error::ServerError
  def initialize(response); end
end

class Selenium::WebDriver::Error::ServerError
end

class Selenium::WebDriver::Error::StaleElementReferenceError
  def initialize(msg=T.unsafe(nil)); end
end

module Selenium::WebDriver::Error
  def self.for_error(error); end
end

module Selenium::WebDriver::FileReaper
  def self.<<(file); end

  def self.reap(file); end

  def self.reap!(); end

  def self.reap=(reap); end

  def self.reap?(); end

  def self.tmp_files(); end
end

module Selenium::WebDriver::Firefox
  DEFAULT_ASSUME_UNTRUSTED_ISSUER = ::T.let(nil, ::T.untyped)
  DEFAULT_LOAD_NO_FOCUS_LIB = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_SECURE_SSL = ::T.let(nil, ::T.untyped)
  DEVTOOLS_VERSION = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Driver
  include ::Selenium::WebDriver::LocalDriver
  def initialize(options: T.unsafe(nil), service: T.unsafe(nil), url: T.unsafe(nil), **opts); end
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Driver
end

class Selenium::WebDriver::Firefox::Extension
  def initialize(path); end

  def write_to(extensions_dir); end
  NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Extension
end

module Selenium::WebDriver::Firefox::Features
  def command_list(); end

  def commands(command); end

  def context(); end

  def context=(context); end

  def full_screenshot(); end

  def install_addon(path, temporary); end

  def uninstall_addon(id); end
  FIREFOX_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Firefox::Features
end

class Selenium::WebDriver::Firefox::Options
  def add_argument(arg); end

  def add_preference(name, value); end

  def debugger_address(); end

  def debugger_address=(debugger_address); end

  def enable_android(package: T.unsafe(nil), serial_number: T.unsafe(nil), activity: T.unsafe(nil), intent_arguments: T.unsafe(nil)); end

  def initialize(log_level: T.unsafe(nil), **opts); end

  def log_level(); end

  def log_level=(level); end

  def profile(); end

  def profile=(profile); end
  BROWSER = ::T.let(nil, ::T.untyped)
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Options
end

class Selenium::WebDriver::Firefox::Profile
  include ::Selenium::WebDriver::ProfileHelper
  def []=(key, value); end

  def add_extension(path, name=T.unsafe(nil)); end

  def as_json(); end

  def initialize(model=T.unsafe(nil)); end

  def layout_on_disk(); end

  def load_no_focus_lib=(load_no_focus_lib); end

  def log_file(); end

  def log_file=(file); end

  def name(); end

  def port=(port); end

  def proxy=(proxy); end

  def secure_ssl=(secure_ssl); end
  DEFAULT_PREFERENCES = ::T.let(nil, ::T.untyped)
  LOCK_FILES = ::T.let(nil, ::T.untyped)
  VALID_PREFERENCE_TYPES = ::T.let(nil, ::T.untyped)
  WEBDRIVER_PREFS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Profile
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods
  def self.decoded(json); end

  def self.from_name(name); end

  def self.ini(); end
end

class Selenium::WebDriver::Firefox::ProfilesIni
  def [](name); end

  def refresh(); end
end

class Selenium::WebDriver::Firefox::ProfilesIni
end

class Selenium::WebDriver::Firefox::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Service
end

module Selenium::WebDriver::Firefox::Util
end

module Selenium::WebDriver::Firefox::Util
  def self.app_data_path(); end

  def self.stringified?(str); end
end

module Selenium::WebDriver::Firefox
  def self.path(); end

  def self.path=(path); end
end

class Selenium::WebDriver::HTML5::LocalStorage
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def initialize(bridge); end

  def keys(); end

  def size(); end
end

class Selenium::WebDriver::HTML5::SessionStorage
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def initialize(bridge); end

  def keys(); end

  def size(); end
end

module Selenium::WebDriver::HTML5::SharedWebStorage
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(&blk); end

  def empty?(); end

  def fetch(key); end

  def has_key?(key); end

  def key?(key); end

  def member?(key); end
end

module Selenium::WebDriver::IE
end

class Selenium::WebDriver::IE::Driver
  include ::Selenium::WebDriver::LocalDriver
  def initialize(options: T.unsafe(nil), service: T.unsafe(nil), url: T.unsafe(nil), **opts); end
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::IE::Driver
end

module Selenium::WebDriver::IE::Features
  def command_list(); end

  def commands(command); end
end

module Selenium::WebDriver::IE::Features
end

class Selenium::WebDriver::IE::Options
  def add_argument(arg); end

  def args(); end
  BROWSER = ::T.let(nil, ::T.untyped)
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  SCROLL_BOTTOM = ::T.let(nil, ::T.untyped)
  SCROLL_TOP = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::IE::Options
end

class Selenium::WebDriver::IE::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::IE::Service
end

module Selenium::WebDriver::IE
end

module Selenium::WebDriver::Interactions
  KEY = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  WHEEL = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::InputDevice
  def actions(); end

  def add_action(action); end

  def clear_actions(); end

  def create_pause(duration=T.unsafe(nil)); end

  def encode(); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class Selenium::WebDriver::Interactions::Interaction
  def assert_source(_source); end

  def initialize(source); end

  def type(); end
end

class Selenium::WebDriver::Interactions::KeyInput
  def create_key_down(key); end

  def create_key_up(key); end
  SUBTYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::Pause
  def assert_source(source); end

  def encode(); end

  def initialize(source, duration=T.unsafe(nil)); end
end

class Selenium::WebDriver::Interactions::PointerCancel
  def assert_source(source); end

  def encode(); end
end

module Selenium::WebDriver::Interactions::PointerEventProperties
  def process_opts(); end
  VALID = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerInput
  def assert_kind(pointer); end

  def create_pointer_cancel(); end

  def create_pointer_down(button, **opts); end

  def create_pointer_move(duration: T.unsafe(nil), x: T.unsafe(nil), y: T.unsafe(nil), origin: T.unsafe(nil), **opts); end

  def create_pointer_up(button, **opts); end

  def initialize(kind, name: T.unsafe(nil)); end

  def kind(); end
  KIND = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerMove
  def assert_source(source); end

  def encode(); end

  def initialize(source, duration, x, y, **opts); end
  ORIGINS = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  VIEWPORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerPress
  def encode(); end

  def initialize(source, direction, button, **opts); end
  BUTTONS = ::T.let(nil, ::T.untyped)
  DIRECTIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::Scroll
  def assert_source(source); end

  def encode(); end

  def initialize(source:, origin: T.unsafe(nil), duration: T.unsafe(nil), **opts); end
end

class Selenium::WebDriver::Interactions::TypingInteraction
  def assert_source(source); end

  def assert_type(type); end

  def encode(); end

  def initialize(source, type, key); end
end

class Selenium::WebDriver::Interactions::WheelInput
  def create_scroll(**opts); end
end

module Selenium::WebDriver::Interactions
  def self.key(name=T.unsafe(nil)); end

  def self.mouse(name: T.unsafe(nil)); end

  def self.none(name=T.unsafe(nil)); end

  def self.pen(name: T.unsafe(nil)); end

  def self.pointer(kind=T.unsafe(nil), name: T.unsafe(nil)); end

  def self.touch(name: T.unsafe(nil)); end

  def self.wheel(name=T.unsafe(nil)); end
end

module Selenium::WebDriver::KeyActions
  def key_down(*args, device: T.unsafe(nil)); end

  def key_up(*args, device: T.unsafe(nil)); end

  def send_keys(*args, device: T.unsafe(nil)); end
end

module Selenium::WebDriver::Keys
  KEYS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Keys
  def self.[](key); end

  def self.encode(keys); end

  def self.encode_key(key); end
end

module Selenium::WebDriver::LocalDriver
  def initialize_local_driver(options, service, url); end

  def process_options(options, service); end
end

class Selenium::WebDriver::LogEntry
  def as_json(*arg); end

  def initialize(level, timestamp, message); end

  def level(); end

  def message(); end

  def time(); end

  def timestamp(); end
end

class Selenium::WebDriver::Logger
  def allow(*ids); end

  def close(*args, **arg, &block); end

  def debug(message, id: T.unsafe(nil), &block); end

  def debug?(*args, **arg, &block); end

  def deprecate(old, new=T.unsafe(nil), id: T.unsafe(nil), reference: T.unsafe(nil), &block); end

  def error(message, id: T.unsafe(nil), &block); end

  def error?(*args, **arg, &block); end

  def fatal(*args, **arg, &block); end

  def fatal?(*args, **arg, &block); end

  def ignore(*ids); end

  def info(message, id: T.unsafe(nil), &block); end

  def info?(*args, **arg, &block); end

  def initialize(progname=T.unsafe(nil), default_level: T.unsafe(nil), ignored: T.unsafe(nil), allowed: T.unsafe(nil)); end

  def io(); end

  def level(*args, **arg, &block); end

  def level=(level); end

  def output=(io); end

  def warn(message, id: T.unsafe(nil), &block); end

  def warn?(*args, **arg, &block); end
end

class Selenium::WebDriver::Logs
  def available_types(); end

  def get(type); end

  def initialize(bridge); end
end

class Selenium::WebDriver::Manager
  def add_cookie(opts=T.unsafe(nil)); end

  def all_cookies(); end

  def cookie_named(name); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def initialize(bridge); end

  def timeouts(); end

  def window(); end
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Navigation
  def back(); end

  def forward(); end

  def initialize(bridge); end

  def refresh(); end

  def to(url); end
end

class Selenium::WebDriver::Options
  def ==(other); end

  def add_option(name, value=T.unsafe(nil)); end

  def as_json(*arg); end

  def eql?(other); end

  def initialize(**opts); end

  def options(); end

  def options=(options); end
  GRID_OPTIONS = ::T.let(nil, ::T.untyped)
  W3C_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Options
  def self.chrome(**opts); end

  def self.driver_path(); end

  def self.edge(**opts); end

  def self.firefox(**opts); end

  def self.ie(**opts); end

  def self.internet_explorer(**opts); end

  def self.microsoftedge(**opts); end

  def self.safari(**opts); end

  def self.set_capabilities(); end
end

module Selenium::WebDriver::Platform
  def self.assert_executable(path); end

  def self.assert_file(path); end

  def self.ci(); end

  def self.cygwin?(); end

  def self.cygwin_path(path, only_cygwin: T.unsafe(nil), **opts); end

  def self.engine(); end

  def self.exit_hook(); end

  def self.home(); end

  def self.interfaces(); end

  def self.ip(); end

  def self.jruby?(); end

  def self.linux?(); end

  def self.localhost(); end

  def self.mac?(); end

  def self.make_writable(file); end

  def self.null_device(); end

  def self.os(); end

  def self.ruby_version(); end

  def self.truffleruby?(); end

  def self.unix?(); end

  def self.unix_path(path); end

  def self.windows?(); end

  def self.windows_path(path); end

  def self.wrap_in_quotes_if_necessary(str); end

  def self.wsl?(); end
end

class Selenium::WebDriver::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Selenium::WebDriver::Point
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Selenium::WebDriver::PointerActions
  def click(element=T.unsafe(nil), button: T.unsafe(nil), device: T.unsafe(nil)); end

  def click_and_hold(element=T.unsafe(nil), button: T.unsafe(nil), device: T.unsafe(nil)); end

  def context_click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def default_move_duration(); end

  def default_move_duration=(default_move_duration); end

  def double_click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def drag_and_drop(source, target, device: T.unsafe(nil)); end

  def drag_and_drop_by(source, right_by, down_by, device: T.unsafe(nil)); end

  def move_by(right_by, down_by, device: T.unsafe(nil), duration: T.unsafe(nil), **opts); end

  def move_to(element, right_by=T.unsafe(nil), down_by=T.unsafe(nil), **opts); end

  def move_to_location(x, y, device: T.unsafe(nil), duration: T.unsafe(nil), **opts); end

  def pointer_down(button=T.unsafe(nil), device: T.unsafe(nil), **opts); end

  def pointer_up(button=T.unsafe(nil), device: T.unsafe(nil), **opts); end

  def release(button: T.unsafe(nil), device: T.unsafe(nil)); end
end

class Selenium::WebDriver::PortProber
  IGNORED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::PortProber
  def self.above(port); end

  def self.free?(port); end
end

module Selenium::WebDriver::ProfileHelper
  def as_json(*arg); end

  def encoded(); end

  def to_json(*arg); end
end

module Selenium::WebDriver::ProfileHelper::ClassMethods
  def from_json(json); end
end

module Selenium::WebDriver::ProfileHelper
  def self.decoded(json); end

  def self.included(base); end
end

class Selenium::WebDriver::Proxy
  def ==(other); end

  def as_json(*arg); end

  def auto_detect(); end

  def auto_detect=(bool); end

  def eql?(other); end

  def ftp(); end

  def ftp=(value); end

  def http(); end

  def http=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def no_proxy(); end

  def no_proxy=(value); end

  def pac(); end

  def pac=(url); end

  def socks(); end

  def socks=(value); end

  def socks_password(); end

  def socks_password=(value); end

  def socks_username(); end

  def socks_username=(value); end

  def socks_version(); end

  def socks_version=(value); end

  def ssl(); end

  def ssl=(value); end

  def to_json(*arg); end

  def type(); end

  def type=(type); end
  ALLOWED = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Proxy
  def self.json_create(data); end
end

class Selenium::WebDriver::Rectangle
  def height(); end

  def height=(_); end

  def width(); end

  def width=(_); end

  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Selenium::WebDriver::Rectangle
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Selenium::WebDriver::Remote
end

class Selenium::WebDriver::Remote::Bridge
  include ::Selenium::WebDriver::Atoms
  def accept_alert(); end

  def action(async: T.unsafe(nil), devices: T.unsafe(nil), duration: T.unsafe(nil)); end

  def actions(async: T.unsafe(nil), devices: T.unsafe(nil), duration: T.unsafe(nil)); end

  def active_element(); end

  def add_cookie(cookie); end

  def add_credential(credential, id); end

  def add_virtual_authenticator(options); end

  def alert=(keys); end

  def alert_text(); end

  def browser(); end

  def capabilities(); end

  def clear_element(element); end

  def clear_local_storage(); end

  def clear_session_storage(); end

  def click_element(element); end

  def close(); end

  def command_list(); end

  def cookie(name); end

  def cookies(); end

  def create_session(capabilities); end

  def credentials(authenticator_id); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def dismiss_alert(); end

  def element_aria_label(element); end

  def element_aria_role(element); end

  def element_attribute(element, name); end

  def element_displayed?(element); end

  def element_dom_attribute(element, name); end

  def element_enabled?(element); end

  def element_location(element); end

  def element_location_once_scrolled_into_view(element); end

  def element_property(element, name); end

  def element_rect(element); end

  def element_screenshot(element); end

  def element_selected?(element); end

  def element_size(element); end

  def element_tag_name(element); end

  def element_text(element); end

  def element_value(element); end

  def element_value_of_css_property(element, prop); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def file_detector(); end

  def file_detector=(file_detector); end

  def find_element_by(how, what, parent_ref=T.unsafe(nil)); end

  def find_elements_by(how, what, parent_ref=T.unsafe(nil)); end

  def full_screen_window(); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def http(); end

  def http=(http); end

  def initialize(url:, http_client: T.unsafe(nil)); end

  def local_storage_item(key, value=T.unsafe(nil)); end

  def local_storage_keys(); end

  def local_storage_size(); end

  def manage(); end

  def maximize_window(handle=T.unsafe(nil)); end

  def minimize_window(); end

  def new_window(type); end

  def page_source(); end

  def print_page(options=T.unsafe(nil)); end

  def quit(); end

  def refresh(); end

  def release_actions(); end

  def remove_all_credentials(authenticator_id); end

  def remove_credential(credential_id, authenticator_id); end

  def remove_local_storage_item(key); end

  def remove_session_storage_item(key); end

  def remove_virtual_authenticator(id); end

  def reposition_window(x, y); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def screenshot(); end

  def send_actions(data); end

  def send_keys_to_element(element, keys); end

  def session_id(); end

  def session_storage_item(key, value=T.unsafe(nil)); end

  def session_storage_keys(); end

  def session_storage_size(); end

  def set_window_rect(x: T.unsafe(nil), y: T.unsafe(nil), width: T.unsafe(nil), height: T.unsafe(nil)); end

  def shadow_root(element); end

  def status(); end

  def submit_element(element); end

  def switch_to_active_element(); end

  def switch_to_default_content(); end

  def switch_to_frame(id); end

  def switch_to_parent_frame(); end

  def switch_to_window(name); end

  def timeouts(); end

  def timeouts=(timeouts); end

  def title(); end

  def url(); end

  def user_verified(verified, authenticator_id); end

  def window_handle(); end

  def window_handles(); end

  def window_position(); end

  def window_rect(); end

  def window_size(handle=T.unsafe(nil)); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  ESCAPE_CSS_REGEXP = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUIT_ERRORS = ::T.let(nil, ::T.untyped)
  UNICODE_CODE_POINT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Bridge
end

class Selenium::WebDriver::Remote::Capabilities
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def accept_insecure_certs(); end

  def accept_insecure_certs=(value); end

  def as_json(*arg); end

  def browser_name(); end

  def browser_name=(value); end

  def browser_version(); end

  def browser_version=(value); end

  def capabilities(); end

  def eql?(other); end

  def implicit_timeout(); end

  def implicit_timeout=(timeout); end

  def initialize(opts=T.unsafe(nil)); end

  def merge!(other); end

  def page_load_strategy(); end

  def page_load_strategy=(value); end

  def page_load_timeout(); end

  def page_load_timeout=(timeout); end

  def platform_name(); end

  def platform_name=(value); end

  def proxy(); end

  def proxy=(proxy); end

  def remote_session_id(); end

  def remote_session_id=(value); end

  def script_timeout(); end

  def script_timeout=(timeout); end

  def set_window_rect(); end

  def set_window_rect=(value); end

  def strict_file_interactability(); end

  def strict_file_interactability=(value); end

  def timeouts(); end

  def timeouts=(timeouts); end

  def to_json(*arg); end

  def unhandled_prompt_behavior(); end

  def unhandled_prompt_behavior=(value); end

  def web_socket_url(); end

  def web_socket_url=(value); end
  KNOWN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Capabilities
  def self.always_match(capabilities); end

  def self.camel_case(str_or_sym); end

  def self.first_match(*capabilities); end

  def self.json_create(data); end
end

class Selenium::WebDriver::Remote::Driver
  include ::Selenium::WebDriver::DriverExtensions::UploadsFiles
  include ::Selenium::WebDriver::DriverExtensions::HasSessionId
  include ::Selenium::WebDriver::DriverExtensions::HasFileDownloads
  def initialize(capabilities: T.unsafe(nil), options: T.unsafe(nil), service: T.unsafe(nil), url: T.unsafe(nil), **opts); end
end

class Selenium::WebDriver::Remote::Driver
end

module Selenium::WebDriver::Remote::Features
  def add_commands(commands); end

  def command_list(); end

  def commands(command); end

  def delete_downloadable_files(); end

  def download_file(name); end

  def downloadable_files(); end

  def upload(local_file); end

  def upload_if_necessary(keys); end
  REMOTE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Remote::Features
end

module Selenium::WebDriver::Remote::Http
end

class Selenium::WebDriver::Remote::Http::Common
  def call(verb, url, command_hash); end

  def close(); end

  def quit_errors(); end

  def server_url=(server_url); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_HEADERS = ::T.let(nil, ::T.untyped)
  MAX_REDIRECTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Common
end

class Selenium::WebDriver::Remote::Http::Default
  def initialize(open_timeout: T.unsafe(nil), read_timeout: T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def proxy=(proxy); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end
  MAX_RETRIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Default
end

module Selenium::WebDriver::Remote::Http
end

class Selenium::WebDriver::Remote::Response
  def [](key); end

  def code(); end

  def error(); end

  def initialize(code, payload=T.unsafe(nil)); end

  def payload(); end
end

class Selenium::WebDriver::Remote::Response
end

module Selenium::WebDriver::Remote
end

module Selenium::WebDriver::Safari
end

class Selenium::WebDriver::Safari::Driver
  include ::Selenium::WebDriver::LocalDriver
  def initialize(options: T.unsafe(nil), service: T.unsafe(nil), url: T.unsafe(nil), **opts); end
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Safari::Driver
end

module Selenium::WebDriver::Safari::Features
  def attach_debugger(); end

  def command_list(); end

  def commands(command); end

  def permissions(); end

  def permissions=(permissions); end
  SAFARI_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Safari::Features
end

class Selenium::WebDriver::Safari::Options
  BROWSER = ::T.let(nil, ::T.untyped)
  CAPABILITIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Safari::Options
end

class Selenium::WebDriver::Safari::Service
  def log=(*arg); end
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EXECUTABLE = ::T.let(nil, ::T.untyped)
  SHUTDOWN_SUPPORTED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Safari::Service
end

module Selenium::WebDriver::Safari
  def self.path(); end

  def self.path=(path); end

  def self.technology_preview(); end

  def self.technology_preview!(); end

  def self.technology_preview?(); end

  def self.use_technology_preview(); end

  def self.use_technology_preview=(use_technology_preview); end
end

module Selenium::WebDriver::SearchContext
  def find_element(*args); end

  def find_elements(*args); end
  FINDERS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::SeleniumManager
  def self.bin_path(); end

  def self.bin_path=(bin_path); end

  def self.binary_paths(*arguments); end
end

class Selenium::WebDriver::Service
  def args(); end

  def args=(args); end

  def executable_path(); end

  def executable_path=(executable_path); end

  def extra_args(); end

  def host(); end

  def host=(host); end

  def initialize(path: T.unsafe(nil), port: T.unsafe(nil), log: T.unsafe(nil), args: T.unsafe(nil)); end

  def launch(); end

  def log=(log); end

  def port(); end

  def port=(port); end

  def shutdown_supported(); end
end

class Selenium::WebDriver::Service
  def self.chrome(**opts); end

  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.edge(**opts); end

  def self.firefox(**opts); end

  def self.ie(**opts); end

  def self.internet_explorer(**opts); end

  def self.microsoftedge(**opts); end

  def self.msedge(**opts); end

  def self.safari(**opts); end
end

class Selenium::WebDriver::ServiceManager
  def initialize(config); end

  def start(); end

  def stop(); end

  def uri(); end
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  START_TIMEOUT = ::T.let(nil, ::T.untyped)
  STOP_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::ShadowRoot
  def ==(other); end

  def as_json(*arg); end

  def eql?(other); end

  def initialize(bridge, id); end

  def ref(); end

  def to_json(*arg); end
  ROOT_KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::SocketLock
  def initialize(port, timeout); end

  def locked(); end
end

class Selenium::WebDriver::SocketPoller
  def closed?(); end

  def connected?(); end

  def initialize(host, port, timeout=T.unsafe(nil), interval=T.unsafe(nil)); end
  CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  NOT_CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Support
end

class Selenium::WebDriver::Support::AbstractEventListener
  def after_change_value_of(element, driver); end

  def after_click(element, driver); end

  def after_close(driver); end

  def after_execute_script(script, driver); end

  def after_find(by, what, driver); end

  def after_navigate_back(driver); end

  def after_navigate_forward(driver); end

  def after_navigate_to(url, driver); end

  def after_quit(driver); end

  def before_change_value_of(element, driver); end

  def before_click(element, driver); end

  def before_close(driver); end

  def before_execute_script(script, driver); end

  def before_find(by, what, driver); end

  def before_navigate_back(driver); end

  def before_navigate_forward(driver); end

  def before_navigate_to(url, driver); end

  def before_quit(driver); end
end

class Selenium::WebDriver::Support::AbstractEventListener
end

class Selenium::WebDriver::Support::BlockEventListener
  def initialize(callback); end

  def method_missing(meth, *args); end
end

class Selenium::WebDriver::Support::BlockEventListener
end

class Selenium::WebDriver::Support::Color
  def ==(other); end

  def alpha(); end

  def blue(); end

  def eql?(other); end

  def green(); end

  def hex(); end

  def initialize(red, green, blue, alpha=T.unsafe(nil)); end

  def red(); end

  def rgb(); end

  def rgba(); end
  HEX3_PATTERN = ::T.let(nil, ::T.untyped)
  HEX_PATTERN = ::T.let(nil, ::T.untyped)
  HSLA_PATTERN = ::T.let(nil, ::T.untyped)
  HSL_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PCT_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PCT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Support::Color
  def self.from_hsl(h, s, l, a); end

  def self.from_string(str); end

  def self.hue_to_rgb(lum1, lum2, hue); end
end

module Selenium::WebDriver::Support::Escaper
end

module Selenium::WebDriver::Support::Escaper
  def self.escape(str); end
end

class Selenium::WebDriver::Support::EventFiringBridge
  def clear_element(ref); end

  def click_element(ref); end

  def close(); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def initialize(delegate, listener); end

  def quit(); end

  def send_keys_to_element(ref, keys); end
end

class Selenium::WebDriver::Support::EventFiringBridge
end

class Selenium::WebDriver::Support::RelativeLocator
  def as_json(); end

  def initialize(locator); end
  KEYS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Support::RelativeLocator
end

class Selenium::WebDriver::Support::Select
  def deselect_all(); end

  def deselect_by(how, what); end

  def first_selected_option(); end

  def initialize(element); end

  def multiple?(); end

  def options(); end

  def select_all(); end

  def select_by(how, what); end

  def selected_options(); end
end

class Selenium::WebDriver::Support::Select
end

module Selenium::WebDriver::Support
end

module Selenium::WebDriver::TakesScreenshot
  def save_screenshot(png_path, full_page: T.unsafe(nil)); end

  def screenshot_as(format, full_page: T.unsafe(nil)); end
end

class Selenium::WebDriver::TargetLocator
  def active_element(); end

  def alert(); end

  def default_content(); end

  def frame(id); end

  def initialize(bridge); end

  def new_window(type=T.unsafe(nil)); end

  def parent_frame(); end

  def window(id); end
end

class Selenium::WebDriver::Timeouts
  def implicit_wait(); end

  def implicit_wait=(seconds); end

  def initialize(bridge); end

  def page_load(); end

  def page_load=(seconds); end

  def script(); end

  def script=(seconds); end

  def script_timeout(); end

  def script_timeout=(seconds); end
end

class Selenium::WebDriver::VirtualAuthenticator
  def add_credential(credential); end

  def credentials(); end

  def initialize(bridge, authenticator_id, options); end

  def options(); end

  def remove!(); end

  def remove_all_credentials(); end

  def remove_credential(credential_id); end

  def user_verified=(verified); end

  def valid?(); end
end

class Selenium::WebDriver::VirtualAuthenticatorOptions
  def as_json(*arg); end

  def initialize(**opts); end

  def protocol(); end

  def protocol=(protocol); end

  def resident_key(); end

  def resident_key=(resident_key); end

  def resident_key?(); end

  def transport(); end

  def transport=(transport); end

  def user_consenting(); end

  def user_consenting=(user_consenting); end

  def user_consenting?(); end

  def user_verification(); end

  def user_verification=(user_verification); end

  def user_verification?(); end

  def user_verified(); end

  def user_verified=(user_verified); end

  def user_verified?(); end
  PROTOCOL = ::T.let(nil, ::T.untyped)
  TRANSPORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Wait
  def initialize(opts=T.unsafe(nil)); end

  def until(); end
  DEFAULT_INTERVAL = ::T.let(nil, ::T.untyped)
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::WebSocketConnection
  def callbacks(); end

  def close(); end

  def initialize(url:); end

  def send_cmd(**payload); end
  CONNECTION_ERRORS = ::T.let(nil, ::T.untyped)
  MAX_LOG_MESSAGE_SIZE = ::T.let(nil, ::T.untyped)
  RESPONSE_WAIT_INTERVAL = ::T.let(nil, ::T.untyped)
  RESPONSE_WAIT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::WheelActions
  def default_scroll_duration(); end

  def default_scroll_duration=(default_scroll_duration); end

  def scroll_by(delta_x, delta_y, device: T.unsafe(nil)); end

  def scroll_from(scroll_origin, delta_x, delta_y, device: T.unsafe(nil)); end

  def scroll_to(element, device: T.unsafe(nil)); end
end

class Selenium::WebDriver::WheelActions::ScrollOrigin
  def initialize(origin, x_offset, y_offset); end

  def origin(); end

  def x_offset(); end

  def y_offset(); end
end

class Selenium::WebDriver::WheelActions::ScrollOrigin
  def self.element(element, x_offset=T.unsafe(nil), y_offset=T.unsafe(nil)); end

  def self.viewport(x_offset=T.unsafe(nil), y_offset=T.unsafe(nil)); end
end

class Selenium::WebDriver::Window
  def full_screen(); end

  def initialize(bridge); end

  def maximize(); end

  def minimize(); end

  def move_to(x, y); end

  def position(); end

  def position=(point); end

  def rect(); end

  def rect=(rectangle); end

  def resize_to(width, height); end

  def size(); end

  def size=(dimension); end
end

module Selenium::WebDriver::Zipper
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Zipper
  def self.unzip(path); end

  def self.zip(path); end

  def self.zip_file(path); end
end

module Selenium::WebDriver
  def self.for(*args); end

  def self.logger(**opts); end

  def self.root(); end
end

class Sermon
  include ::Sermon::GeneratedAttributeMethods
  include ::Sermon::GeneratedAssociationMethods
  def autosave_associated_records_for_homilist(*args); end

  def autosave_associated_records_for_rich_text_content(*args); end

  def content(); end

  def content=(body); end

  def content?(); end

  def validate_associated_records_for_rich_text_content(*args); end
end

module Sermon::GeneratedAssociationMethods
  def build_homilist(*args, &block); end

  def build_rich_text_content(*args, &block); end

  def create_homilist(*args, &block); end

  def create_homilist!(*args, &block); end

  def create_rich_text_content(*args, &block); end

  def create_rich_text_content!(*args, &block); end

  def homilist(); end

  def homilist=(value); end

  def homilist_changed?(); end

  def homilist_previously_changed?(); end

  def reload_homilist(); end

  def reload_rich_text_content(); end

  def reset_homilist(); end

  def reset_rich_text_content(); end

  def rich_text_content(); end

  def rich_text_content=(value); end
end

module Sermon::GeneratedAssociationMethods
end

module Sermon::GeneratedAttributeMethods
end

module Sermon::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Sermon
  def self.with_rich_text_content(*args, **arg); end

  def self.with_rich_text_content_and_embeds(*args, **arg); end
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Shellany
  VERSION = ::T.let(nil, ::T.untyped)
end

class Shellany::Sheller
  def initialize(*args); end

  def ok?(); end

  def ran?(); end

  def run(); end

  def status(); end

  def stderr(); end

  def stdout(); end
end

class Shellany::Sheller
  def self._shellize_if_needed(args); end

  def self._system_with_capture(*args); end

  def self._system_with_no_capture(*args); end

  def self.run(*args); end

  def self.stderr(*args); end

  def self.stdout(*args); end

  def self.system(*args); end
end

module Shellwords
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sidekiq
  MAJOR = ::T.let(nil, ::T.untyped)
end

Sidekiq::ClientMiddleware = Sidekiq::ServerMiddleware

class Sidekiq::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
  ERROR_HANDLER = ::T.let(nil, ::T.untyped)
end

module Sidekiq::JobUtil
  TRANSIENT_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

module Sidekiq::LoggingUtils
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Sidekiq::RedisClientAdapter
  DEPRECATED_COMMANDS = ::T.let(nil, ::T.untyped)
end

Sidekiq::RedisClientAdapter::BaseError = RedisClient::Error

Sidekiq::RedisClientAdapter::CommandError = RedisClient::CommandError

module Sidekiq::RedisClientAdapter::CompatMethods
  USED_COMMANDS = ::T.let(nil, ::T.untyped)
end

class SignedGlobalID
  def expires_at(); end

  def purpose(); end

  def to_s(); end

  def verifier(); end
end

class SignedGlobalID
  def self.expires_in(); end

  def self.expires_in=(expires_in); end

  def self.parse(sgid, options=T.unsafe(nil)); end

  def self.pick_purpose(options); end

  def self.pick_verifier(options); end

  def self.verifier(); end

  def self.verifier=(verifier); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module SimpleForm
  CUSTOM_INPUT_DEPRECATION_WARN = ::T.let(nil, ::T.untyped)
  FILE_METHODS_DEPRECATION_WARN = ::T.let(nil, ::T.untyped)
end

module SimpleForm::Components
end

module SimpleForm::Components::Errors
  def error(wrapper_options=T.unsafe(nil)); end

  def error_method(); end

  def error_text(); end

  def errors(); end

  def errors_on_association(); end

  def errors_on_attribute(); end

  def full_error(wrapper_options=T.unsafe(nil)); end

  def full_error_text(); end

  def full_errors(); end

  def full_errors_on_association(); end

  def full_errors_on_attribute(); end

  def has_custom_error?(); end

  def has_errors?(); end

  def has_value?(); end

  def object_with_errors?(); end

  def valid?(); end
end

module SimpleForm::Components::Errors
end

module SimpleForm::Components::HTML5
  def has_required?(); end

  def html5(wrapper_options=T.unsafe(nil)); end

  def html5?(); end

  def initialize(*arg); end

  def input_html_aria_required_option(); end

  def input_html_required_option(); end
end

module SimpleForm::Components::HTML5
end

module SimpleForm::Components::Hints
  def has_hint?(); end

  def hint(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Hints
end

module SimpleForm::Components::LabelInput
  def label_input(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::LabelInput
  extend ::ActiveSupport::Concern
end

module SimpleForm::Components::Labels
  def generate_label_for_attribute?(); end

  def label(wrapper_options=T.unsafe(nil)); end

  def label_html_options(); end

  def label_target(); end

  def label_text(wrapper_options=T.unsafe(nil)); end

  def label_translation(); end

  def raw_label_text(); end

  def required_label_text(); end
end

module SimpleForm::Components::Labels::ClassMethods
  def translate_required_html(); end

  def translate_required_mark(); end

  def translate_required_text(); end
end

module SimpleForm::Components::Labels::ClassMethods
end

module SimpleForm::Components::Labels
  extend ::ActiveSupport::Concern
end

module SimpleForm::Components::Maxlength
  def maxlength(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Maxlength
end

module SimpleForm::Components::MinMax
  def min_max(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::MinMax
end

module SimpleForm::Components::Minlength
  def minlength(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Minlength
end

module SimpleForm::Components::Pattern
  def pattern(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Pattern
end

module SimpleForm::Components::Placeholders
  def placeholder(wrapper_options=T.unsafe(nil)); end

  def placeholder_text(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Placeholders
end

module SimpleForm::Components::Readonly
  def readonly(wrapper_options=T.unsafe(nil)); end
end

module SimpleForm::Components::Readonly
end

module SimpleForm::Components
  extend ::ActiveSupport::Autoload
end

class SimpleForm::ErrorNotification
  def error_message(); end

  def error_notification_tag(); end

  def errors(); end

  def has_errors?(); end

  def html_options(); end

  def initialize(builder, options); end

  def object(*arg, **arg1, &arg2); end

  def object_name(*arg, **arg1, &arg2); end

  def render(); end

  def template(*arg, **arg1, &arg2); end

  def translate_error_notification(); end
end

class SimpleForm::ErrorNotification
end

class SimpleForm::FormBuilder
  include ::SimpleForm::Inputs
  def association(association, options=T.unsafe(nil), &block); end

  def attribute(attribute_name, options=T.unsafe(nil), &block); end

  def button(type, *args, &block); end

  def button_button(value=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def error(attribute_name, options=T.unsafe(nil)); end

  def error_notification(options=T.unsafe(nil)); end

  def full_error(attribute_name, options=T.unsafe(nil)); end

  def hint(attribute_name, options=T.unsafe(nil)); end

  def initialize(*arg); end

  def input(attribute_name, options=T.unsafe(nil), &block); end

  def input_field(attribute_name, options=T.unsafe(nil)); end

  def label(attribute_name, *args); end

  def lookup_action(); end

  def lookup_model_names(); end

  def mappings(); end

  def mappings=(mappings); end

  def mappings?(); end

  def template(); end

  def wrapper(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class SimpleForm::FormBuilder
  def self.discovery_cache(); end

  def self.mappings(); end

  def self.mappings=(value); end

  def self.mappings?(); end
end

module SimpleForm::Helpers
end

module SimpleForm::Helpers::Autofocus
end

module SimpleForm::Helpers::Autofocus
end

module SimpleForm::Helpers::Disabled
end

module SimpleForm::Helpers::Disabled
end

module SimpleForm::Helpers::Readonly
end

module SimpleForm::Helpers::Readonly
end

module SimpleForm::Helpers::Required
end

module SimpleForm::Helpers::Required
end

module SimpleForm::Helpers::Validators
  def has_validators?(); end
end

module SimpleForm::Helpers::Validators
end

module SimpleForm::Helpers
end

module SimpleForm::Inputs
end

class SimpleForm::Inputs::Base
  include ::ERB::Util
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::CoreExt::ERBUtil
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::SimpleForm::Helpers::Autofocus
  include ::SimpleForm::Helpers::Disabled
  include ::SimpleForm::Helpers::Readonly
  include ::SimpleForm::Helpers::Required
  include ::SimpleForm::Helpers::Validators
  include ::SimpleForm::Components::Errors
  include ::SimpleForm::Components::Hints
  include ::SimpleForm::Components::HTML5
  include ::SimpleForm::Components::LabelInput
  include ::SimpleForm::Components::Labels
  include ::SimpleForm::Components::Maxlength
  include ::SimpleForm::Components::Minlength
  include ::SimpleForm::Components::MinMax
  include ::SimpleForm::Components::Pattern
  include ::SimpleForm::Components::Placeholders
  include ::SimpleForm::Components::Readonly
  def additional_classes(); end

  def attribute_name(); end

  def column(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(val); end

  def default_options(); end

  def default_options=(default_options); end

  def default_options?(); end

  def html_classes(); end

  def initialize(builder, attribute_name, column, input_type, options=T.unsafe(nil)); end

  def input(wrapper_options=T.unsafe(nil)); end

  def input_class(); end

  def input_html_classes(); end

  def input_html_options(); end

  def input_options(); end

  def input_type(); end

  def lookup_action(*arg, **arg1, &arg2); end

  def lookup_model_names(*arg, **arg1, &arg2); end

  def object(*arg, **arg1, &arg2); end

  def object_name(*arg, **arg1, &arg2); end

  def options(); end

  def reflection(); end

  def template(*arg, **arg1, &arg2); end
end

class SimpleForm::Inputs::Base
  extend ::SimpleForm::Components::Labels::ClassMethods
  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(val); end

  def self.default_options(); end

  def self.default_options=(value); end

  def self.default_options?(); end

  def self.disable(*keys); end

  def self.enable(*keys); end
end

class SimpleForm::Inputs::BlockInput
  def initialize(*args, &block); end
end

class SimpleForm::Inputs::BlockInput
end

class SimpleForm::Inputs::BooleanInput
end

class SimpleForm::Inputs::BooleanInput
end

class SimpleForm::Inputs::CollectionCheckBoxesInput
end

class SimpleForm::Inputs::CollectionCheckBoxesInput
end

class SimpleForm::Inputs::CollectionInput
  BASIC_OBJECT_CLASSES = ::T.let(nil, ::T.untyped)
end

class SimpleForm::Inputs::CollectionInput
  def self.boolean_collection(); end
end

class SimpleForm::Inputs::CollectionRadioButtonsInput
  def apply_default_collection_options!(options); end

  def build_nested_boolean_style_item_tag(collection_builder); end

  def collection_block_for_nested_boolean_style(); end

  def item_wrapper_class(); end
end

class SimpleForm::Inputs::CollectionRadioButtonsInput
end

class SimpleForm::Inputs::CollectionSelectInput
end

class SimpleForm::Inputs::CollectionSelectInput
end

class SimpleForm::Inputs::ColorInput
end

class SimpleForm::Inputs::ColorInput
end

class SimpleForm::Inputs::DateTimeInput
end

class SimpleForm::Inputs::DateTimeInput
end

class SimpleForm::Inputs::FileInput
end

class SimpleForm::Inputs::FileInput
end

class SimpleForm::Inputs::GroupedCollectionSelectInput
end

class SimpleForm::Inputs::GroupedCollectionSelectInput
end

class SimpleForm::Inputs::HiddenInput
end

class SimpleForm::Inputs::HiddenInput
end

class SimpleForm::Inputs::NumericInput
end

class SimpleForm::Inputs::NumericInput
end

class SimpleForm::Inputs::PasswordInput
end

class SimpleForm::Inputs::PasswordInput
end

class SimpleForm::Inputs::PriorityInput
  def country_input(merged_input_options); end

  def input_priority(); end

  def time_zone_input(merged_input_options); end
end

class SimpleForm::Inputs::PriorityInput
end

class SimpleForm::Inputs::RangeInput
end

class SimpleForm::Inputs::RangeInput
end

class SimpleForm::Inputs::RichTextAreaInput
end

class SimpleForm::Inputs::RichTextAreaInput
end

class SimpleForm::Inputs::StringInput
end

class SimpleForm::Inputs::StringInput
end

class SimpleForm::Inputs::TextInput
end

class SimpleForm::Inputs::TextInput
end

module SimpleForm::Inputs
  extend ::ActiveSupport::Autoload
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

module Skiptrace
  VERSION = ::T.let(nil, ::T.untyped)
end

class Skiptrace::BindingLocations
  def initialize(locations, bindings); end
end

class Skiptrace::Location
  def absolute_path(); end

  def base_label(); end

  def initialize(location, binding); end

  def label(); end

  def lineno(); end
end

module Skiptrace
  def self.current_bindings(); end
end

class Socket
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

class Socket::ResolutionError
  def error_code(); end
end

class Socket::ResolutionError
end

module Solargraph
  VERSION = ::T.let(nil, ::T.untyped)
  VIEWS_PATH = ::T.let(nil, ::T.untyped)
  YARD_EXTENSION_FILE = ::T.let(nil, ::T.untyped)
end

class Solargraph::ApiMap
  include ::Solargraph::ApiMap::SourceToYard
  def bundled?(filename); end

  def catalog(bench); end

  def clip(cursor); end

  def clip_at(filename, position); end

  def core_pins(); end

  def cursor_at(filename, position); end

  def document(path); end

  def document_symbols(filename); end

  def get_class_variable_pins(namespace); end

  def get_complex_type_methods(complex_type, context=T.unsafe(nil), internal=T.unsafe(nil)); end

  def get_constants(namespace, *contexts); end

  def get_global_variable_pins(); end

  def get_instance_variable_pins(namespace, scope=T.unsafe(nil)); end

  def get_method_stack(fqns, name, scope: T.unsafe(nil)); end

  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil), deep: T.unsafe(nil)); end

  def get_path_pins(path); end

  def get_path_suggestions(path); end

  def get_symbols(); end

  def implicit(); end

  def index(pins); end

  def initialize(pins: T.unsafe(nil)); end

  def keyword_pins(); end

  def locate_pins(location); end

  def map(source); end

  def missing_docs(); end

  def named_macro(name); end

  def namespace_exists?(name, context=T.unsafe(nil)); end

  def namespaces(); end

  def pins(); end

  def qualify(namespace, context=T.unsafe(nil)); end

  def query_symbols(query); end

  def rebindable_method_names(); end

  def required(); end

  def search(query); end

  def source_map(filename); end

  def source_maps(); end

  def super_and_sub?(sup, sub); end

  def type_include?(host, mod); end

  def unresolved_requires(); end

  def yard_map(); end
end

module Solargraph::ApiMap::BundlerMethods
end

module Solargraph::ApiMap::BundlerMethods
  def self.require_from_bundle(directory); end
end

class Solargraph::ApiMap::Cache
  def clear(); end

  def empty?(); end

  def get_constants(namespace, context); end

  def get_methods(fqns, scope, visibility, deep); end

  def get_qualified_namespace(name, context); end

  def get_receiver_definition(path); end

  def receiver_defined?(path); end

  def set_constants(namespace, context, value); end

  def set_methods(fqns, scope, visibility, deep, value); end

  def set_qualified_namespace(name, context, value); end

  def set_receiver_definition(path, pin); end
end

class Solargraph::ApiMap::Cache
end

module Solargraph::ApiMap::SourceToYard
  def code_object_at(path); end

  def code_object_paths(); end

  def rake_yard(store); end
end

module Solargraph::ApiMap::SourceToYard
end

class Solargraph::ApiMap::Store
  def block_pins(); end

  def domains(fqns); end

  def get_class_variables(fqns); end

  def get_constants(fqns, visibility=T.unsafe(nil)); end

  def get_extends(fqns); end

  def get_includes(fqns); end

  def get_instance_variables(fqns, scope=T.unsafe(nil)); end

  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def get_path_pins(path); end

  def get_prepends(fqns); end

  def get_superclass(fqns); end

  def get_symbols(); end

  def initialize(pins=T.unsafe(nil)); end

  def method_pins(); end

  def named_macros(); end

  def namespace_exists?(fqns); end

  def namespace_pins(); end

  def namespaces(); end

  def pins(); end

  def pins_by_class(klass); end
end

class Solargraph::ApiMap::Store
end

class Solargraph::ApiMap
  def self.load(directory); end
end

class Solargraph::Bench
  def external_requires(); end

  def initialize(source_maps: T.unsafe(nil), workspace: T.unsafe(nil), external_requires: T.unsafe(nil)); end

  def source_maps(); end

  def workspace(); end
end

class Solargraph::Bench
end

module Solargraph::Cache
end

module Solargraph::Cache
  def self.base_dir(); end

  def self.clear(); end

  def self.load(*path); end

  def self.save(*path, pins); end

  def self.work_dir(); end
end

class Solargraph::ComplexType
  def [](index); end

  def all?(&block); end

  def all_params(); end

  def any?(&block); end

  def each(&block); end

  def each_unique_type(&block); end

  def first(); end

  def initialize(types=T.unsafe(nil)); end

  def length(); end

  def map(&block); end

  def method_missing(name, *args, &block); end

  def namespace(); end

  def nullable?(); end

  def parameterized?(); end

  def qualify(api_map, context=T.unsafe(nil)); end

  def resolve_parameters(definitions, context); end

  def select(&block); end

  def self_to(dst); end

  def selfy?(); end

  def to_rbs(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  NIL = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  SELF = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module Solargraph::ComplexType::TypeMethods
  def ==(other); end

  def defined?(); end

  def duck_type?(); end

  def each_unique_type(&block); end

  def fixed_parameters?(); end

  def hash_parameters?(); end

  def key_types(); end

  def list_parameters?(); end

  def name(); end

  def namespace(); end

  def nil_type?(); end

  def parameters?(); end

  def qualify(api_map, context=T.unsafe(nil)); end

  def rooted?(); end

  def scope(); end

  def substring(); end

  def subtypes(); end

  def tag(); end

  def undefined?(); end

  def value_types(); end

  def void?(); end
end

module Solargraph::ComplexType::TypeMethods
end

class Solargraph::ComplexType::UniqueType
  include ::Solargraph::ComplexType::TypeMethods
  def all_params(); end

  def initialize(name, substring=T.unsafe(nil)); end

  def parameterized?(); end

  def resolve_parameters(definitions, context); end

  def self_to(dst); end

  def selfy?(); end

  def to_rbs(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Solargraph::ComplexType::UniqueType
end

class Solargraph::ComplexType
  def self.parse(*strings, partial: T.unsafe(nil)); end

  def self.try_parse(*strings); end
end

module Solargraph::Convention
end

class Solargraph::Convention::Base
  def global(yard_map); end

  def local(source_map); end
  EMPTY_ENVIRON = ::T.let(nil, ::T.untyped)
end

class Solargraph::Convention::Base
end

class Solargraph::Convention::Gemfile
end

class Solargraph::Convention::Gemfile
end

class Solargraph::Convention::Gemspec
end

class Solargraph::Convention::Gemspec
end

class Solargraph::Convention::Rakefile
end

class Solargraph::Convention::Rakefile
end

class Solargraph::Convention::Rspec
end

class Solargraph::Convention::Rspec
end

module Solargraph::Convention
  def self.for_global(yard_map); end

  def self.for_local(source_map); end

  def self.register(convention); end
end

module Solargraph::Diagnostics
end

class Solargraph::Diagnostics::Base
  def args(); end

  def diagnose(source, api_map); end

  def initialize(*args); end
end

class Solargraph::Diagnostics::Base
end

class Solargraph::Diagnostics::RequireNotFound
end

class Solargraph::Diagnostics::RequireNotFound
end

class Solargraph::Diagnostics::Rubocop
  include ::Solargraph::Diagnostics::RubocopHelpers
  def diagnose(source, _api_map); end
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Diagnostics::Rubocop
end

module Solargraph::Diagnostics::RubocopHelpers
end

module Solargraph::Diagnostics::RubocopHelpers
  def self.fix_drive_letter(path); end

  def self.generate_options(filename, code); end

  def self.redirect_stdout(); end

  def self.require_rubocop(version=T.unsafe(nil)); end
end

module Solargraph::Diagnostics::Severities
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module Solargraph::Diagnostics::Severities
end

class Solargraph::Diagnostics::TypeCheck
end

class Solargraph::Diagnostics::TypeCheck
end

class Solargraph::Diagnostics::UpdateErrors
end

class Solargraph::Diagnostics::UpdateErrors
end

module Solargraph::Diagnostics
  def self.register(name, klass); end

  def self.reporter(name); end

  def self.reporters(); end
end

class Solargraph::Documentor
  def document(); end

  def initialize(directory, rebuild: T.unsafe(nil), out: T.unsafe(nil)); end
  RDOC_GEMS = ::T.let(nil, ::T.untyped)
end

class Solargraph::Documentor
  def self.specs_from_bundle(directory); end
end

class Solargraph::Environ
  def clear(); end

  def domains(); end

  def initialize(requires: T.unsafe(nil), domains: T.unsafe(nil), pins: T.unsafe(nil)); end

  def merge(other); end

  def pins(); end

  def requires(); end
end

class Solargraph::Environ
end

module Solargraph::LanguageServer
end

module Solargraph::LanguageServer::CompletionItemKinds
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::CompletionItemKinds
end

module Solargraph::LanguageServer::ErrorCodes
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::ErrorCodes
end

class Solargraph::LanguageServer::Host
  include ::Solargraph::LanguageServer::UriHelpers
  include ::Solargraph::Logging
  include ::Solargraph::LanguageServer::Host::Dispatch
  include ::Observable
  def allow_registration(method); end

  def can_register?(method); end

  def cancel(id); end

  def cancel?(id); end

  def catalog(); end

  def change(params); end

  def clear(id); end

  def client_capabilities(); end

  def client_capabilities=(client_capabilities); end

  def close(uri); end

  def completions_at(uri, line, column); end

  def configure(update); end

  def create(*uris); end

  def default_configuration(); end

  def definitions_at(uri, line, column); end

  def delete(*uris); end

  def diagnose(uri); end

  def document(query); end

  def document_symbols(uri); end

  def flush(); end

  def folders(); end

  def folding_ranges(uri); end

  def formatter_config(uri); end

  def has_pending_completions?(); end

  def locate_pins(params); end

  def open(uri, text, version); end

  def open?(uri); end

  def open_from_disk(uri); end

  def options(); end

  def pending_requests(); end

  def prepare(directory, name=T.unsafe(nil)); end

  def prepare_folders(array); end

  def process(request); end

  def query_symbols(query); end

  def queue(message); end

  def read_text(uri); end

  def receive(request); end

  def references_from(uri, line, column, strip: T.unsafe(nil), only: T.unsafe(nil)); end

  def register_capabilities(methods); end

  def registered?(method); end

  def remove(directory); end

  def remove_folders(array); end

  def search(query); end

  def send_notification(method, params); end

  def send_request(method, params, &block); end

  def show_message(text, type=T.unsafe(nil)); end

  def show_message_request(text, type, actions, &block); end

  def signatures_at(uri, line, column); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def synchronizing?(); end

  def unregister_capabilities(methods); end
end

class Solargraph::LanguageServer::Host::Cataloger
  def initialize(host); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::Cataloger
end

class Solargraph::LanguageServer::Host::Diagnoser
  def initialize(host); end

  def schedule(uri); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::Diagnoser
end

module Solargraph::LanguageServer::Host::Dispatch
  def explicit_library_for(uri); end

  def generic_library(); end

  def generic_library_for(uri); end

  def implicit_library_for(uri); end

  def libraries(); end

  def library_for(uri); end

  def sources(); end

  def update_libraries(uri); end
end

module Solargraph::LanguageServer::Host::Dispatch
end

class Solargraph::LanguageServer::Host::MessageWorker
  def initialize(host); end

  def messages(); end

  def queue(message); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::MessageWorker
end

class Solargraph::LanguageServer::Host::Sources
  include ::Observable
  include ::Solargraph::LanguageServer::UriHelpers
  def add_uri(uri); end

  def async_update(uri, updater); end

  def clear(); end

  def close(uri); end

  def find(uri); end

  def include?(uri); end

  def next_uri(); end

  def open(uri, text, version); end

  def open_from_disk(uri); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end

  def update(uri, updater); end
end

class Solargraph::LanguageServer::Host::Sources
end

class Solargraph::LanguageServer::Host
end

module Solargraph::LanguageServer::Message
end

class Solargraph::LanguageServer::Message::Base
  def error(); end

  def host(); end

  def id(); end

  def initialize(host, request); end

  def method(); end

  def params(); end

  def post_initialize(); end

  def process(); end

  def request(); end

  def result(); end

  def send_response(); end

  def set_error(code, message); end

  def set_result(data); end
end

class Solargraph::LanguageServer::Message::Base
end

class Solargraph::LanguageServer::Message::CancelRequest
end

class Solargraph::LanguageServer::Message::CancelRequest
end

module Solargraph::LanguageServer::Message::CompletionItem
end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve
end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve
end

module Solargraph::LanguageServer::Message::CompletionItem
end

class Solargraph::LanguageServer::Message::ExitNotification
end

class Solargraph::LanguageServer::Message::ExitNotification
end

module Solargraph::LanguageServer::Message::Extended
end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion
  def initialize(host, request, current: T.unsafe(nil), available: T.unsafe(nil)); end
  GEM_ZERO = ::T.let(nil, ::T.untyped)
end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion
  def self.fetcher(); end

  def self.fetcher=(obj); end
end

class Solargraph::LanguageServer::Message::Extended::Document
end

class Solargraph::LanguageServer::Message::Extended::Document
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore
end

class Solargraph::LanguageServer::Message::Extended::Environment
end

class Solargraph::LanguageServer::Message::Extended::Environment
end

class Solargraph::LanguageServer::Message::Extended::Search
end

class Solargraph::LanguageServer::Message::Extended::Search
end

module Solargraph::LanguageServer::Message::Extended
end

class Solargraph::LanguageServer::Message::Initialize
end

class Solargraph::LanguageServer::Message::Initialize
end

class Solargraph::LanguageServer::Message::Initialized
end

class Solargraph::LanguageServer::Message::Initialized
end

class Solargraph::LanguageServer::Message::MethodNotFound
end

class Solargraph::LanguageServer::Message::MethodNotFound
end

class Solargraph::LanguageServer::Message::MethodNotImplemented
end

class Solargraph::LanguageServer::Message::MethodNotImplemented
end

class Solargraph::LanguageServer::Message::Shutdown
end

class Solargraph::LanguageServer::Message::Shutdown
end

module Solargraph::LanguageServer::Message::TextDocument
end

class Solargraph::LanguageServer::Message::TextDocument::Base
  include ::Solargraph::LanguageServer::UriHelpers
  def filename(); end
end

class Solargraph::LanguageServer::Message::TextDocument::Base
end

class Solargraph::LanguageServer::Message::TextDocument::Completion
  def empty_result(incomplete=T.unsafe(nil)); end
end

class Solargraph::LanguageServer::Message::TextDocument::Completion
end

class Solargraph::LanguageServer::Message::TextDocument::Definition
end

class Solargraph::LanguageServer::Message::TextDocument::Definition
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentHighlight
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentHighlight
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol
  include ::Solargraph::LanguageServer::UriHelpers
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting
  include ::Solargraph::Diagnostics::RubocopHelpers
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting
end

class Solargraph::LanguageServer::Message::TextDocument::Hover
end

class Solargraph::LanguageServer::Message::TextDocument::Hover
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename
end

class Solargraph::LanguageServer::Message::TextDocument::References
end

class Solargraph::LanguageServer::Message::TextDocument::References
end

class Solargraph::LanguageServer::Message::TextDocument::Rename
end

class Solargraph::LanguageServer::Message::TextDocument::Rename
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp
end

module Solargraph::LanguageServer::Message::TextDocument
end

module Solargraph::LanguageServer::Message::Workspace
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles
  include ::Solargraph::LanguageServer::UriHelpers
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol
  include ::Solargraph::LanguageServer::UriHelpers
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol
end

module Solargraph::LanguageServer::Message::Workspace
end

module Solargraph::LanguageServer::Message
  def self.register(path, message_class); end

  def self.select(path); end
end

module Solargraph::LanguageServer::MessageTypes
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::MessageTypes
end

class Solargraph::LanguageServer::Request
  def initialize(id, &block); end

  def process(result); end

  def send_response(); end
end

class Solargraph::LanguageServer::Request
end

module Solargraph::LanguageServer::SymbolKinds
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::SymbolKinds
end

module Solargraph::LanguageServer::Transport
end

module Solargraph::LanguageServer::Transport::Adapter
  def closing(); end

  def opening(); end

  def receiving(data); end

  def update(); end
end

module Solargraph::LanguageServer::Transport::Adapter
end

class Solargraph::LanguageServer::Transport::DataReader
  def receive(data); end

  def set_message_handler(&block); end
end

class Solargraph::LanguageServer::Transport::DataReader
end

module Solargraph::LanguageServer::Transport
end

module Solargraph::LanguageServer::UriHelpers
end

module Solargraph::LanguageServer::UriHelpers
  def self.decode(text); end

  def self.encode(text); end

  def self.file_to_uri(file); end

  def self.uri_to_file(uri); end
end

module Solargraph::LanguageServer
end

class Solargraph::Library
  include ::Solargraph::Logging
  def attach(source); end

  def attached?(filename); end

  def bench(); end

  def catalog(); end

  def close(filename); end

  def completions_at(filename, line, column); end

  def contain?(filename); end

  def create(filename, text); end

  def create_from_disk(*filenames); end

  def current(); end

  def definitions_at(filename, line, column); end

  def delete(*filenames); end

  def detach(filename); end

  def diagnose(filename); end

  def document(query); end

  def document_symbols(filename); end

  def external_requires(); end

  def folding_ranges(filename); end

  def get_path_pins(path); end

  def initialize(workspace=T.unsafe(nil), name=T.unsafe(nil)); end

  def locate_pins(location); end

  def locate_ref(location); end

  def map!(); end

  def mapped?(); end

  def merge(source); end

  def name(); end

  def next_map(); end

  def open?(filename); end

  def path_pins(path); end

  def pins(); end

  def query_symbols(query); end

  def read_text(filename); end

  def references_from(filename, line, column, strip: T.unsafe(nil), only: T.unsafe(nil)); end

  def search(query); end

  def signatures_at(filename, line, column); end

  def source_map_hash(); end

  def source_maps(); end

  def synchronized?(); end

  def workspace(); end
end

class Solargraph::Library
  def self.load(directory=T.unsafe(nil), name=T.unsafe(nil)); end
end

class Solargraph::Location
  def ==(other); end

  def filename(); end

  def initialize(filename, range); end

  def range(); end

  def to_hash(); end
end

class Solargraph::Location
end

module Solargraph::Logging
  DEFAULT_LOG_LEVEL = ::T.let(nil, ::T.untyped)
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
end

module Solargraph::Logging
  def self.logger(); end
end

class Solargraph::Page
  def initialize(directory=T.unsafe(nil)); end

  def render(template, layout: T.unsafe(nil), locals: T.unsafe(nil)); end
end

class Solargraph::Page
  def self.select_template(directories, name); end
end

module Solargraph::Parser
end

class Solargraph::Parser::CommentRipper
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def on_comment(*args); end

  def on_embdoc(*args); end

  def on_embdoc_beg(*args); end

  def on_embdoc_end(*args); end
end

class Solargraph::Parser::CommentRipper
end

module Solargraph::Parser::Legacy
end

module Solargraph::Parser::Legacy::ClassMethods
  def chain(*args); end

  def chain_string(*args); end

  def infer_literal_node_type(node); end

  def inner_node_references(name, top); end

  def is_ast_node?(node); end

  def map(source); end

  def node_range(node); end

  def parse(code, filename=T.unsafe(nil), line=T.unsafe(nil)); end

  def parse_with_comments(code, filename=T.unsafe(nil)); end

  def parser(); end

  def process_node(*args); end

  def references(source, name); end

  def returns_from(node); end

  def string_ranges(node); end

  def version(); end
end

module Solargraph::Parser::Legacy::ClassMethods
end

class Solargraph::Parser::Legacy::FlawedBuilder
end

class Solargraph::Parser::Legacy::FlawedBuilder
end

class Solargraph::Parser::Legacy::NodeChainer
  include ::Solargraph::Parser::Legacy::NodeMethods
  def chain(); end

  def initialize(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end
end

Solargraph::Parser::Legacy::NodeChainer::Chain = Solargraph::Source::Chain

class Solargraph::Parser::Legacy::NodeChainer
  def self.chain(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end

  def self.load_string(code); end
end

module Solargraph::Parser::Legacy::NodeMethods
  NIL_NODE = ::T.let(nil, ::T.untyped)
end

module Solargraph::Parser::Legacy::NodeMethods::DeepInference
end

module Solargraph::Parser::Legacy::NodeMethods::DeepInference
  def self.get_return_nodes(node); end
end

module Solargraph::Parser::Legacy::NodeMethods
  def self.any_splatted_call?(nodes); end

  def self.call_nodes_from(node); end

  def self.const_nodes_from(node); end

  def self.convert_hash(node); end

  def self.drill_signature(node, signature); end

  def self.find_recipient_node(cursor); end

  def self.get_node_end_position(node); end

  def self.get_node_start_position(node); end

  def self.infer_literal_node_type(node); end

  def self.pack_name(node); end

  def self.repaired_find_recipient_node(cursor); end

  def self.returns_from(node); end

  def self.splatted_call?(node); end

  def self.splatted_hash?(node); end

  def self.unpack_name(node); end
end

module Solargraph::Parser::Legacy::NodeProcessors
end

class Solargraph::Parser::Legacy::NodeProcessors::AliasNode
end

class Solargraph::Parser::Legacy::NodeProcessors::AliasNode
end

class Solargraph::Parser::Legacy::NodeProcessors::ArgsNode
end

class Solargraph::Parser::Legacy::NodeProcessors::ArgsNode
end

class Solargraph::Parser::Legacy::NodeProcessors::BeginNode
end

class Solargraph::Parser::Legacy::NodeProcessors::BeginNode
end

class Solargraph::Parser::Legacy::NodeProcessors::BlockNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::BlockNode
end

class Solargraph::Parser::Legacy::NodeProcessors::CasgnNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::CasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::CvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::CvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::DefNode
end

class Solargraph::Parser::Legacy::NodeProcessors::DefNode
end

class Solargraph::Parser::Legacy::NodeProcessors::DefsNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::DefsNode
end

class Solargraph::Parser::Legacy::NodeProcessors::GvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::GvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::IvasgnNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::IvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::LvasgnNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::LvasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::NamespaceNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::NamespaceNode
end

class Solargraph::Parser::Legacy::NodeProcessors::OrasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::OrasgnNode
end

class Solargraph::Parser::Legacy::NodeProcessors::ResbodyNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::ResbodyNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SclassNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SclassNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SendNode
  include ::Solargraph::Parser::Legacy::NodeMethods
end

class Solargraph::Parser::Legacy::NodeProcessors::SendNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SymNode
end

class Solargraph::Parser::Legacy::NodeProcessors::SymNode
end

module Solargraph::Parser::Legacy::NodeProcessors
end

module Solargraph::Parser::Legacy
end

Solargraph::Parser::NodeMethods = Solargraph::Parser::Rubyvm::NodeMethods

module Solargraph::Parser::NodeProcessor
end

class Solargraph::Parser::NodeProcessor::Base
  def initialize(node, region, pins, locals); end

  def locals(); end

  def node(); end

  def pins(); end

  def process(); end

  def region(); end
end

class Solargraph::Parser::NodeProcessor::Base
end

module Solargraph::Parser::NodeProcessor
  def self.process(node, region=T.unsafe(nil), pins=T.unsafe(nil), locals=T.unsafe(nil)); end

  def self.register(type, cls); end
end

class Solargraph::Parser::Region
  def closure(); end

  def code_for(node); end

  def filename(); end

  def initialize(source: T.unsafe(nil), closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil), lvars: T.unsafe(nil)); end

  def lvars(); end

  def scope(); end

  def source(); end

  def update(closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil), lvars: T.unsafe(nil)); end

  def visibility(); end
end

class Solargraph::Parser::Region
end

module Solargraph::Parser::Rubyvm
end

module Solargraph::Parser::Rubyvm::ClassMethods
  def chain(*args); end

  def chain_string(*args); end

  def infer_literal_node_type(node); end

  def inner_node_references(name, top); end

  def is_ast_node?(node); end

  def map(source); end

  def match_rubyvm_node_to_ref(top, name); end

  def node_range(node); end

  def parse(code, filename=T.unsafe(nil), line=T.unsafe(nil)); end

  def parse_with_comments(code, filename=T.unsafe(nil)); end

  def process_node(*args); end

  def recipient_node(tree); end

  def references(source, name); end

  def string_ranges(node); end

  def version(); end
end

module Solargraph::Parser::Rubyvm::ClassMethods
end

class Solargraph::Parser::Rubyvm::NodeChainer
  include ::Solargraph::Parser::Rubyvm::NodeMethods
  def chain(); end

  def initialize(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end
end

Solargraph::Parser::Rubyvm::NodeChainer::Chain = Solargraph::Source::Chain

class Solargraph::Parser::Rubyvm::NodeChainer
  def self.chain(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end

  def self.load_string(code); end
end

module Solargraph::Parser::Rubyvm::NodeMethods
end

module Solargraph::Parser::Rubyvm::NodeMethods::DeepInference
end

module Solargraph::Parser::Rubyvm::NodeMethods::DeepInference
  def self.get_return_nodes(node); end
end

module Solargraph::Parser::Rubyvm::NodeMethods
  def self.any_splatted_call?(nodes); end

  def self.call_nodes_from(node); end

  def self.const_nodes_from(node); end

  def self.convert_hash(node); end

  def self.find_recipient_node(cursor); end

  def self.infer_literal_node_type(node); end

  def self.maybe_adjust_cursor(cursor); end

  def self.node?(node); end

  def self.pack_name(node); end

  def self.returns_from(node); end

  def self.splatted_call?(node); end

  def self.splatted_hash?(node); end

  def self.splatted_node?(node); end

  def self.synchronized_find_recipient_node(cursor); end

  def self.unpack_name(node); end

  def self.unsynchronized_find_recipient_node(cursor); end
end

module Solargraph::Parser::Rubyvm::NodeProcessors
end

class Solargraph::Parser::Rubyvm::NodeProcessors::AliasNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::AliasNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ArgsNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ArgsNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BeginNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BeginNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BlockNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::BlockNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::CvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefsNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::DefsNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::GvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::GvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::IvasgnNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::IvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::KwArgNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::KwArgNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LitNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LitNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::LvasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::NamespaceNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::NamespaceNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OptArgNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OptArgNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OrasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::OrasgnNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ResbodyNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ResbodyNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SclassNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SclassNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ScopeNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::ScopeNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SendNode
  include ::Solargraph::Parser::Rubyvm::NodeMethods
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SendNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SymNode
end

class Solargraph::Parser::Rubyvm::NodeProcessors::SymNode
end

module Solargraph::Parser::Rubyvm::NodeProcessors
end

module Solargraph::Parser::Rubyvm
end

class Solargraph::Parser::Snippet
  def initialize(range, text); end

  def range(); end

  def text(); end
end

class Solargraph::Parser::Snippet
end

class Solargraph::Parser::SyntaxError
end

class Solargraph::Parser::SyntaxError
end

module Solargraph::Parser
  extend ::Solargraph::Parser::Rubyvm::ClassMethods
  def self.rubyvm?(); end
end

module Solargraph::Pin
  ROOT_PIN = ::T.let(nil, ::T.untyped)
end

class Solargraph::Pin::Base
  include ::Solargraph::Pin::Common
  include ::Solargraph::Pin::Conversions
  include ::Solargraph::Pin::Documenting
  def ==(other); end

  def code_object(); end

  def completion_item_kind(); end

  def deprecated?(); end

  def directives(); end

  def docstring(); end

  def filename(); end

  def identity(); end

  def infer(api_map); end

  def initialize(location: T.unsafe(nil), closure: T.unsafe(nil), name: T.unsafe(nil), comments: T.unsafe(nil)); end

  def macros(); end

  def maybe_directives?(); end

  def nearly?(other); end

  def probe(api_map); end

  def probed=(probed); end

  def probed?(); end

  def proxied=(proxied); end

  def proxied?(); end

  def proxy(return_type); end

  def realize(api_map); end

  def return_type=(return_type); end

  def source(); end

  def source=(source); end

  def symbol_kind(); end

  def try_merge!(pin); end

  def typify(api_map); end

  def variable?(); end
end

class Solargraph::Pin::Base
end

class Solargraph::Pin::BaseVariable
  include ::Solargraph::Parser::Rubyvm::NodeMethods
  def assignment(); end

  def initialize(assignment: T.unsafe(nil), **splat); end

  def nil_assignment?(); end
end

class Solargraph::Pin::BaseVariable
end

class Solargraph::Pin::Block
  def initialize(receiver: T.unsafe(nil), args: T.unsafe(nil), context: T.unsafe(nil), **splat); end

  def parameter_names(); end

  def parameters(); end

  def rebind(api_map); end

  def receiver(); end
end

class Solargraph::Pin::Block
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::Closure
  def gates(); end

  def initialize(scope: T.unsafe(nil), **splat); end

  def scope(); end
end

class Solargraph::Pin::Closure
end

module Solargraph::Pin::Common
  def binder(); end

  def closure(); end

  def comments(); end

  def context(); end

  def full_context(); end

  def location(); end

  def name(); end

  def namespace(); end

  def path(); end

  def return_type(); end
end

module Solargraph::Pin::Common
end

class Solargraph::Pin::Constant
  def initialize(visibility: T.unsafe(nil), **splat); end

  def visibility(); end
end

class Solargraph::Pin::Constant
end

module Solargraph::Pin::Conversions
  def completion_item(); end

  def detail(); end

  def link_documentation(); end

  def reset_conversions(); end

  def resolve_completion_item(); end

  def signature_help(); end

  def text_documentation(); end
end

module Solargraph::Pin::Conversions
end

module Solargraph::Pin::Documenting
  def documentation(); end
end

class Solargraph::Pin::Documenting::DocSection
  def code?(); end

  def concat(text); end

  def initialize(code); end

  def plaintext(); end
end

class Solargraph::Pin::Documenting::DocSection
end

module Solargraph::Pin::Documenting
end

class Solargraph::Pin::DuckMethod
end

class Solargraph::Pin::DuckMethod
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::InstanceVariable
  def scope(); end
end

class Solargraph::Pin::InstanceVariable
end

class Solargraph::Pin::Keyword
  def initialize(name); end
end

class Solargraph::Pin::Keyword
end

class Solargraph::Pin::KeywordParam
end

class Solargraph::Pin::KeywordParam
end

class Solargraph::Pin::LocalVariable
  def initialize(assignment: T.unsafe(nil), presence: T.unsafe(nil), **splat); end

  def visible_at?(other_closure, other_loc); end
end

class Solargraph::Pin::LocalVariable
end

class Solargraph::Pin::Method
  include ::Solargraph::Parser::Rubyvm::NodeMethods
  def anon_splat?(); end

  def attribute?(); end

  def explicit?(); end

  def initialize(visibility: T.unsafe(nil), explicit: T.unsafe(nil), parameters: T.unsafe(nil), node: T.unsafe(nil), attribute: T.unsafe(nil), signatures: T.unsafe(nil), anon_splat: T.unsafe(nil), **splat); end

  def node(); end

  def overloads(); end

  def parameter_names(); end

  def parameters(); end

  def signatures(); end

  def visibility(); end
end

class Solargraph::Pin::Method
end

class Solargraph::Pin::MethodAlias
  def initialize(scope: T.unsafe(nil), original: T.unsafe(nil), **splat); end

  def original(); end
end

class Solargraph::Pin::MethodAlias
end

class Solargraph::Pin::Namespace
  def domains(); end

  def initialize(type: T.unsafe(nil), visibility: T.unsafe(nil), gates: T.unsafe(nil), parameters: T.unsafe(nil), **splat); end

  def parameters(); end

  def type(); end

  def visibility(); end
end

class Solargraph::Pin::Namespace
end

class Solargraph::Pin::Parameter
  def asgn_code(); end

  def block?(); end

  def decl(); end

  def full(); end

  def index(); end

  def initialize(decl: T.unsafe(nil), asgn_code: T.unsafe(nil), return_type: T.unsafe(nil), **splat); end

  def keyword?(); end

  def kwrestarg?(); end

  def rest?(); end

  def restarg?(); end
end

class Solargraph::Pin::Parameter
end

class Solargraph::Pin::ProxyType
  def initialize(return_type: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::ProxyType
  def self.anonymous(return_type); end
end

class Solargraph::Pin::Reference
end

class Solargraph::Pin::Reference::Extend
end

class Solargraph::Pin::Reference::Extend
end

class Solargraph::Pin::Reference::Include
end

class Solargraph::Pin::Reference::Include
end

class Solargraph::Pin::Reference::Override
  def delete(); end

  def initialize(location, name, tags, delete=T.unsafe(nil)); end

  def tags(); end
end

class Solargraph::Pin::Reference::Override
  def self.from_comment(name, comment); end

  def self.method_return(name, *tags, delete: T.unsafe(nil)); end
end

class Solargraph::Pin::Reference::Prepend
end

class Solargraph::Pin::Reference::Prepend
end

class Solargraph::Pin::Reference::Require
  def initialize(location, name); end
end

class Solargraph::Pin::Reference::Require
end

class Solargraph::Pin::Reference::Superclass
end

class Solargraph::Pin::Reference::Superclass
end

class Solargraph::Pin::Reference
end

class Solargraph::Pin::Search
  def initialize(pins, query); end

  def results(); end
end

class Solargraph::Pin::Search::Result
  def initialize(match, pin); end

  def match(); end

  def pin(); end
end

class Solargraph::Pin::Search::Result
end

class Solargraph::Pin::Search
end

class Solargraph::Pin::Signature
  def block(); end

  def block?(); end

  def initialize(parameters, return_type, block=T.unsafe(nil)); end

  def parameters(); end

  def return_type(); end
end

class Solargraph::Pin::Signature
end

class Solargraph::Pin::Singleton
  def initialize(name: T.unsafe(nil), location: T.unsafe(nil), closure: T.unsafe(nil)); end
end

class Solargraph::Pin::Singleton
end

class Solargraph::Pin::Symbol
  def initialize(location, name); end

  def visibility(); end
end

class Solargraph::Pin::Symbol
end

module Solargraph::Pin
end

class Solargraph::Position
  def ==(other); end

  def character(); end

  def column(); end

  def initialize(line, character); end

  def line(); end

  def to_hash(); end
end

class Solargraph::Position
  def self.from_offset(text, offset); end

  def self.line_char_to_offset(text, line, character); end

  def self.normalize(object); end

  def self.to_offset(text, position); end
end

class Solargraph::Range
  def ==(other); end

  def contain?(position); end

  def ending(); end

  def include?(position); end

  def initialize(start, ending); end

  def start(); end

  def to_hash(); end
end

class Solargraph::Range
  def self.from_expr(expr); end

  def self.from_node(node); end

  def self.from_to(l1, c1, l2, c2); end
end

class Solargraph::RbsMap
  include ::Solargraph::RbsMap::Conversions
  def initialize(library); end

  def library(); end

  def path_pin(path); end

  def path_pins(path); end

  def repository(); end

  def resolved?(); end
end

module Solargraph::RbsMap::Conversions
  def pins(); end
  RBS_TO_YARD_TYPE = ::T.let(nil, ::T.untyped)
end

class Solargraph::RbsMap::Conversions::Context
  def initialize(visibility=T.unsafe(nil)); end

  def visibility(); end
end

class Solargraph::RbsMap::Conversions::Context
end

module Solargraph::RbsMap::Conversions
end

module Solargraph::RbsMap::CoreFills
  ALL = ::T.let(nil, ::T.untyped)
  CLASS_RETURN_TYPES = ::T.let(nil, ::T.untyped)
  ERRNOS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  YIELDPARAMS = ::T.let(nil, ::T.untyped)
  YIELDPARAM_SINGLE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

Solargraph::RbsMap::CoreFills::Override = Solargraph::Pin::Reference::Override

module Solargraph::RbsMap::CoreFills
end

class Solargraph::RbsMap::CoreMap
  include ::Solargraph::RbsMap::Conversions
end

class Solargraph::RbsMap::CoreMap
end

module Solargraph::RbsMap::CoreSigns
  SIGNATURE_MAP = ::T.let(nil, ::T.untyped)
end

Solargraph::RbsMap::CoreSigns::Override = Solargraph::Pin::Reference::Override

class Solargraph::RbsMap::CoreSigns::Stub
  def initialize(parameters, return_type); end

  def parameters(); end

  def return_type(); end
end

class Solargraph::RbsMap::CoreSigns::Stub
end

module Solargraph::RbsMap::CoreSigns
  def self.sign(path); end
end

class Solargraph::RbsMap::StdlibMap
end

class Solargraph::RbsMap::StdlibMap
end

class Solargraph::RbsMap
  def self.load(library); end
end

module Solargraph::ServerMethods
  def available_port(); end
end

module Solargraph::ServerMethods
end

class Solargraph::Shell
  include ::Solargraph::ServerMethods
  def available_cores(); end

  def bundle(); end

  def clear(); end

  def config(directory=T.unsafe(nil)); end

  def download_core(_version=T.unsafe(nil)); end

  def list(); end

  def list_cores(); end

  def rdoc(_gem, _version=T.unsafe(nil)); end

  def reporters(); end

  def scan(); end

  def socket(); end

  def stdio(); end

  def typecheck(*files); end

  def uncache(*gems); end

  def version(); end
end

class Solargraph::Shell
end

class Solargraph::Source
  include ::Solargraph::Source::EncodingFixes
  def associated_comments(); end

  def at(range); end

  def code(); end

  def code=(val); end

  def code_for(node); end

  def comment_at?(position); end

  def comments(); end

  def comments=(comments); end

  def comments_for(node); end

  def cursor_at(position); end

  def error_ranges(); end

  def error_ranges=(error_ranges); end

  def filename(); end

  def filename=(filename); end

  def finish_synchronize(); end

  def folding_ranges(); end

  def from_to(l1, c1, l2, c2); end

  def initialize(code, filename=T.unsafe(nil), version=T.unsafe(nil)); end

  def last_updater(); end

  def last_updater=(last_updater); end

  def location(); end

  def node(); end

  def node=(node); end

  def node_at(line, column); end

  def parsed=(parsed); end

  def parsed?(); end

  def references(name); end

  def repaired(); end

  def repaired=(repaired); end

  def repaired?(); end

  def start_synchronize(updater); end

  def string_at?(position); end

  def string_ranges(); end

  def synchronize(updater); end

  def synchronized=(synchronized); end

  def synchronized?(); end

  def tree_at(line, column); end

  def version(); end

  def version=(version); end
  FOLDING_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Source::Chain
  def base(); end

  def constant?(); end

  def define(api_map, name_pin, locals); end

  def defined?(); end

  def infer(api_map, name_pin, locals); end

  def initialize(links, node=T.unsafe(nil), splat=T.unsafe(nil)); end

  def links(); end

  def literal?(); end

  def node(); end

  def nullable?(); end

  def splat?(); end

  def undefined?(); end
  UNDEFINED_CALL = ::T.let(nil, ::T.untyped)
  UNDEFINED_CONSTANT = ::T.let(nil, ::T.untyped)
end

class Solargraph::Source::Chain::BlockVariable
end

class Solargraph::Source::Chain::BlockVariable
end

class Solargraph::Source::Chain::Call
  def arguments(); end

  def initialize(word, arguments=T.unsafe(nil), with_block=T.unsafe(nil)); end

  def with_block?(); end
end

class Solargraph::Source::Chain::Call
end

class Solargraph::Source::Chain::ClassVariable
end

class Solargraph::Source::Chain::ClassVariable
end

class Solargraph::Source::Chain::Constant
  def initialize(word); end
end

class Solargraph::Source::Chain::Constant
end

class Solargraph::Source::Chain::GlobalVariable
end

class Solargraph::Source::Chain::GlobalVariable
end

class Solargraph::Source::Chain::Hash
  def initialize(type, splatted=T.unsafe(nil)); end

  def splatted?(); end
end

class Solargraph::Source::Chain::Hash
end

class Solargraph::Source::Chain::Head
end

class Solargraph::Source::Chain::Head
end

class Solargraph::Source::Chain::InstanceVariable
end

class Solargraph::Source::Chain::InstanceVariable
end

class Solargraph::Source::Chain::Link
  def ==(other); end

  def clone_body(); end

  def clone_head(); end

  def constant?(); end

  def head?(); end

  def initialize(word=T.unsafe(nil)); end

  def last_context(); end

  def last_context=(last_context); end

  def mark_head(bool); end

  def nullable?(); end

  def resolve(api_map, name_pin, locals); end

  def undefined?(); end

  def word(); end
end

class Solargraph::Source::Chain::Link
end

class Solargraph::Source::Chain::Literal
  def initialize(type); end
end

class Solargraph::Source::Chain::Literal
end

class Solargraph::Source::Chain::Or
  def initialize(links); end
end

class Solargraph::Source::Chain::Or
end

class Solargraph::Source::Chain::QCall
end

class Solargraph::Source::Chain::QCall
end

class Solargraph::Source::Chain::Variable
end

class Solargraph::Source::Chain::Variable
end

class Solargraph::Source::Chain::ZSuper
  def initialize(word, with_block=T.unsafe(nil)); end
end

class Solargraph::Source::Chain::ZSuper
end

class Solargraph::Source::Chain
end

class Solargraph::Source::Change
  include ::Solargraph::Source::EncodingFixes
  def initialize(range, new_text); end

  def new_text(); end

  def range(); end

  def repair(text); end

  def write(text, nullable=T.unsafe(nil)); end
end

class Solargraph::Source::Change
end

class Solargraph::Source::Cursor
  def argument?(); end

  def chain(); end

  def comment?(); end

  def end_of_word(); end

  def filename(); end

  def initialize(source, position); end

  def node(); end

  def node_position(); end

  def offset(); end

  def position(); end

  def range(); end

  def receiver(); end

  def recipient(); end

  def recipient_node(); end

  def source(); end

  def start_of_constant?(); end

  def start_of_word(); end

  def string?(); end

  def word(); end
end

class Solargraph::Source::Cursor
end

module Solargraph::Source::EncodingFixes
end

module Solargraph::Source::EncodingFixes
  def self.normalize(string); end
end

class Solargraph::Source::SourceChainer
  def chain(); end

  def initialize(source, position); end
end

class Solargraph::Source::SourceChainer
  def self.chain(source, position); end
end

class Solargraph::Source::Updater
  def changes(); end

  def filename(); end

  def initialize(filename, version, changes); end

  def repair(text); end

  def version(); end

  def write(text, nullable=T.unsafe(nil)); end
end

class Solargraph::Source::Updater
end

class Solargraph::Source
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil), version=T.unsafe(nil)); end

  def self.parse_docstring(comments); end
end

class Solargraph::SourceMap
  def code(); end

  def cursor_at(position); end

  def document_symbols(); end

  def environ(); end

  def filename(); end

  def first_pin(path); end

  def initialize(source, pins, locals); end

  def locals(); end

  def locals_at(location); end

  def locate_block_pin(line, character); end

  def locate_named_path_pin(line, character); end

  def locate_pins(location); end

  def pins(); end

  def pins_by_class(klass); end

  def query_symbols(query); end

  def rebindable_method_names(); end

  def references(name); end

  def requires(); end

  def source(); end

  def try_merge!(other_map); end
end

class Solargraph::SourceMap::Clip
  def complete(); end

  def define(); end

  def gates(); end

  def in_block?(); end

  def infer(); end

  def initialize(api_map, cursor); end

  def locals(); end

  def signify(); end

  def translate(phrase); end
end

class Solargraph::SourceMap::Clip
end

class Solargraph::SourceMap::Completion
  def initialize(pins, range); end

  def pins(); end

  def range(); end
end

class Solargraph::SourceMap::Completion
end

class Solargraph::SourceMap::Mapper
  def closure_at(position); end

  def find_directive_line_number(comment, tag, start); end

  def map(source); end

  def no_empty_lines?(line1, line2); end

  def pins(); end

  def process_comment(source_position, comment_position, comment); end

  def process_comment_directives(); end

  def process_directive(source_position, comment_position, directive); end

  def remove_inline_comment_hashes(comment); end

  def unmap(filename, code); end
  DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Solargraph::SourceMap::Mapper
  def self.map(source); end
end

class Solargraph::SourceMap
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil)); end

  def self.map(source); end
end

class Solargraph::TypeChecker
  include ::Solargraph::TypeChecker::Checks
  include ::Solargraph::Parser::Rubyvm::NodeMethods
  def api_map(); end

  def filename(); end

  def initialize(filename, api_map: T.unsafe(nil), level: T.unsafe(nil)); end

  def problems(); end

  def rules(); end

  def source_map(); end
end

module Solargraph::TypeChecker::Checks
end

module Solargraph::TypeChecker::Checks
  def self.all_types_match?(api_map, inferred, expected); end

  def self.any_types_match?(api_map, expected, inferred); end

  def self.duck_types_match?(api_map, expected, inferred); end

  def self.either_way?(api_map, cls1, cls2); end

  def self.fuzz(type); end

  def self.types_match?(api_map, expected, inferred); end
end

class Solargraph::TypeChecker::ParamDef
  def initialize(name, type); end

  def name(); end

  def type(); end
end

class Solargraph::TypeChecker::ParamDef
  def self.from(pin); end
end

class Solargraph::TypeChecker::Problem
  def initialize(location, message, pin: T.unsafe(nil), suggestion: T.unsafe(nil)); end

  def location(); end

  def message(); end

  def pin(); end

  def suggestion(); end
end

class Solargraph::TypeChecker::Problem
end

class Solargraph::TypeChecker::Rules
  def ignore_all_undefined?(); end

  def initialize(level); end

  def level(); end

  def must_tag_or_infer?(); end

  def rank(); end

  def require_type_tags?(); end

  def validate_calls?(); end

  def validate_consts?(); end

  def validate_tags?(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Solargraph::TypeChecker::Rules
end

class Solargraph::TypeChecker
  def self.load(filename, level=T.unsafe(nil)); end

  def self.load_string(code, filename=T.unsafe(nil), level=T.unsafe(nil)); end
end

class Solargraph::Workspace
  def config(); end

  def directory(); end

  def filenames(); end

  def gemnames(); end

  def gemspec?(); end

  def gemspecs(); end

  def has_file?(filename); end

  def initialize(directory=T.unsafe(nil), config=T.unsafe(nil)); end

  def merge(*sources); end

  def remove(filename); end

  def require_paths(); end

  def source(filename); end

  def source_gems(); end

  def sources(); end

  def synchronize!(updater); end

  def would_require?(path); end
end

class Solargraph::Workspace::Config
  def allow?(filename); end

  def calculated(); end

  def directory(); end

  def domains(); end

  def excluded(); end

  def formatter(); end

  def included(); end

  def initialize(directory=T.unsafe(nil)); end

  def max_files(); end

  def plugins(); end

  def raw_data(); end

  def reporters(); end

  def require_paths(); end

  def required(); end
  MAX_FILES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Workspace::Config
end

class Solargraph::Workspace
end

class Solargraph::YardMap
  include ::Solargraph::ApiMap::BundlerMethods
  def base_required(); end

  def change(new_requires, new_directory, new_source_gems); end

  def directory(); end

  def initialize(required: T.unsafe(nil), directory: T.unsafe(nil), source_gems: T.unsafe(nil), with_dependencies: T.unsafe(nil)); end

  def load_yardoc(y); end

  def missing_docs(); end

  def path_pin(path); end

  def pins(); end

  def rebindable_method_names(); end

  def require_reference(path); end

  def required(); end

  def unresolved_requires(); end

  def with_dependencies=(with_dependencies); end

  def with_dependencies?(); end

  def yardocs(); end
end

class Solargraph::YardMap::Cache
  def get_path_pins(path); end

  def set_path_pins(path, pins); end
end

class Solargraph::YardMap::Cache
end

module Solargraph::YardMap::Helpers
end

module Solargraph::YardMap::Helpers
  def self.object_location(code_object, spec); end
end

class Solargraph::YardMap::Mapper
  def initialize(code_objects, spec=T.unsafe(nil)); end

  def map(); end
end

module Solargraph::YardMap::Mapper::ToConstant
end

module Solargraph::YardMap::Mapper::ToConstant
  extend ::Solargraph::YardMap::Helpers
  def self.make(code_object, closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

module Solargraph::YardMap::Mapper::ToMethod
end

module Solargraph::YardMap::Mapper::ToMethod
  extend ::Solargraph::YardMap::Helpers
  def self.make(code_object, name=T.unsafe(nil), scope=T.unsafe(nil), visibility=T.unsafe(nil), closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

module Solargraph::YardMap::Mapper::ToNamespace
end

module Solargraph::YardMap::Mapper::ToNamespace
  extend ::Solargraph::YardMap::Helpers
  def self.make(code_object, spec, closure=T.unsafe(nil)); end
end

class Solargraph::YardMap::Mapper
end

class Solargraph::YardMap::NoYardocError
end

class Solargraph::YardMap::NoYardocError
end

class Solargraph::YardMap::ToMethod
  def make(code_object, name=T.unsafe(nil), scope=T.unsafe(nil), visibility=T.unsafe(nil), closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

class Solargraph::YardMap::ToMethod
  extend ::Solargraph::YardMap::Helpers
end

class Solargraph::YardMap
end

module Spoom
  SPOOM_PATH = ::T.let(nil, ::T.untyped)
end

module Spoom::Context::Bundle
  def bundle(*args, **arg, &blk); end

  def bundle_exec(*args, **arg, &blk); end

  def bundle_install!(*args, **arg, &blk); end

  def gem_version_from_gemfile_lock(*args, **arg, &blk); end

  def gemfile_lock_specs(*args, **arg, &blk); end

  def read_gemfile(*args, **arg, &blk); end

  def read_gemfile_lock(*args, **arg, &blk); end

  def write_gemfile!(*args, **arg, &blk); end
end

class Spoom::ExecResult
  def self.inherited(grandchild); end
end

class Spoom::FileCollector
  def files(*args, **arg, &blk); end

  def initialize(*args, **arg, &blk); end

  def visit_path(*args, **arg, &blk); end

  def visit_paths(*args, **arg, &blk); end
end

module Stimulus
  VERSION = ::T.let(nil, ::T.untyped)
end

class Stimulus::Engine
  PRECOMPILE_ASSETS = ::T.let(nil, ::T.untyped)
end

class Story
  include ::Story::GeneratedAttributeMethods
  include ::Story::GeneratedAssociationMethods
  def autosave_associated_records_for_rich_text_body(*args); end

  def autosave_associated_records_for_user(*args); end

  def body(); end

  def body=(body); end

  def body?(); end

  def validate_associated_records_for_rich_text_body(*args); end
end

module Story::GeneratedAssociationMethods
  def build_rich_text_body(*args, &block); end

  def build_user(*args, &block); end

  def create_rich_text_body(*args, &block); end

  def create_rich_text_body!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_rich_text_body(); end

  def reload_user(); end

  def reset_rich_text_body(); end

  def reset_user(); end

  def rich_text_body(); end

  def rich_text_body=(value); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Story::GeneratedAssociationMethods
end

module Story::GeneratedAttributeMethods
end

module Story::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Story
  def self.with_rich_text_body(*args, **arg); end

  def self.with_rich_text_body_and_embeds(*args, **arg); end
end

class StoryAssignment
  include ::StoryAssignment::GeneratedAttributeMethods
  include ::StoryAssignment::GeneratedAssociationMethods
  def autosave_associated_records_for_story_idea(*args); end
end

module StoryAssignment::GeneratedAssociationMethods
  def build_story_idea(*args, &block); end

  def create_story_idea(*args, &block); end

  def create_story_idea!(*args, &block); end

  def reload_story_idea(); end

  def reset_story_idea(); end

  def story_idea(); end

  def story_idea=(value); end

  def story_idea_changed?(); end

  def story_idea_previously_changed?(); end
end

module StoryAssignment::GeneratedAssociationMethods
end

module StoryAssignment::GeneratedAttributeMethods
end

module StoryAssignment::GeneratedAttributeMethods
  extend ::Mutex_m
end

class StoryAssignment
  def self.not_pending(*args, **arg); end

  def self.not_submitted(*args, **arg); end

  def self.pending(*args, **arg); end

  def self.statuses(); end

  def self.submitted(*args, **arg); end
end

class StoryIdea
  include ::StoryIdea::GeneratedAttributeMethods
  include ::StoryIdea::GeneratedAssociationMethods
  def autosave_associated_records_for_comments(*args); end

  def autosave_associated_records_for_user(*args); end

  def validate_associated_records_for_comments(*args); end
end

module StoryIdea::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def comment_ids(); end

  def comment_ids=(ids); end

  def comments(); end

  def comments=(value); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module StoryIdea::GeneratedAssociationMethods
end

module StoryIdea::GeneratedAttributeMethods
end

module StoryIdea::GeneratedAttributeMethods
  extend ::Mutex_m
end

class String
  def dedup(); end

  def shell_split(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class String
  def self.new(*arg); end
end

class StringIO
  def pread(*arg); end

  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*arg); end

  def named_captures(); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

module Stripe
  DEFAULT_CA_BUNDLE_PATH = ::T.let(nil, ::T.untyped)
  LEVEL_DEBUG = ::T.let(nil, ::T.untyped)
  LEVEL_ERROR = ::T.let(nil, ::T.untyped)
  LEVEL_INFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Stripe::APIResource
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Account
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::AccountLink
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::AccountSession
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

module Stripe::ApiVersion
  CURRENT = ::T.let(nil, ::T.untyped)
end

class Stripe::ApplePayDomain
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ApplicationFee
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ApplicationFeeRefund
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Apps::Secret
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Balance
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::BalanceTransaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::BankAccount
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Billing::Meter
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Billing::MeterEvent
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Billing::MeterEventAdjustment
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Billing::MeterEventSummary
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::BillingPortal::Configuration
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::BillingPortal::Session
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Capability
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Card
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::CashBalance
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Charge
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Checkout::Session
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Climate::Order
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Climate::Product
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Climate::Supplier
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ConfirmationToken
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::ConfirmationToken::TestHelpers::RESOURCE_CLASS = Stripe::ConfirmationToken

class Stripe::CountrySpec
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Coupon
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::CreditNote
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::CreditNoteLineItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Customer
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Customer::TestHelpers::RESOURCE_CLASS = Stripe::Customer

class Stripe::CustomerBalanceTransaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::CustomerCashBalanceTransaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::CustomerSession
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Discount
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Dispute
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Entitlements::ActiveEntitlement
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Entitlements::Feature
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::EphemeralKey
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Event
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ExchangeRate
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::File
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
  OBJECT_NAME_ALT = ::T.let(nil, ::T.untyped)
end

class Stripe::FileLink
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::FinancialConnections::Account
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::FinancialConnections::AccountOwner
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::FinancialConnections::AccountOwnership
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::FinancialConnections::Session
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::FinancialConnections::Transaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Forwarding::Request
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::FundingInstructions
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Identity::VerificationReport
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Identity::VerificationSession
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Instrumentation::RequestEvent = Stripe::Instrumentation::RequestEndEvent

class Stripe::Invoice
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::InvoiceItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::InvoiceLineItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Authorization
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Issuing::Authorization::TestHelpers::RESOURCE_CLASS = Stripe::Issuing::Authorization

class Stripe::Issuing::Card
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Issuing::Card::TestHelpers::RESOURCE_CLASS = Stripe::Issuing::Card

class Stripe::Issuing::Cardholder
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Dispute
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::PersonalizationDesign
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Issuing::PersonalizationDesign::TestHelpers::RESOURCE_CLASS = Stripe::Issuing::PersonalizationDesign

class Stripe::Issuing::PhysicalBundle
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Token
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Transaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Issuing::Transaction::TestHelpers::RESOURCE_CLASS = Stripe::Issuing::Transaction

class Stripe::LineItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ListObject
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::LoginLink
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Mandate
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::MultipartEncoder
  MULTIPART_FORM_DATA = ::T.let(nil, ::T.untyped)
end

class Stripe::PaymentIntent
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::PaymentLink
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::PaymentMethod
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::PaymentMethodConfiguration
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::PaymentMethodDomain
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Payout
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Person
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Plan
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Price
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Product
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ProductFeature
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::PromotionCode
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Quote
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Radar::EarlyFraudWarning
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Radar::ValueList
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Radar::ValueListItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Refund
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Refund::TestHelpers::RESOURCE_CLASS = Stripe::Refund

class Stripe::Reporting::ReportRun
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Reporting::ReportType
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Reversal
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Review
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SearchResultObject
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SetupAttempt
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SetupIntent
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ShippingRate
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Sigma::ScheduledQueryRun
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Source
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SourceTransaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::StripeClient
  CONNECTION_MANAGER_GC_LAST_USED_EXPIRY = ::T.let(nil, ::T.untyped)
  CONNECTION_MANAGER_GC_PERIOD = ::T.let(nil, ::T.untyped)
  ERROR_MESSAGE_CONNECTION = ::T.let(nil, ::T.untyped)
  ERROR_MESSAGE_SSL = ::T.let(nil, ::T.untyped)
  ERROR_MESSAGE_TIMEOUT_CONNECT = ::T.let(nil, ::T.untyped)
  ERROR_MESSAGE_TIMEOUT_READ = ::T.let(nil, ::T.untyped)
  ERROR_MESSAGE_TIMEOUT_SUFFIX = ::T.let(nil, ::T.untyped)
end

class Stripe::StripeObject
  RESERVED_FIELD_NAMES = ::T.let(nil, ::T.untyped)
end

Stripe::StripeResponse::Headers = Stripe::StripeResponseHeaders

class Stripe::Subscription
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SubscriptionItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SubscriptionSchedule
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Tax::Calculation
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Tax::CalculationLineItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Tax::Registration
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Tax::Settings
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Tax::Transaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Tax::TransactionLineItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::TaxCode
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::TaxId
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::TaxRate
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Terminal::Configuration
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Terminal::ConnectionToken
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Terminal::Location
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Terminal::Reader
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Terminal::Reader::TestHelpers::RESOURCE_CLASS = Stripe::Terminal::Reader

class Stripe::TestHelpers::TestClock
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Token
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Topup
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Transfer
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Treasury::CreditReversal
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Treasury::DebitReversal
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Treasury::FinancialAccount
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Treasury::FinancialAccountFeatures
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Treasury::InboundTransfer
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Treasury::InboundTransfer::TestHelpers::RESOURCE_CLASS = Stripe::Treasury::InboundTransfer

class Stripe::Treasury::OutboundPayment
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Treasury::OutboundPayment::TestHelpers::RESOURCE_CLASS = Stripe::Treasury::OutboundPayment

class Stripe::Treasury::OutboundTransfer
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Treasury::OutboundTransfer::TestHelpers::RESOURCE_CLASS = Stripe::Treasury::OutboundTransfer

class Stripe::Treasury::ReceivedCredit
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Treasury::ReceivedCredit::TestHelpers::RESOURCE_CLASS = Stripe::Treasury::ReceivedCredit

class Stripe::Treasury::ReceivedDebit
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

Stripe::Treasury::ReceivedDebit::TestHelpers::RESOURCE_CLASS = Stripe::Treasury::ReceivedDebit

class Stripe::Treasury::Transaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Treasury::TransactionEntry
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::UsageRecord
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::UsageRecordSummary
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

module Stripe::Util
  OPTS_COPYABLE = ::T.let(nil, ::T.untyped)
  OPTS_PERSISTABLE = ::T.let(nil, ::T.untyped)
  OPTS_USER_SPECIFIED = ::T.let(nil, ::T.untyped)
end

module Stripe::Webhook
  DEFAULT_TOLERANCE = ::T.let(nil, ::T.untyped)
end

module Stripe::Webhook::Signature
  EXPECTED_SCHEME = ::T.let(nil, ::T.untyped)
end

class Stripe::WebhookEndpoint
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class StripeReport
  include ::StripeReport::GeneratedAttributeMethods
  include ::StripeReport::GeneratedAssociationMethods
  def autosave_associated_records_for_donation(*args); end

  def autosave_associated_records_for_pledge(*args); end

  def autosave_associated_records_for_user(*args); end
end

module StripeReport::GeneratedAssociationMethods
  def build_donation(*args, &block); end

  def build_pledge(*args, &block); end

  def build_user(*args, &block); end

  def create_donation(*args, &block); end

  def create_donation!(*args, &block); end

  def create_pledge(*args, &block); end

  def create_pledge!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def donation(); end

  def donation=(value); end

  def donation_changed?(); end

  def donation_previously_changed?(); end

  def pledge(); end

  def pledge=(value); end

  def pledge_changed?(); end

  def pledge_previously_changed?(); end

  def reload_donation(); end

  def reload_pledge(); end

  def reload_user(); end

  def reset_donation(); end

  def reset_pledge(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module StripeReport::GeneratedAssociationMethods
end

module StripeReport::GeneratedAttributeMethods
end

module StripeReport::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct
  def self.new(*arg); end
end

class Survey
  include ::Survey::GeneratedAttributeMethods
  include ::Survey::GeneratedAssociationMethods
  def autosave_associated_records_for_user(*args); end
end

module Survey::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def reset_user(); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Survey::GeneratedAssociationMethods
end

module Survey::GeneratedAttributeMethods
end

module Survey::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Symbol
  def ends_with?(*arg); end

  def starts_with?(*arg); end
end

class Symbol
  def self.from_msgpack_ext(data); end
end

class SymbolHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def initialize(symbolize_value=T.unsafe(nil)); end

  def key?(key); end

  def merge(hash); end

  def merge!(hash); end

  def update(hash); end
end

class SymbolHash
  def self.[](*hsh); end
end

class SyntaxError
  def path(); end
end

module SyntaxSuggest
end

class SyntaxSuggest::MiniStringIO
  def initialize(isatty: T.unsafe(nil)); end

  def isatty(); end

  def puts(value=T.unsafe(nil), **arg); end

  def string(); end
end

class SyntaxSuggest::MiniStringIO
end

module SyntaxSuggest
  def self.module_for_detailed_message(); end
end

module TSort
  VERSION = ::T.let(nil, ::T.untyped)
end

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

module Tapioca
  BINARY_FILE = ::T.let(nil, ::T.untyped)
  CENTRAL_REPO_ANNOTATIONS_DIR = ::T.let(nil, ::T.untyped)
  CENTRAL_REPO_INDEX_PATH = ::T.let(nil, ::T.untyped)
  CENTRAL_REPO_ROOT_URI = ::T.let(nil, ::T.untyped)
  DEFAULT_ANNOTATIONS_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_DSL_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_ENVIRONMENT = ::T.let(nil, ::T.untyped)
  DEFAULT_GEM_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_OVERRIDES = ::T.let(nil, ::T.untyped)
  DEFAULT_POSTREQUIRE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_RBI_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_RBI_MAX_LINE_LENGTH = ::T.let(nil, ::T.untyped)
  DEFAULT_SHIM_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_TODO_FILE = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  TAPIOCA_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  TAPIOCA_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Tapioca
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.silence_warnings(*args, **arg, &blk); end
end

class Task
  include ::Task::GeneratedAttributeMethods
  include ::Task::GeneratedAssociationMethods
end

module Task::GeneratedAssociationMethods
end

module Task::GeneratedAssociationMethods
end

module Task::GeneratedAttributeMethods
end

module Task::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Tempfile
  def _close(); end

  def finalizer_obj(); end

  def mode(); end

  def opts(); end

  def unlinked(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile::Closer
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Closer
end

class Tempfile::Remover
  def call(*args); end

  def initialize(path); end
end

class Tempfile::Remover
end

class Thor::Actions::InjectIntoFile
  def content(); end

  def replacement_present?(); end
end

class Thor::Argument
  def enum_to_s(); end

  def print_default(); end
end

class Thor::Command
  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end
end

class Thor::CoreExt::HashWithIndifferentAccess
  def except(*keys); end

  def slice(*keys); end
end

class Thor::Option
  def aliases_for_usage(); end
end

class Thor::Options
  def check_at_least_one!(); end

  def check_exclusive!(); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def unshift(arg, is_value: T.unsafe(nil)); end
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
end

module Thor::Shell
  def say_error(*args, &block); end
end

class Thor::UndefinedCommandError
  include ::Thor::Correctable
end

class Thor::UnknownArgumentError
  include ::Thor::Correctable
end

class Thor
  def self.at_least_one(*args, &block); end

  def self.exclusive(*args, &block); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.sort_commands!(list); end
end

class Thread
  def active_support_execution_state(); end

  def active_support_execution_state=(active_support_execution_state); end
end

class Thread::Backtrace::Location
  def spot(ex); end
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class Ticket
  include ::Ticket::GeneratedAttributeMethods
  include ::Ticket::GeneratedAssociationMethods
  def autosave_associated_records_for_event(*args); end
end

module Ticket::GeneratedAssociationMethods
  def build_event(*args, &block); end

  def create_event(*args, &block); end

  def create_event!(*args, &block); end

  def event(); end

  def event=(value); end

  def event_changed?(); end

  def event_previously_changed?(); end

  def reload_event(); end

  def reset_event(); end
end

module Ticket::GeneratedAssociationMethods
end

module Ticket::GeneratedAttributeMethods
end

module Ticket::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::BaseMapping
  def [](file); end

  def new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def template_for(file); end

  def templates_for(file); end
end

class Tilt::BuilderTemplate
  def precompiled_postamble(locals); end

  def precompiled_template(locals); end
end

class Tilt::BuilderTemplate
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
end

class Tilt::Cache
  def clear(); end

  def fetch(*key); end
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
end

class Tilt::ErubiTemplate
  def precompiled_template(locals); end
end

class Tilt::ErubiTemplate
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::KramdownTemplate
end

class Tilt::KramdownTemplate
end

class Tilt::Mapping
  def extensions_for(template_class); end

  def finalized(); end

  def lazy_map(); end

  def register(template_class, *extensions); end

  def register_lazy(class_name, file, *extensions); end

  def register_pipeline(ext, options=T.unsafe(nil)); end

  def registered?(ext); end

  def template_map(); end

  def unregister(*extensions); end
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
end

class Tilt::RDocTemplate
end

class Tilt::StaticTemplate
  def allows_script?(); end

  def render(scope=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class Tilt::StaticTemplate
  def self.subclass(mime_type: T.unsafe(nil), &block); end
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Tilt::Template
  def basename(suffix=T.unsafe(nil)); end

  def compiled_method(locals_keys, scope_class=T.unsafe(nil)); end

  def compiled_path(); end

  def compiled_path=(path); end

  def data(); end

  def default_encoding(); end

  def eval_file(); end

  def evaluate(scope, locals, &block); end

  def file(); end

  def initialize(file=T.unsafe(nil), line=T.unsafe(nil), options=T.unsafe(nil)); end

  def line(); end

  def metadata(); end

  def name(); end

  def options(); end

  def precompiled(local_keys); end

  def precompiled_postamble(local_keys); end

  def precompiled_preamble(local_keys); end

  def precompiled_template(local_keys); end

  def prepare(); end

  def render(scope=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def skip_compiled_encoding_detection?(); end
  CLASS_METHOD = ::T.let(nil, ::T.untyped)
  USE_BIND_CALL = ::T.let(nil, ::T.untyped)
end

class Tilt::Template
  def self.default_mime_type(); end

  def self.default_mime_type=(value); end

  def self.metadata(); end
end

module Tilt
  def self.[](file); end

  def self.default_mapping(); end

  def self.finalize!(); end

  def self.lazy_map(); end

  def self.new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.prefer(template_class, *extensions); end

  def self.register(template_class, *extensions); end

  def self.register_lazy(class_name, file, *extensions); end

  def self.register_pipeline(ext, options=T.unsafe(nil)); end

  def self.registered?(ext); end

  def self.template_for(file); end

  def self.templates_for(file); end
end

class Time
  def deconstruct_keys(arg); end
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Timeout::Error
  def self.handle_timeout(message); end
end

class Timeout::ExitException
  def exception(*arg); end
end

class Timeout::ExitException
end

module Timeout
  def self.ensure_timeout_thread_created(); end
end

class TodoItem
  include ::TodoItem::GeneratedAttributeMethods
  include ::TodoItem::GeneratedAssociationMethods
  include ::ActiveRecord::Acts::List::InstanceMethods
  include ::ActiveRecord::Acts::List::NoUpdate
  def acts_as_list_class(); end

  def acts_as_list_top(); end

  def add_new_at(); end

  def autosave_associated_records_for_todo_list(*args); end

  def connection(&block); end

  def destroyed_via_scope?(); end

  def position=(position); end

  def position_changed(); end

  def position_column(); end

  def scope_changed?(); end

  def scope_name(); end

  def touch_record_sql(); end
end

module TodoItem::GeneratedAssociationMethods
  def build_todo_list(*args, &block); end

  def create_todo_list(*args, &block); end

  def create_todo_list!(*args, &block); end

  def reload_todo_list(); end

  def reset_todo_list(); end

  def todo_list(); end

  def todo_list=(value); end

  def todo_list_changed?(); end

  def todo_list_previously_changed?(); end
end

module TodoItem::GeneratedAssociationMethods
end

module TodoItem::GeneratedAttributeMethods
end

module TodoItem::GeneratedAttributeMethods
  extend ::Mutex_m
end

class TodoItem
  extend ::ActiveRecord::Acts::List::NoUpdate::ClassMethods
  def self.acts_as_list_top(); end

  def self.decrement_all(); end

  def self.decrement_sequentially(); end

  def self.in_list(*args, **arg); end

  def self.increment_all(); end

  def self.increment_sequentially(); end

  def self.quoted_position_column(); end

  def self.quoted_position_column_with_table_name(); end

  def self.touch_record_sql(); end

  def self.update_all_with_touch(updates); end
end

class TodoList
  include ::TodoList::GeneratedAttributeMethods
  include ::TodoList::GeneratedAssociationMethods
  def autosave_associated_records_for_todo_items(*args); end

  def autosave_associated_records_for_user(*args); end

  def validate_associated_records_for_todo_items(*args); end
end

module TodoList::GeneratedAssociationMethods
  def build_user(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_user(); end

  def reset_user(); end

  def todo_item_ids(); end

  def todo_item_ids=(ids); end

  def todo_items(); end

  def todo_items=(value); end

  def todo_items_attributes=(attributes); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module TodoList::GeneratedAssociationMethods
end

module TodoList::GeneratedAttributeMethods
end

module TodoList::GeneratedAttributeMethods
  extend ::Mutex_m
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

module Turbo::Broadcastable
  def broadcast_action(action, target: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end

  def broadcast_action_later(action:, target: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end

  def broadcast_action_later_to(*streamables, action:, target: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end

  def broadcast_action_to(*streamables, action:, target: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end

  def broadcast_after_to(*streamables, target:, **rendering); end

  def broadcast_append(target: T.unsafe(nil), **rendering); end

  def broadcast_append_later(target: T.unsafe(nil), **rendering); end

  def broadcast_append_later_to(*streamables, target: T.unsafe(nil), **rendering); end

  def broadcast_append_to(*streamables, target: T.unsafe(nil), **rendering); end

  def broadcast_before_to(*streamables, target:, **rendering); end

  def broadcast_prepend(target: T.unsafe(nil), **rendering); end

  def broadcast_prepend_later(target: T.unsafe(nil), **rendering); end

  def broadcast_prepend_later_to(*streamables, target: T.unsafe(nil), **rendering); end

  def broadcast_prepend_to(*streamables, target: T.unsafe(nil), **rendering); end

  def broadcast_refresh(); end

  def broadcast_refresh_later(); end

  def broadcast_refresh_later_to(*streamables); end

  def broadcast_refresh_to(*streamables); end

  def broadcast_remove(); end

  def broadcast_remove_to(*streamables, target: T.unsafe(nil)); end

  def broadcast_render(**rendering); end

  def broadcast_render_later(**rendering); end

  def broadcast_render_later_to(*streamables, **rendering); end

  def broadcast_render_to(*streamables, **rendering); end

  def broadcast_replace(**rendering); end

  def broadcast_replace_later(**rendering); end

  def broadcast_replace_later_to(*streamables, **rendering); end

  def broadcast_replace_to(*streamables, **rendering); end

  def broadcast_update(**rendering); end

  def broadcast_update_later(**rendering); end

  def broadcast_update_later_to(*streamables, **rendering); end

  def broadcast_update_to(*streamables, **rendering); end
end

module Turbo::Broadcastable::TestHelper
  def assert_no_turbo_stream_broadcasts(stream_name_or_object, &block); end

  def assert_turbo_stream_broadcasts(stream_name_or_object, count: T.unsafe(nil), &block); end

  def capture_turbo_stream_broadcasts(stream_name_or_object, &block); end
end

class Turbo::Debouncer
  def debounce(&block); end

  def delay(); end

  def initialize(delay: T.unsafe(nil)); end

  def scheduled_task(); end

  def wait(); end
  DEFAULT_DELAY = ::T.let(nil, ::T.untyped)
end

module Turbo::DriveHelper
  def turbo_exempts_page_from_cache(); end

  def turbo_exempts_page_from_cache_tag(); end

  def turbo_exempts_page_from_preview(); end

  def turbo_exempts_page_from_preview_tag(); end

  def turbo_page_requires_reload(); end

  def turbo_page_requires_reload_tag(); end

  def turbo_refresh_method_tag(method=T.unsafe(nil)); end

  def turbo_refresh_scroll_tag(scroll=T.unsafe(nil)); end

  def turbo_refreshes_with(method: T.unsafe(nil), scroll: T.unsafe(nil)); end
end

class Turbo::Engine
  PRECOMPILE_ASSETS = ::T.let(nil, ::T.untyped)
end

module Turbo::FramesHelper
  def turbo_frame_tag(*ids, src: T.unsafe(nil), target: T.unsafe(nil), **attributes, &block); end
end

module Turbo::IncludesHelper
  def turbo_include_tags(); end
end

module Turbo::Native::Navigation
  def recede_or_redirect_back_or_to(url, **options); end

  def recede_or_redirect_to(url, **options); end

  def refresh_or_redirect_back_or_to(url, **options); end

  def refresh_or_redirect_to(url, **options); end

  def resume_or_redirect_back_or_to(url, **options); end

  def resume_or_redirect_to(url, **options); end

  def turbo_native_app?(); end
end

class Turbo::Native::NavigationController
  def recede(); end

  def refresh(); end

  def resume(); end
end

class Turbo::Streams::ActionBroadcastJob
  def perform(stream, action:, target:, attributes: T.unsafe(nil), **rendering); end
end

module Turbo::Streams::ActionHelper
  def turbo_stream_action_tag(action, target: T.unsafe(nil), targets: T.unsafe(nil), template: T.unsafe(nil), **attributes); end

  def turbo_stream_refresh_tag(request_id: T.unsafe(nil), **attributes); end
end

class Turbo::Streams::BroadcastJob
  def perform(stream, **rendering); end
end

class Turbo::Streams::BroadcastStreamJob
  def perform(stream, content:); end
end

module Turbo::Streams::Broadcasts
  def broadcast_action_later_to(*streamables, action:, target: T.unsafe(nil), targets: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end

  def broadcast_action_to(*streamables, action:, target: T.unsafe(nil), targets: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end

  def broadcast_after_later_to(*streamables, **opts); end

  def broadcast_after_to(*streamables, **opts); end

  def broadcast_append_later_to(*streamables, **opts); end

  def broadcast_append_to(*streamables, **opts); end

  def broadcast_before_later_to(*streamables, **opts); end

  def broadcast_before_to(*streamables, **opts); end

  def broadcast_prepend_later_to(*streamables, **opts); end

  def broadcast_prepend_to(*streamables, **opts); end

  def broadcast_refresh_later_to(*streamables, request_id: T.unsafe(nil), **opts); end

  def broadcast_refresh_to(*streamables, **opts); end

  def broadcast_remove_to(*streamables, **opts); end

  def broadcast_render_later_to(*streamables, **rendering); end

  def broadcast_render_to(*streamables, **rendering); end

  def broadcast_replace_later_to(*streamables, **opts); end

  def broadcast_replace_to(*streamables, **opts); end

  def broadcast_stream_to(*streamables, content:); end

  def broadcast_update_later_to(*streamables, **opts); end

  def broadcast_update_to(*streamables, **opts); end

  def refresh_debouncer_for(*streamables, request_id: T.unsafe(nil)); end
end

module Turbo::Streams::StreamName
  def signed_stream_name(streamables); end

  def verified_stream_name(signed_stream_name); end
end

module Turbo::Streams::StreamName::ClassMethods
  def verified_stream_name_from_params(); end
end

class Turbo::Streams::TagBuilder
  def action(name, target, content=T.unsafe(nil), allow_inferred_rendering: T.unsafe(nil), **rendering, &block); end

  def action_all(name, targets, content=T.unsafe(nil), allow_inferred_rendering: T.unsafe(nil), **rendering, &block); end

  def after(target, content=T.unsafe(nil), **rendering, &block); end

  def after_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def append(target, content=T.unsafe(nil), **rendering, &block); end

  def append_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def before(target, content=T.unsafe(nil), **rendering, &block); end

  def before_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def initialize(view_context); end

  def prepend(target, content=T.unsafe(nil), **rendering, &block); end

  def prepend_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def remove(target); end

  def remove_all(targets); end

  def replace(target, content=T.unsafe(nil), **rendering, &block); end

  def replace_all(targets, content=T.unsafe(nil), **rendering, &block); end

  def update(target, content=T.unsafe(nil), **rendering, &block); end

  def update_all(targets, content=T.unsafe(nil), **rendering, &block); end
end

class Turbo::StreamsChannel
  extend ::Turbo::Streams::StreamName
end

module Turbo::StreamsHelper
  def turbo_stream(); end

  def turbo_stream_from(*streamables, **attributes); end
end

module Turbo::TestAssertions
  def assert_no_turbo_stream(action:, target: T.unsafe(nil), targets: T.unsafe(nil)); end

  def assert_turbo_stream(action:, target: T.unsafe(nil), targets: T.unsafe(nil), count: T.unsafe(nil), &block); end
end

module Turbo::TestAssertions::IntegrationTestAssertions
  def assert_no_turbo_stream(status: T.unsafe(nil), **attributes); end

  def assert_turbo_stream(status: T.unsafe(nil), **attributes, &block); end
end

module Turbo::TestAssertions::IntegrationTestAssertions
end

class Turbo::ThreadDebouncer
  def debounce(); end

  def initialize(key, thread, delay:); end

  def wait(*arg, **arg1, &arg2); end
end

class Turbo::ThreadDebouncer
  def self.for(key, delay: T.unsafe(nil)); end
end

class TypeError
  include ::ErrorHighlight::CoreExt
end

module URI
  include ::URI::RFC2396_REGEXP
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::GID
  COMPONENT = ::T.let(nil, ::T.untyped)
  COMPOSITE_MODEL_ID_DELIMITER = ::T.let(nil, ::T.untyped)
  COMPOSITE_MODEL_ID_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class URI::Generic
  def decoded_password(); end

  def decoded_user(); end

  def to_str(); end
end

class URI::HTTP
  def authority(); end

  def buffer_open(buf, proxy, options); end

  def origin(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::WSS
end

module URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.open(name, *rest, **arg, &block); end

  def self.register_scheme(scheme, klass); end
end

class Unicode::DisplayWidth
  def get_config(**kwargs); end

  def initialize(ambiguous: T.unsafe(nil), overwrite: T.unsafe(nil), emoji: T.unsafe(nil)); end

  def of(string, **kwargs); end
  ASCII_NON_ZERO_REGEX = ::T.let(nil, ::T.untyped)
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  FIRST_4096 = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  INITIAL_DEPTH = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Unicode::DisplayWidth
  def self.decompress_index(index, level); end

  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.width_all_features(string, ambiguous, overwrite, options); end

  def self.width_no_overwrite(string, ambiguous, options=T.unsafe(nil)); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class User
  include ::User::GeneratedAttributeMethods
  include ::User::GeneratedAssociationMethods
  include ::Devise::Orm
  include ::Devise::Orm::DirtyTrackingNewMethods
  include ::Devise::Models::Authenticatable
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
  include ::Devise::Models::DatabaseAuthenticatable
  include ::Devise::Models::Rememberable
  include ::Devise::Models::Recoverable
  include ::Devise::Models::Registerable
  include ::Devise::Models::Confirmable
  include ::Devise::Models::Trackable
  def autosave_associated_records_for_agendas(*args); end

  def autosave_associated_records_for_avatar_attachment(*args); end

  def autosave_associated_records_for_avatar_blob(*args); end

  def autosave_associated_records_for_comments(*args); end

  def autosave_associated_records_for_donations(*args); end

  def autosave_associated_records_for_opportunities(*args); end

  def autosave_associated_records_for_pledge(*args); end

  def autosave_associated_records_for_posts(*args); end

  def autosave_associated_records_for_profile(*args); end

  def autosave_associated_records_for_story_ideas(*args); end

  def autosave_associated_records_for_todo_lists(*args); end

  def autosave_associated_records_for_vnotes(*args); end

  def current_password(); end

  def devise_modules(); end

  def devise_modules?(); end

  def password(); end

  def password_confirmation(); end

  def password_confirmation=(password_confirmation); end

  def validate_associated_records_for_agendas(*args); end

  def validate_associated_records_for_comments(*args); end

  def validate_associated_records_for_donations(*args); end

  def validate_associated_records_for_opportunities(*args); end

  def validate_associated_records_for_posts(*args); end

  def validate_associated_records_for_profile(*args); end

  def validate_associated_records_for_story_ideas(*args); end

  def validate_associated_records_for_todo_lists(*args); end

  def validate_associated_records_for_vnotes(*args); end
end

module User::GeneratedAssociationMethods
  def agenda_ids(); end

  def agenda_ids=(ids); end

  def agendas(); end

  def agendas=(value); end

  def avatar(); end

  def avatar=(attachable); end

  def avatar_attachment(); end

  def avatar_attachment=(value); end

  def avatar_blob(); end

  def avatar_blob=(value); end

  def build_avatar_attachment(*args, &block); end

  def build_avatar_blob(*args, &block); end

  def build_pledge(*args, &block); end

  def build_profile(*args, &block); end

  def comment_ids(); end

  def comment_ids=(ids); end

  def comments(); end

  def comments=(value); end

  def create_avatar_attachment(*args, &block); end

  def create_avatar_attachment!(*args, &block); end

  def create_avatar_blob(*args, &block); end

  def create_avatar_blob!(*args, &block); end

  def create_pledge(*args, &block); end

  def create_pledge!(*args, &block); end

  def create_profile(*args, &block); end

  def create_profile!(*args, &block); end

  def donation_ids(); end

  def donation_ids=(ids); end

  def donations(); end

  def donations=(value); end

  def opportunities(); end

  def opportunities=(value); end

  def opportunity_ids(); end

  def opportunity_ids=(ids); end

  def pledge(); end

  def pledge=(value); end

  def post_ids(); end

  def post_ids=(ids); end

  def posts(); end

  def posts=(value); end

  def profile(); end

  def profile=(value); end

  def profile_attributes=(attributes); end

  def reload_avatar_attachment(); end

  def reload_avatar_blob(); end

  def reload_pledge(); end

  def reload_profile(); end

  def reset_avatar_attachment(); end

  def reset_avatar_blob(); end

  def reset_pledge(); end

  def reset_profile(); end

  def story_idea_ids(); end

  def story_idea_ids=(ids); end

  def story_ideas(); end

  def story_ideas=(value); end

  def todo_list_ids(); end

  def todo_list_ids=(ids); end

  def todo_lists(); end

  def todo_lists=(value); end

  def todo_lists_attributes=(attributes); end

  def vnote_ids(); end

  def vnote_ids=(ids); end

  def vnotes(); end

  def vnotes=(value); end
end

module User::GeneratedAssociationMethods
end

module User::GeneratedAttributeMethods
end

module User::GeneratedAttributeMethods
  extend ::Mutex_m
end

class User
  extend ::Devise::Models::Authenticatable::ClassMethods
  extend ::Devise::Models::DatabaseAuthenticatable::ClassMethods
  extend ::Devise::Models::Rememberable::ClassMethods
  extend ::Devise::Models::Recoverable::ClassMethods
  extend ::Devise::Models::Registerable::ClassMethods
  extend ::Devise::Models::Confirmable::ClassMethods
  def self.devise_modules(); end

  def self.devise_modules=(value); end

  def self.devise_modules?(); end

  def self.with_attached_avatar(*args, **arg); end
end

class Vector
  def [](i); end

  def []=(i, v); end

  def collect!(&block); end

  def covector(); end

  def elements(); end

  def initialize(array); end

  def map!(&block); end
end

class Verifalia::Client
  VERSION = ::T.let(nil, ::T.untyped)
end

module Verifalia::EmailValidations::EntryClassification
  DELIVERABLE = ::T.let(nil, ::T.untyped)
  RISKY = ::T.let(nil, ::T.untyped)
  UNDELIVERABLE = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

module Verifalia::EmailValidations::EntryStatus
  AT_SIGN_NOT_FOUND = ::T.let(nil, ::T.untyped)
  CATCH_ALL_CONNECTION_FAILURE = ::T.let(nil, ::T.untyped)
  CATCH_ALL_VALIDATION_TIMEOUT = ::T.let(nil, ::T.untyped)
  DNS_CONNECTION_FAILURE = ::T.let(nil, ::T.untyped)
  DNS_QUERY_TIMEOUT = ::T.let(nil, ::T.untyped)
  DOMAIN_DOES_NOT_EXIST = ::T.let(nil, ::T.untyped)
  DOMAIN_HAS_NULL_MX = ::T.let(nil, ::T.untyped)
  DOMAIN_IS_MISCONFIGURED = ::T.let(nil, ::T.untyped)
  DOMAIN_IS_WELL_KNOWN_DEA = ::T.let(nil, ::T.untyped)
  DOMAIN_PART_COMPLIANCY_FAILURE = ::T.let(nil, ::T.untyped)
  DOUBLE_DOT_SEQUENCE = ::T.let(nil, ::T.untyped)
  DUPLICATE = ::T.let(nil, ::T.untyped)
  INVALID_ADDRESS_LENGTH = ::T.let(nil, ::T.untyped)
  INVALID_CHARACTER_IN_SEQUENCE = ::T.let(nil, ::T.untyped)
  INVALID_EMPTY_QUOTED_WORD = ::T.let(nil, ::T.untyped)
  INVALID_FOLDING_WHITE_SPACE_SEQUENCE = ::T.let(nil, ::T.untyped)
  INVALID_LOCAL_PART_LENGTH = ::T.let(nil, ::T.untyped)
  INVALID_WORD_BOUNDARY_START = ::T.let(nil, ::T.untyped)
  ISP_SPECIFIC_SYNTAX_FAILURE = ::T.let(nil, ::T.untyped)
  LOCAL_END_POINT_REJECTED = ::T.let(nil, ::T.untyped)
  LOCAL_PART_IS_WELL_KNOWN_ROLE_ACCOUNT = ::T.let(nil, ::T.untyped)
  LOCAL_SENDER_ADDRESS_REJECTED = ::T.let(nil, ::T.untyped)
  MAILBOX_CONNECTION_FAILURE = ::T.let(nil, ::T.untyped)
  MAILBOX_DOES_NOT_EXIST = ::T.let(nil, ::T.untyped)
  MAILBOX_HAS_INSUFFICIENT_STORAGE = ::T.let(nil, ::T.untyped)
  MAILBOX_IS_DEA = ::T.let(nil, ::T.untyped)
  MAILBOX_TEMPORARILY_UNAVAILABLE = ::T.let(nil, ::T.untyped)
  MAILBOX_VALIDATION_TIMEOUT = ::T.let(nil, ::T.untyped)
  MAIL_EXCHANGER_IS_HONEYPOT = ::T.let(nil, ::T.untyped)
  MAIL_EXCHANGER_IS_PARKED = ::T.let(nil, ::T.untyped)
  MAIL_EXCHANGER_IS_WELL_KNOWN_DEA = ::T.let(nil, ::T.untyped)
  OVERRIDE_MATCH = ::T.let(nil, ::T.untyped)
  SERVER_DOES_NOT_SUPPORT_INTERNATIONAL_MAILBOXES = ::T.let(nil, ::T.untyped)
  SERVER_IS_CATCH_ALL = ::T.let(nil, ::T.untyped)
  SERVER_TEMPORARILY_UNAVAILABLE = ::T.let(nil, ::T.untyped)
  SMTP_CONNECTION_FAILURE = ::T.let(nil, ::T.untyped)
  SMTP_CONNECTION_TIMEOUT = ::T.let(nil, ::T.untyped)
  SMTP_DIALOG_ERROR = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
  UNACCEPTABLE_DOMAIN_LITERAL = ::T.let(nil, ::T.untyped)
  UNBALANCED_COMMENT_PARENTHESIS = ::T.let(nil, ::T.untyped)
  UNEXPECTED_QUOTED_PAIR_SEQUENCE = ::T.let(nil, ::T.untyped)
  UNHANDLED_EXCEPTION = ::T.let(nil, ::T.untyped)
  UNMATCHED_QUOTED_PAIR = ::T.let(nil, ::T.untyped)
end

module Verifalia::EmailValidations::ExportedEntriesFormat
  CSV = ::T.let(nil, ::T.untyped)
  EXCEL_XLS = ::T.let(nil, ::T.untyped)
  EXCEL_XLSX = ::T.let(nil, ::T.untyped)
end

module Verifalia::EmailValidations::JobStatus
  COMPLETED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
  EXPIRED = ::T.let(nil, ::T.untyped)
  IN_PROGRESS = ::T.let(nil, ::T.untyped)
end

module Verifalia::Rest
  BASE_CCA_URLS = ::T.let(nil, ::T.untyped)
  BASE_URLS = ::T.let(nil, ::T.untyped)
end

class VestryMinute
  include ::VestryMinute::GeneratedAttributeMethods
  include ::VestryMinute::GeneratedAssociationMethods
  def autosave_associated_records_for_rich_text_body(*args); end

  def body(); end

  def body=(body); end

  def body?(); end

  def validate_associated_records_for_rich_text_body(*args); end
end

module VestryMinute::GeneratedAssociationMethods
  def build_rich_text_body(*args, &block); end

  def create_rich_text_body(*args, &block); end

  def create_rich_text_body!(*args, &block); end

  def reload_rich_text_body(); end

  def reset_rich_text_body(); end

  def rich_text_body(); end

  def rich_text_body=(value); end
end

module VestryMinute::GeneratedAssociationMethods
end

module VestryMinute::GeneratedAttributeMethods
end

module VestryMinute::GeneratedAttributeMethods
  extend ::Mutex_m
end

class VestryMinute
  def self.with_rich_text_body(*args, **arg); end

  def self.with_rich_text_body_and_embeds(*args, **arg); end
end

module Vips
  ARGUMENT_CONSTRUCT = ::T.let(nil, ::T.untyped)
  ARGUMENT_DEPRECATED = ::T.let(nil, ::T.untyped)
  ARGUMENT_FLAGS = ::T.let(nil, ::T.untyped)
  ARGUMENT_INPUT = ::T.let(nil, ::T.untyped)
  ARGUMENT_MODIFY = ::T.let(nil, ::T.untyped)
  ARGUMENT_OUTPUT = ::T.let(nil, ::T.untyped)
  ARGUMENT_REQUIRED = ::T.let(nil, ::T.untyped)
  ARGUMENT_SET_ALWAYS = ::T.let(nil, ::T.untyped)
  ARGUMENT_SET_ONCE = ::T.let(nil, ::T.untyped)
  ARRAY_DOUBLE_TYPE = ::T.let(nil, ::T.untyped)
  ARRAY_IMAGE_TYPE = ::T.let(nil, ::T.untyped)
  ARRAY_INT_TYPE = ::T.let(nil, ::T.untyped)
  BAND_FORMAT_TYPE = ::T.let(nil, ::T.untyped)
  BLEND_MODE_TYPE = ::T.let(nil, ::T.untyped)
  BLOB_TYPE = ::T.let(nil, ::T.untyped)
  CODING_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONCURRENCY = ::T.let(nil, ::T.untyped)
  IMAGE_TYPE = ::T.let(nil, ::T.untyped)
  INTERPRETATION_TYPE = ::T.let(nil, ::T.untyped)
  LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  LOG_DOMAIN = ::T.let(nil, ::T.untyped)
  MARSHAL_ALL = ::T.let(nil, ::T.untyped)
  MARSHAL_FINISH = ::T.let(nil, ::T.untyped)
  MARSHAL_PROGRESS = ::T.let(nil, ::T.untyped)
  MARSHAL_READ = ::T.let(nil, ::T.untyped)
  MARSHAL_SEEK = ::T.let(nil, ::T.untyped)
  MARSHAL_WRITE = ::T.let(nil, ::T.untyped)
  MAX_COORD = ::T.let(nil, ::T.untyped)
  OPERATION_DEPRECATED = ::T.let(nil, ::T.untyped)
  OPERATION_FLAGS = ::T.let(nil, ::T.untyped)
  OPERATION_NOCACHE = ::T.let(nil, ::T.untyped)
  OPERATION_SEQUENTIAL = ::T.let(nil, ::T.untyped)
  REFSTR_TYPE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Vips::Yard
  ALIAS = ::T.let(nil, ::T.untyped)
  MAP_GO_TO_RUBY = ::T.let(nil, ::T.untyped)
  NO_GENERATE = ::T.let(nil, ::T.untyped)
end

class Vnote
  include ::Vnote::GeneratedAttributeMethods
  include ::Vnote::GeneratedAssociationMethods
  def autosave_associated_records_for_comments(*args); end

  def autosave_associated_records_for_rich_text_content(*args); end

  def autosave_associated_records_for_user(*args); end

  def content(); end

  def content=(body); end

  def content?(); end

  def validate_associated_records_for_comments(*args); end

  def validate_associated_records_for_rich_text_content(*args); end
end

module Vnote::GeneratedAssociationMethods
  def build_rich_text_content(*args, &block); end

  def build_user(*args, &block); end

  def comment_ids(); end

  def comment_ids=(ids); end

  def comments(); end

  def comments=(value); end

  def create_rich_text_content(*args, &block); end

  def create_rich_text_content!(*args, &block); end

  def create_user(*args, &block); end

  def create_user!(*args, &block); end

  def reload_rich_text_content(); end

  def reload_user(); end

  def reset_rich_text_content(); end

  def reset_user(); end

  def rich_text_content(); end

  def rich_text_content=(value); end

  def user(); end

  def user=(value); end

  def user_changed?(); end

  def user_previously_changed?(); end
end

module Vnote::GeneratedAssociationMethods
end

module Vnote::GeneratedAttributeMethods
end

module Vnote::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Vnote
  def self.with_rich_text_content(*args, **arg); end

  def self.with_rich_text_content_and_embeds(*args, **arg); end
end

WEBrick::HTTPAuth::Authenticator::AuthException = WEBrick::HTTPStatus::Unauthorized

class WEBrick::HTTPAuth::DigestAuth::OpaqueInfo
  def self.keyword_init?(); end
end

WEBrick::HTTPAuth::ProxyAuthenticator::AuthException = WEBrick::HTTPStatus::ProxyAuthenticationRequired

class WEBrick::HTTPRequest
  def body_reader(); end

  def readpartial(size, buf=T.unsafe(nil)); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end

  def xhr?(); end
  MAX_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPResponse
  def make_body_tempfile(); end

  def remove_body_tempfile(); end

  def upgrade(); end

  def upgrade!(protocol); end

  def upgrade=(upgrade); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
  def <<(*buf); end

  def initialize(socket, resp); end

  def write(buf); end
end

class WEBrick::HTTPServer
  def create_request(with_webrick_config); end

  def create_response(with_webrick_config); end
end

class WEBrick::HTTPServlet::CGIHandler
  CGIRunnerArray = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPServlet::DefaultFileHandler
  def multipart_body(body, parts, boundary, mtype, filesize); end
end

class WEBrick::HTTPServlet::FileHandler
  def set_filesystem_encoding(str); end
end

class WEBrick::HTTPServlet::ProcHandler
  def do_PUT(request, response); end
end

class Warden::Proxy
  ENV_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  ENV_WARDEN_ERRORS = ::T.let(nil, ::T.untyped)
end

class Warden::SessionSerializer
  def user_deserialize(args); end

  def user_serialize(record); end
end

module Warden::Test::Helpers
  def login_as(user, opts=T.unsafe(nil)); end

  def logout(*scopes); end
end

module Warden::Test::Helpers
  def self.included(_base); end
end

module Warden::Test::Mock
  def warden(); end
end

class Warden::Test::Mock::Session
  def app(); end

  def app=(app); end

  def call(e); end

  def initialize(app, _configs=T.unsafe(nil)); end
end

class Warden::Test::Mock::Session
end

module Warden::Test::Mock
  def self.included(_base); end
end

module Warden::Test::WardenHelpers
  def _on_next_request(); end

  def asset_paths(); end

  def asset_paths=(*vals); end

  def on_next_request(&blk); end

  def test_reset!(); end
end

module Warden::Test::WardenHelpers
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebConsole::Context
  def extract(input=T.unsafe(nil)); end

  def initialize(binding); end
  GLOBAL_OBJECTS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Context
end

class WebConsole::DoubleRenderError
end

class WebConsole::DoubleRenderError
end

class WebConsole::Error
end

class WebConsole::Error
end

class WebConsole::Evaluator
  def cleaner(); end

  def eval(input); end

  def initialize(binding=T.unsafe(nil)); end
end

class WebConsole::Evaluator
  def self.cleaner(); end
end

class WebConsole::ExceptionMapper
  def [](index); end

  def exc(); end

  def first(); end

  def initialize(exception); end
end

class WebConsole::ExceptionMapper
  def self.find_binding(mappers, exception_object_id); end

  def self.follow(exc); end
end

class WebConsole::Injector
  def initialize(body, headers); end

  def inject(content); end
end

class WebConsole::Injector
end

module WebConsole::Interceptor
  def self.call(request, error); end
end

class WebConsole::Middleware
  def call(env); end

  def initialize(app); end

  def mount_point(); end

  def mount_point=(val); end

  def whiny_requests(); end

  def whiny_requests=(val); end
  TEMPLATES_PATH = ::T.let(nil, ::T.untyped)
end

class WebConsole::Middleware
  def self.mount_point(); end

  def self.mount_point=(val); end

  def self.whiny_requests(); end

  def self.whiny_requests=(val); end
end

class WebConsole::Permissions
  def include?(network); end

  def initialize(networks=T.unsafe(nil)); end
  ALWAYS_PERMITTED_NETWORKS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Railtie
  def web_console_permissions(); end
end

class WebConsole::Request
  def permissions(); end

  def permissions=(val); end

  def permitted?(); end

  def strict_remote_ip(); end
end

class WebConsole::Request::GetSecureIp
  def initialize(req, proxies); end
end

class WebConsole::Request
  def self.permissions(); end

  def self.permissions=(val); end
end

class WebConsole::Session
  def context(objpath); end

  def eval(input); end

  def id(); end

  def initialize(exception_mappers); end

  def inmemory_storage(); end

  def switch_binding_to(index, exception_object_id); end
end

class WebConsole::Session
  def self.find(id); end

  def self.from(storage); end

  def self.inmemory_storage(); end
end

class WebConsole::SourceLocation
  def initialize(binding); end

  def lineno(); end

  def path(); end
end

class WebConsole::SourceLocation
end

class WebConsole::Template
  def initialize(env, session); end

  def render(template); end

  def template_paths(); end

  def template_paths=(val); end
end

class WebConsole::Template
  def self.template_paths(); end

  def self.template_paths=(val); end
end

class WebConsole::View
  def only_on_error_page(*args); end

  def only_on_regular_page(*args); end

  def render(*arg); end

  def render_inlined_string(template); end

  def render_javascript(template); end

  def t(key, options=T.unsafe(nil)); end
end

class WebConsole::View
end

class WebConsole::WhinyRequest
  def permitted?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class WebConsole::WhinyRequest
end

module WebConsole
  def self.deprecator(); end

  def self.logger(); end
end

module WebSocket
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver
  def add_extension(extension); end

  def binary(message); end

  def close(reason=T.unsafe(nil), code=T.unsafe(nil)); end

  def initialize(socket, options=T.unsafe(nil)); end

  def ping(*args); end

  def pong(*args); end

  def protocol(); end

  def ready_state(); end

  def set_header(name, value); end

  def start(); end

  def state(); end

  def text(message); end
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  PORTS = ::T.let(nil, ::T.untyped)
  STATES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def headers(); end

  def proxy(origin, options=T.unsafe(nil)); end

  def status(); end
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def self.generate_key(); end
end

class WebSocket::Driver::CloseEvent
  def code(); end

  def code=(_); end

  def reason(); end

  def reason=(_); end
end

class WebSocket::Driver::CloseEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::ConnectEvent
end

class WebSocket::Driver::ConnectEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::Draft75
  def frame(buffer, type=T.unsafe(nil), error_type=T.unsafe(nil)); end

  def parse(chunk); end

  def version(); end
end

class WebSocket::Driver::Draft75
end

class WebSocket::Driver::Draft76
  BODY_SIZE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Draft76
end

module WebSocket::Driver::EventEmitter
  def add_listener(event, callable=T.unsafe(nil), &block); end

  def emit(event, *args); end

  def initialize(); end

  def listener_count(event); end

  def listeners(event); end

  def on(event, callable=T.unsafe(nil), &block); end

  def remove_all_listeners(event=T.unsafe(nil)); end

  def remove_listener(event, callable=T.unsafe(nil), &block); end
end

class WebSocket::Driver::Headers
  def [](name); end

  def []=(name, value); end

  def clear(); end

  def initialize(received=T.unsafe(nil)); end

  def to_h(); end
  ALLOWED_DUPLICATES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Headers
end

class WebSocket::Driver::Hybi
  def frame(buffer, type=T.unsafe(nil), code=T.unsafe(nil)); end

  def parse(chunk); end

  def ping(message=T.unsafe(nil), &callback); end

  def pong(message=T.unsafe(nil)); end

  def version(); end
  BYTE = ::T.let(nil, ::T.untyped)
  DEFAULT_ERROR_CODE = ::T.let(nil, ::T.untyped)
  ERRORS = ::T.let(nil, ::T.untyped)
  ERROR_CODES = ::T.let(nil, ::T.untyped)
  FIN = ::T.let(nil, ::T.untyped)
  GUID = ::T.let(nil, ::T.untyped)
  LENGTH = ::T.let(nil, ::T.untyped)
  MASK = ::T.let(nil, ::T.untyped)
  MAX_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
  MIN_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  OPCODE = ::T.let(nil, ::T.untyped)
  OPCODES = ::T.let(nil, ::T.untyped)
  OPCODE_CODES = ::T.let(nil, ::T.untyped)
  OPENING_OPCODES = ::T.let(nil, ::T.untyped)
  PACK_FORMATS = ::T.let(nil, ::T.untyped)
  RSV1 = ::T.let(nil, ::T.untyped)
  RSV2 = ::T.let(nil, ::T.untyped)
  RSV3 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Hybi::Frame
  def final(); end

  def final=(final); end

  def length(); end

  def length=(length); end

  def length_bytes(); end

  def length_bytes=(length_bytes); end

  def masked(); end

  def masked=(masked); end

  def masking_key(); end

  def masking_key=(masking_key); end

  def opcode(); end

  def opcode=(opcode); end

  def payload(); end

  def payload=(payload); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Frame
end

class WebSocket::Driver::Hybi::Message
  def <<(frame); end

  def data(); end

  def data=(data); end

  def opcode(); end

  def opcode=(opcode); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Message
end

class WebSocket::Driver::Hybi
  def self.generate_accept(key); end
end

class WebSocket::Driver::MessageEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::MessageEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::OpenEvent
end

class WebSocket::Driver::OpenEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::PingEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::PingEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::PongEvent
  def data(); end

  def data=(_); end
end

class WebSocket::Driver::PongEvent
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class WebSocket::Driver::Proxy
  include ::WebSocket::Driver::EventEmitter
  def headers(); end

  def initialize(client, origin, options); end

  def parse(chunk); end

  def set_header(name, value); end

  def start(); end

  def status(); end
end

class WebSocket::Driver::Proxy
end

class WebSocket::Driver::Server
  def add_extension(*args, &block); end

  def binary(*args, &block); end

  def close(*args, &block); end

  def env(); end

  def frame(*args, &block); end

  def parse(chunk); end

  def ping(*args, &block); end

  def set_header(*args, &block); end

  def start(*args, &block); end

  def text(*args, &block); end

  def url(); end

  def version(); end

  def write(buffer); end
  EVENTS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Server
end

class WebSocket::Driver::StreamReader
  def each_byte(); end

  def put(chunk); end

  def read(length); end
  MINIMUM_AUTOMATIC_PRUNE_OFFSET = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::StreamReader
end

class WebSocket::Driver
  def self.client(socket, options=T.unsafe(nil)); end

  def self.encode(data, encoding=T.unsafe(nil)); end

  def self.host_header(uri); end

  def self.rack(socket, options=T.unsafe(nil)); end

  def self.server(socket, options=T.unsafe(nil)); end

  def self.validate_options(options, valid_keys); end

  def self.websocket?(env); end
end

class WebSocket::Error
end

class WebSocket::Error::Frame
end

class WebSocket::Error::Frame::ControlFramePayloadTooLong
end

class WebSocket::Error::Frame::ControlFramePayloadTooLong
end

class WebSocket::Error::Frame::DataFrameInsteadContinuation
end

class WebSocket::Error::Frame::DataFrameInsteadContinuation
end

class WebSocket::Error::Frame::FragmentedControlFrame
end

class WebSocket::Error::Frame::FragmentedControlFrame
end

class WebSocket::Error::Frame::Invalid
end

class WebSocket::Error::Frame::Invalid
end

class WebSocket::Error::Frame::InvalidPayloadEncoding
end

class WebSocket::Error::Frame::InvalidPayloadEncoding
end

class WebSocket::Error::Frame::MaskTooShort
end

class WebSocket::Error::Frame::MaskTooShort
end

class WebSocket::Error::Frame::ReservedBitUsed
end

class WebSocket::Error::Frame::ReservedBitUsed
end

class WebSocket::Error::Frame::TooLong
end

class WebSocket::Error::Frame::TooLong
end

class WebSocket::Error::Frame::UnexpectedContinuationFrame
end

class WebSocket::Error::Frame::UnexpectedContinuationFrame
end

class WebSocket::Error::Frame::UnknownCloseCode
end

class WebSocket::Error::Frame::UnknownCloseCode
end

class WebSocket::Error::Frame::UnknownFrameType
end

class WebSocket::Error::Frame::UnknownFrameType
end

class WebSocket::Error::Frame::UnknownOpcode
end

class WebSocket::Error::Frame::UnknownOpcode
end

class WebSocket::Error::Frame::UnknownVersion
end

class WebSocket::Error::Frame::UnknownVersion
end

class WebSocket::Error::Frame
end

class WebSocket::Error::Handshake
end

class WebSocket::Error::Handshake::GetRequestRequired
end

class WebSocket::Error::Handshake::GetRequestRequired
end

class WebSocket::Error::Handshake::InvalidAuthentication
end

class WebSocket::Error::Handshake::InvalidAuthentication
end

class WebSocket::Error::Handshake::InvalidHeader
end

class WebSocket::Error::Handshake::InvalidHeader
end

class WebSocket::Error::Handshake::InvalidStatusCode
end

class WebSocket::Error::Handshake::InvalidStatusCode
end

class WebSocket::Error::Handshake::NoHostProvided
end

class WebSocket::Error::Handshake::NoHostProvided
end

class WebSocket::Error::Handshake::UnknownVersion
end

class WebSocket::Error::Handshake::UnknownVersion
end

class WebSocket::Error::Handshake::UnsupportedProtocol
end

class WebSocket::Error::Handshake::UnsupportedProtocol
end

class WebSocket::Error::Handshake
end

class WebSocket::Error
end

module WebSocket::ExceptionHandler
  def error(); end

  def error=(error); end
end

module WebSocket::ExceptionHandler::ClassMethods
  def rescue_method(method_name, options=T.unsafe(nil)); end
end

module WebSocket::ExceptionHandler::ClassMethods
end

module WebSocket::ExceptionHandler
  def self.included(base); end
end

class WebSocket::Extensions
  def activate(header); end

  def add(ext); end

  def close(); end

  def generate_offer(); end

  def generate_response(header); end

  def process_incoming_message(message); end

  def process_outgoing_message(message); end

  def valid_frame_rsv(frame); end

  def valid_frame_rsv?(frame); end
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser
  EXT = ::T.let(nil, ::T.untyped)
  EXT_LIST = ::T.let(nil, ::T.untyped)
  NOTOKEN = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PARAM = ::T.let(nil, ::T.untyped)
  QUOTED = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser
  def self.parse_header(header); end

  def self.serialize_params(name, params); end
end

module WebSocket::Frame
end

class WebSocket::Frame::Base
  include ::WebSocket::ExceptionHandler
  include ::WebSocket::NiceInspect
  def code(); end

  def code=(code); end

  def data(); end

  def data=(data); end

  def error?(); end

  def initialize(*args); end

  def initialize_with_rescue(*args); end

  def support_type?(); end

  def supported_frames(); end

  def type(); end

  def version(); end
end

class WebSocket::Frame::Base
  extend ::WebSocket::ExceptionHandler::ClassMethods
end

class WebSocket::Frame::Data
  def <<(*args); end

  def convert_args(args); end

  def getbytes(start_index, count); end

  def initialize(*args); end

  def mask(payload, mask); end

  def set_mask(); end

  def unset_mask(); end
end

class WebSocket::Frame::Data
end

module WebSocket::Frame::Handler
end

class WebSocket::Frame::Handler::Base
  def decode_frame(); end

  def encode_frame(); end

  def initialize(frame); end
end

class WebSocket::Frame::Handler::Base
end

class WebSocket::Frame::Handler::Handler03
  def masking?(); end

  def supported_frames(); end
  FRAME_TYPES = ::T.let(nil, ::T.untyped)
  FRAME_TYPES_INVERSE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Frame::Handler::Handler03
end

class WebSocket::Frame::Handler::Handler04
end

class WebSocket::Frame::Handler::Handler04
end

class WebSocket::Frame::Handler::Handler05
end

class WebSocket::Frame::Handler::Handler05
end

class WebSocket::Frame::Handler::Handler07
  FRAME_TYPES = ::T.let(nil, ::T.untyped)
  FRAME_TYPES_INVERSE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Frame::Handler::Handler07
end

class WebSocket::Frame::Handler::Handler75
  def supported_frames(); end
end

class WebSocket::Frame::Handler::Handler75
end

module WebSocket::Frame::Handler
end

class WebSocket::Frame::Incoming
  def <<(data); end

  def decoded?(); end

  def initialize(args=T.unsafe(nil)); end

  def next(*args); end

  def next_with_rescue(*args); end

  def next_without_rescue(); end
end

class WebSocket::Frame::Incoming::Client
  def incoming_masking?(); end

  def outgoing_masking?(); end
end

class WebSocket::Frame::Incoming::Client
end

class WebSocket::Frame::Incoming::Server
  def incoming_masking?(); end

  def outgoing_masking?(); end
end

class WebSocket::Frame::Incoming::Server
end

class WebSocket::Frame::Incoming
end

class WebSocket::Frame::Outgoing
  def require_sending?(); end

  def supported?(); end

  def to_s(*args); end

  def to_s_with_rescue(*args); end

  def to_s_without_rescue(); end
end

class WebSocket::Frame::Outgoing::Client
  def incoming_masking?(); end

  def outgoing_masking?(); end
end

class WebSocket::Frame::Outgoing::Client
end

class WebSocket::Frame::Outgoing::Server
  def incoming_masking?(); end

  def outgoing_masking?(); end
end

class WebSocket::Frame::Outgoing::Server
end

class WebSocket::Frame::Outgoing
end

module WebSocket::Frame
end

module WebSocket::HTTP
end

module WebSocket::HTTP::Headers
  def complete?(); end

  def error?(); end

  def headers(); end

  def initialize(); end

  def parse(chunk); end
  CR = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  MAX_LINE_LENGTH = ::T.let(nil, ::T.untyped)
end

module WebSocket::HTTP::Headers
end

class WebSocket::HTTP::Request
  include ::WebSocket::HTTP::Headers
  def env(); end
  REQUEST_LINE = ::T.let(nil, ::T.untyped)
  REQUEST_TARGET = ::T.let(nil, ::T.untyped)
  RESERVED_HEADERS = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Request
end

class WebSocket::HTTP::Response
  include ::WebSocket::HTTP::Headers
  def [](name); end

  def body(); end

  def code(); end
  STATUS_LINE = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Response
end

module WebSocket::HTTP
  def self.normalize_header(name); end
end

module WebSocket::Handshake
end

class WebSocket::Handshake::Base
  include ::WebSocket::ExceptionHandler
  include ::WebSocket::NiceInspect
  def <<(data); end

  def default_port(); end

  def default_port?(); end

  def finished?(); end

  def headers(); end

  def host(); end

  def initialize(args=T.unsafe(nil)); end

  def leftovers(); end

  def path(); end

  def port(); end

  def protocols(); end

  def query(); end

  def secure(); end

  def should_respond?(); end

  def state(); end

  def to_s(*args); end

  def to_s_with_rescue(*args); end

  def to_s_without_rescue(); end

  def uri(); end

  def valid?(*args); end

  def version(); end
  HEADER = ::T.let(nil, ::T.untyped)
end

class WebSocket::Handshake::Base
  extend ::WebSocket::ExceptionHandler::ClassMethods
end

class WebSocket::Handshake::Client
  def <<(*args); end

  def initialize(*args); end

  def initialize_with_rescue(*args); end

  def origin(); end
  FIRST_LINE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Handshake::Client
end

module WebSocket::Handshake::Handler
end

class WebSocket::Handshake::Handler::Base
  def initialize(handshake); end

  def valid?(); end
end

class WebSocket::Handshake::Handler::Base
end

class WebSocket::Handshake::Handler::Client
end

class WebSocket::Handshake::Handler::Client
end

class WebSocket::Handshake::Handler::Client01
end

class WebSocket::Handshake::Handler::Client01
end

class WebSocket::Handshake::Handler::Client04
end

class WebSocket::Handshake::Handler::Client04
end

class WebSocket::Handshake::Handler::Client11
end

class WebSocket::Handshake::Handler::Client11
end

class WebSocket::Handshake::Handler::Client75
end

class WebSocket::Handshake::Handler::Client75
end

class WebSocket::Handshake::Handler::Client76
  NOISE_CHARS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Handshake::Handler::Client76
end

class WebSocket::Handshake::Handler::Server
end

class WebSocket::Handshake::Handler::Server
end

class WebSocket::Handshake::Handler::Server04
end

class WebSocket::Handshake::Handler::Server04
end

class WebSocket::Handshake::Handler::Server75
end

class WebSocket::Handshake::Handler::Server75
end

class WebSocket::Handshake::Handler::Server76
end

class WebSocket::Handshake::Handler::Server76
end

module WebSocket::Handshake::Handler
end

class WebSocket::Handshake::Server
  def <<(*args); end

  def from_hash(hash); end

  def from_rack(env); end
  PATH = ::T.let(nil, ::T.untyped)
end

class WebSocket::Handshake::Server
end

module WebSocket::Handshake
end

module WebSocket::Mask
end

module WebSocket::Mask
  def self.mask(arg, arg1); end
end

module WebSocket::NiceInspect
  def inspect(); end
end

module WebSocket::NiceInspect
end

module WebSocket
  def self.max_frame_size(); end

  def self.max_frame_size=(val); end

  def self.should_raise(); end

  def self.should_raise=(val); end
end

class WebhookEvent
  include ::WebhookEvent::GeneratedAttributeMethods
  include ::WebhookEvent::GeneratedAssociationMethods
end

module WebhookEvent::GeneratedAssociationMethods
end

module WebhookEvent::GeneratedAssociationMethods
end

module WebhookEvent::GeneratedAttributeMethods
end

module WebhookEvent::GeneratedAttributeMethods
  extend ::Mutex_m
end

class WebhookEvent
  def self.failed(*args, **arg); end

  def self.not_failed(*args, **arg); end

  def self.not_pending(*args, **arg); end

  def self.not_processed(*args, **arg); end

  def self.not_processing(*args, **arg); end

  def self.pending(*args, **arg); end

  def self.processed(*args, **arg); end

  def self.processing(*args, **arg); end

  def self.states(); end
end

module XPath::DSL
  def !(*args); end

  def !=(rhs); end

  def %(rhs); end

  def &(rhs); end

  def *(rhs); end

  def +(*expressions); end

  def /(rhs); end

  def <(rhs); end

  def <=(rhs); end

  def ==(rhs); end

  def >(rhs); end

  def >=(rhs); end

  def [](expression); end

  def ancestor(*element_names); end

  def ancestor_or_self(*element_names); end

  def and(rhs); end

  def anywhere(*expressions); end

  def attr(expression); end

  def attribute(*element_names); end

  def axis(name, *element_names); end

  def binary_operator(name, rhs); end

  def boolean(*args); end

  def ceiling(*args); end

  def child(*expressions); end

  def concat(*args); end

  def contains(*args); end

  def contains_word(word); end

  def count(*args); end

  def css(selector); end

  def current(); end

  def descendant(*expressions); end

  def descendant_or_self(*element_names); end

  def divide(rhs); end

  def ends_with(suffix); end

  def equals(rhs); end

  def false(*args); end

  def floor(*args); end

  def following(*element_names); end

  def following_sibling(*element_names); end

  def function(name, *arguments); end

  def gt(rhs); end

  def gte(rhs); end

  def id(*args); end

  def inverse(*args); end

  def is(expression); end

  def join(*expressions); end

  def lang(*args); end

  def last(); end

  def local_name(*args); end

  def lowercase(); end

  def lt(rhs); end

  def lte(rhs); end

  def method(name, *arguments); end

  def minus(rhs); end

  def mod(rhs); end

  def multiply(rhs); end

  def n(*args); end

  def namespace(*element_names); end

  def namespace_uri(*args); end

  def next_sibling(*expressions); end

  def normalize(*args); end

  def normalize_space(*args); end

  def not(*args); end

  def not_equals(rhs); end

  def number(*args); end

  def one_of(*expressions); end

  def or(rhs); end

  def parent(*element_names); end

  def plus(rhs); end

  def position(); end

  def preceding(*element_names); end

  def preceding_sibling(*element_names); end

  def previous_sibling(*expressions); end

  def qname(); end

  def round(*args); end

  def self(*element_names); end

  def self_axis(*element_names); end

  def starts_with(*args); end

  def string(*args); end

  def string_length(*args); end

  def substring(*args); end

  def substring_after(*args); end

  def substring_before(*args); end

  def sum(*args); end

  def text(); end

  def translate(*args); end

  def true(*args); end

  def union(*expressions); end

  def uppercase(); end

  def where(expression); end

  def |(rhs); end

  def ~(*args); end
  AXES = ::T.let(nil, ::T.untyped)
  LOWERCASE_LETTERS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  UPPERCASE_LETTERS = ::T.let(nil, ::T.untyped)
end

class XPath::Expression
  def arguments(); end

  def arguments=(arguments); end

  def expression(); end

  def expression=(expression); end

  def initialize(expression, *arguments); end

  def to_s(type=T.unsafe(nil)); end

  def to_xpath(type=T.unsafe(nil)); end
end

class XPath::Literal
  def initialize(value); end

  def value(); end
end

class XPath::Renderer
  def anywhere(element_names); end

  def attribute(current, name); end

  def axis(current, name, element_names); end

  def binary_operator(name, left, right); end

  def child(current, element_names); end

  def convert_argument(argument); end

  def css(current, selector); end

  def descendant(current, element_names); end

  def function(name, *arguments); end

  def initialize(type); end

  def is(one, two); end

  def join(*expressions); end

  def literal(node); end

  def render(node); end

  def string_literal(string); end

  def text(current); end

  def this_node(); end

  def union(*expressions); end

  def variable(name); end

  def where(on, condition); end
end

class XPath::Renderer
  def self.render(node, type); end
end

class XPath::Union
  def arguments(); end

  def each(&block); end

  def expression(); end

  def expressions(); end

  def initialize(*expressions); end

  def method_missing(*args); end

  def to_s(type=T.unsafe(nil)); end

  def to_xpath(type=T.unsafe(nil)); end
end

module XPath
  def self.generate(); end
end

module YARD
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  TEMPLATE_ROOT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Command
  def common_options(opts); end

  def description(); end

  def load_script(file); end

  def parse_options(opts, args); end

  def unrecognized_option(err); end
end

class YARD::CLI::Command
  def self.run(*args); end
end

class YARD::CLI::CommandParser
  def run(*args); end
end

class YARD::CLI::CommandParser
  def self.commands(); end

  def self.commands=(commands); end

  def self.default_command(); end

  def self.default_command=(default_command); end

  def self.run(*args); end
end

class YARD::CLI::Config
  def append(); end

  def append=(append); end

  def as_list(); end

  def as_list=(as_list); end

  def gem_install_cmd(); end

  def gem_install_cmd=(gem_install_cmd); end

  def key(); end

  def key=(key); end

  def reset(); end

  def reset=(reset); end

  def run(*args); end

  def values(); end

  def values=(values); end
end

class YARD::CLI::Config
end

class YARD::CLI::Diff
  def run(*args); end
end

class YARD::CLI::Diff
end

class YARD::CLI::Display
  def format_objects(); end

  def initialize(*args); end

  def wrap_layout(contents); end
end

class YARD::CLI::Display
end

class YARD::CLI::Gems
  def run(*args); end
end

class YARD::CLI::Gems
end

class YARD::CLI::Graph
  def objects(); end

  def options(); end

  def run(*args); end
end

class YARD::CLI::Graph
end

class YARD::CLI::Help
  def run(*args); end
end

class YARD::CLI::Help
end

class YARD::CLI::I18n
end

class YARD::CLI::I18n
end

class YARD::CLI::List
  def run(*args); end
end

class YARD::CLI::List
end

class YARD::CLI::MarkupTypes
  def run(*args); end
end

class YARD::CLI::MarkupTypes
end

class YARD::CLI::Server
  def adapter(); end

  def adapter=(adapter); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def run(*args); end

  def scripts(); end

  def scripts=(scripts); end

  def server_options(); end

  def server_options=(server_options); end

  def template_paths(); end

  def template_paths=(template_paths); end
end

class YARD::CLI::Server
end

class YARD::CLI::Stats
  include ::YARD::Templates::Helpers::BaseHelper
  def initialize(parse=T.unsafe(nil)); end

  def output(name, data, undoc=T.unsafe(nil)); end

  def parse(); end

  def parse=(parse); end

  def print_statistics(); end

  def print_undocumented_objects(); end

  def stats_for_attributes(); end

  def stats_for_classes(); end

  def stats_for_constants(); end

  def stats_for_files(); end

  def stats_for_methods(); end

  def stats_for_modules(); end
  STATS_ORDER = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Stats
end

class YARD::CLI::YRI
  def cache_object(name, path); end

  def find_object(name); end

  def print_object(object); end

  def print_usage(); end

  def run(*args); end
  CACHE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  SEARCH_PATHS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YRI
end

class YARD::CLI::Yardoc
  def all_objects(); end

  def apis(); end

  def apis=(apis); end

  def assets(); end

  def assets=(assets); end

  def excluded(); end

  def excluded=(excluded); end

  def fail_on_warning(); end

  def fail_on_warning=(fail_on_warning); end

  def files(); end

  def files=(files); end

  def generate(); end

  def generate=(generate); end

  def has_markup(); end

  def has_markup=(has_markup); end

  def hidden_apis(); end

  def hidden_apis=(hidden_apis); end

  def hidden_tags(); end

  def hidden_tags=(hidden_tags); end

  def list(); end

  def list=(list); end

  def options(); end

  def run(*args); end

  def save_yardoc(); end

  def save_yardoc=(save_yardoc); end

  def statistics(); end

  def statistics=(statistics); end

  def use_cache(); end

  def use_cache=(use_cache); end

  def visibilities(); end

  def visibilities=(visibilities); end
end

class YARD::CLI::YardocOptions
  def file(); end

  def file=(file); end

  def files(); end

  def files=(files); end

  def item(); end

  def item=(item); end

  def locale(); end

  def locale=(locale); end

  def objects(); end

  def objects=(objects); end

  def onefile(); end

  def onefile=(onefile); end

  def readme(); end

  def readme=(readme); end

  def title(); end

  def title=(title); end
end

class YARD::CLI::YardoptsCommand
  def options_file(); end

  def options_file=(options_file); end

  def parse_arguments(*args); end

  def use_document_file(); end

  def use_document_file=(use_document_file); end

  def use_yardopts_file(); end

  def use_yardopts_file=(use_yardopts_file); end

  def yardopts_options(opts); end
  DEFAULT_YARDOPTS_FILE = ::T.let(nil, ::T.untyped)
end

module YARD::CodeObjects
  BUILTIN_ALL = ::T.let(nil, ::T.untyped)
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS_HASH = ::T.let(nil, ::T.untyped)
  BUILTIN_MODULES = ::T.let(nil, ::T.untyped)
  CONSTANTMATCH = ::T.let(nil, ::T.untyped)
  CONSTANTSTART = ::T.let(nil, ::T.untyped)
  CSEP = ::T.let(nil, ::T.untyped)
  CSEPQ = ::T.let(nil, ::T.untyped)
  ISEP = ::T.let(nil, ::T.untyped)
  ISEPQ = ::T.let(nil, ::T.untyped)
  METHODMATCH = ::T.let(nil, ::T.untyped)
  METHODNAMEMATCH = ::T.let(nil, ::T.untyped)
  NAMESPACEMATCH = ::T.let(nil, ::T.untyped)
  NSEP = ::T.let(nil, ::T.untyped)
  NSEPQ = ::T.let(nil, ::T.untyped)
  PROXY_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::Base
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def add_file(file, line=T.unsafe(nil), has_comments=T.unsafe(nil)); end

  def add_tag(*tags); end

  def base_docstring(); end

  def copy_to(other); end

  def copyable_attributes(); end

  def docstring(locale=T.unsafe(nil)); end

  def docstring=(comments); end

  def dynamic(); end

  def dynamic=(dynamic); end

  def dynamic?(); end

  def eql?(other); end

  def equal?(other); end

  def file(); end

  def files(); end

  def format(options=T.unsafe(nil)); end

  def group(); end

  def group=(group); end

  def has_tag?(name); end

  def line(); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def namespace=(obj); end

  def parent(); end

  def parent=(obj); end

  def path(); end

  def relative_path(other); end

  def root?(); end

  def sep(); end

  def signature(); end

  def signature=(signature); end

  def source(); end

  def source=(statement); end

  def source_type(); end

  def source_type=(source_type); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def title(); end

  def to_ary(); end

  def type(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::CodeObjects::Base
  def self.===(other); end

  def self.new(namespace, name, *args, &block); end
end

class YARD::CodeObjects::ClassObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end

  def inherited_constants(); end

  def inherited_meths(opts=T.unsafe(nil)); end

  def is_exception?(); end

  def superclass(); end

  def superclass=(object); end
end

class YARD::CodeObjects::ClassVariableObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ClassVariableObject
end

class YARD::CodeObjects::CodeObjectList
  def <<(value); end

  def initialize(owner=T.unsafe(nil)); end

  def push(value); end
end

class YARD::CodeObjects::ConstantObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ExtendedMethodObject
  def initialize(obj); end

  def method_missing(sym, *args, &block); end

  def scope(); end
end

class YARD::CodeObjects::ExtendedMethodObject
end

class YARD::CodeObjects::ExtraFileObject
  def ==(other); end

  def attributes(); end

  def attributes=(attributes); end

  def contents(); end

  def contents=(contents); end

  def eql?(other); end

  def equal?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(filename, contents=T.unsafe(nil)); end

  def locale(); end

  def locale=(locale); end

  def name(); end

  def name=(name); end

  def path(); end

  def title(); end

  def type(); end
end

class YARD::CodeObjects::ExtraFileObject
end

class YARD::CodeObjects::MacroObject
  def attached?(); end

  def expand(call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def macro_data(); end

  def macro_data=(macro_data); end

  def method_object(); end

  def method_object=(method_object); end
  MACRO_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::MacroObject
  def self.apply(docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil), _method_object=T.unsafe(nil)); end

  def self.apply_macro(macro, docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.create(macro_name, data, method_object=T.unsafe(nil)); end

  def self.create_docstring(macro_name, data, method_object=T.unsafe(nil)); end

  def self.expand(macro_data, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.find(macro_name); end

  def self.find_or_create(macro_name, data, method_object=T.unsafe(nil)); end
end

class YARD::CodeObjects::MethodObject
  def aliases(); end

  def attr_info(); end

  def constructor?(); end

  def explicit(); end

  def explicit=(explicit); end

  def initialize(namespace, name, scope=T.unsafe(nil), &block); end

  def is_alias?(); end

  def is_attribute?(); end

  def is_explicit?(); end

  def module_function?(); end

  def overridden_method(); end

  def parameters(); end

  def parameters=(parameters); end

  def reader?(); end

  def scope(); end

  def scope=(v); end

  def writer?(); end
end

class YARD::CodeObjects::ModuleObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end
end

class YARD::CodeObjects::ModuleObject
end

module YARD::CodeObjects::NamespaceMapper
  def clear_separators(); end

  def default_separator(value=T.unsafe(nil)); end

  def register_separator(sep, *valid_types); end

  def separators(); end

  def separators_for_type(type); end

  def separators_match(); end

  def types_for_separator(sep); end

  def unregister_separator_by_type(type); end
end

module YARD::CodeObjects::NamespaceMapper
  def self.default_separator(); end

  def self.default_separator=(default_separator); end

  def self.invalidate(); end

  def self.map(); end

  def self.map_match(); end

  def self.on_invalidate(&block); end

  def self.rev_map(); end
end

class YARD::CodeObjects::NamespaceObject
  def aliases(); end

  def attributes(); end

  def child(opts=T.unsafe(nil)); end

  def children(); end

  def class_attributes(); end

  def class_mixins(); end

  def constants(opts=T.unsafe(nil)); end

  def cvars(); end

  def groups(); end

  def groups=(groups); end

  def included_constants(); end

  def included_meths(opts=T.unsafe(nil)); end

  def initialize(namespace, name, *args, &block); end

  def instance_attributes(); end

  def instance_mixins(); end

  def meths(opts=T.unsafe(nil)); end
end

class YARD::CodeObjects::Proxy
  def ==(other); end

  def ===(other); end

  def equal?(other); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def parent(); end

  def path(); end

  def respond_to?(meth, include_private=T.unsafe(nil)); end

  def root?(); end

  def title(); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class YARD::CodeObjects::Proxy
  def self.===(other); end
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::RootObject
end

class YARD::CodeObjects::RootObject
end

class YARD::Config
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  CONFIG_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG_OPTIONS = ::T.let(nil, ::T.untyped)
  IGNORED_PLUGINS = ::T.let(nil, ::T.untyped)
  YARD_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class YARD::Config
  def self.add_ignored_plugins_file(); end

  def self.arguments(); end

  def self.load(); end

  def self.load_autoload_plugins(); end

  def self.load_commandline_plugins(); end

  def self.load_commandline_safemode(); end

  def self.load_gem_plugins(); end

  def self.load_plugin(name); end

  def self.load_plugin_failed(name, exception); end

  def self.load_plugins(); end

  def self.options(); end

  def self.options=(options); end

  def self.read_config_file(); end

  def self.save(); end

  def self.translate_plugin_name(name); end

  def self.translate_plugin_names(); end

  def self.with_yardopts(); end
end

class YARD::Docstring
  def +(other); end

  def add_tag(*tags); end

  def all(); end

  def all=(content, parse=T.unsafe(nil)); end

  def blank?(only_visible_tags=T.unsafe(nil)); end

  def delete_tag_if(&block); end

  def delete_tags(name); end

  def has_tag?(name); end

  def hash_flag(); end

  def hash_flag=(v); end

  def initialize(content=T.unsafe(nil), object=T.unsafe(nil)); end

  def line(); end

  def line_range(); end

  def line_range=(line_range); end

  def object(); end

  def object=(object); end

  def ref_tags(); end

  def replace(content, parse=T.unsafe(nil)); end

  def resolve_reference(); end

  def summary(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def to_raw(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Docstring
  def self.default_parser(); end

  def self.default_parser=(default_parser); end

  def self.new!(text, tags=T.unsafe(nil), object=T.unsafe(nil), raw_data=T.unsafe(nil), ref_object=T.unsafe(nil)); end

  def self.parser(*args); end
end

class YARD::DocstringParser
  def create_directive(tag_name, tag_buf); end

  def create_ref_tag(tag_name, name, object_name); end

  def create_tag(tag_name, tag_buf=T.unsafe(nil)); end

  def directives(); end

  def directives=(directives); end

  def handler(); end

  def handler=(handler); end

  def initialize(library=T.unsafe(nil)); end

  def library(); end

  def library=(library); end

  def object(); end

  def object=(object); end

  def parse(content, object=T.unsafe(nil), handler=T.unsafe(nil)); end

  def parse_content(content); end

  def post_process(); end

  def raw_text(); end

  def raw_text=(raw_text); end

  def reference(); end

  def reference=(reference); end

  def state(); end

  def state=(state); end

  def tag_is_directive?(tag_name); end

  def tags(); end

  def tags=(tags); end

  def text(); end

  def text=(text); end

  def to_docstring(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::DocstringParser
  def self.after_parse(&block); end

  def self.after_parse_callbacks(); end
end

module YARD::GemIndex
end

module YARD::GemIndex
  def self.all(); end

  def self.each(&block); end

  def self.find_all_by_name(*args); end
end

class YARD::Handlers::Base
  def abort!(); end

  def call_params(); end

  def caller_method(); end

  def ensure_loaded!(object, max_retries=T.unsafe(nil)); end

  def extra_state(); end

  def globals(); end

  def initialize(source_parser, stmt); end

  def namespace(); end

  def namespace=(v); end

  def owner(); end

  def owner=(v); end

  def parse_block(*arg); end

  def parser(); end

  def process(); end

  def push_state(opts=T.unsafe(nil)); end

  def register(*objects); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end

  def register_dynamic(object); end

  def register_ensure_loaded(object); end

  def register_file_info(object, file=T.unsafe(nil), line=T.unsafe(nil), comments=T.unsafe(nil)); end

  def register_group(object, group=T.unsafe(nil)); end

  def register_module_function(object); end

  def register_source(object, source=T.unsafe(nil), type=T.unsafe(nil)); end

  def register_transitive_tags(object); end

  def register_visibility(object, visibility=T.unsafe(nil)); end

  def scope(); end

  def scope=(v); end

  def statement(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::Handlers::Base
  def self.clear_subclasses(); end

  def self.handles(*matches); end

  def self.handles?(statement); end

  def self.in_file(filename); end

  def self.inherited(subclass); end

  def self.matches_file?(filename); end

  def self.namespace_only(); end

  def self.namespace_only?(); end

  def self.process(&block); end
end

class YARD::Handlers::C::AliasHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AliasHandler
end

class YARD::Handlers::C::AttributeHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AttributeHandler
end

class YARD::Handlers::C::Base
  include ::YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::Handlers::Common::MethodHandler
  def ensure_variable_defined!(var, max_retries=T.unsafe(nil)); end

  def namespace_for_variable(var); end

  def namespaces(); end

  def override_comments(); end

  def parse_block(opts=T.unsafe(nil)); end

  def process_file(file, object); end

  def processed_files(); end

  def symbols(); end
  ERROR_CLASS_NAMES = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::Base
  def self.handles?(statement, processor); end

  def self.statement_class(type=T.unsafe(nil)); end
end

class YARD::Handlers::C::ClassHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ClassHandler
end

class YARD::Handlers::C::ConstantHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ConstantHandler
end

module YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::CodeObjects
  include ::YARD::Handlers::Common::MethodHandler
  def handle_alias(var_name, new_name, old_name); end

  def handle_attribute(var_name, name, read, write); end

  def handle_class(var_name, class_name, parent, in_module=T.unsafe(nil)); end

  def handle_constants(type, var_name, const_name, value); end

  def handle_method(scope, var_name, name, func_name, _source_file=T.unsafe(nil)); end

  def handle_module(var_name, module_name, in_module=T.unsafe(nil)); end
end

module YARD::Handlers::C::HandlerMethods
end

class YARD::Handlers::C::InitHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::InitHandler
end

class YARD::Handlers::C::MethodHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
  MATCH3 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MethodHandler
end

class YARD::Handlers::C::MixinHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MixinHandler
end

class YARD::Handlers::C::ModuleHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ModuleHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::PathHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::PathHandler
end

class YARD::Handlers::C::StructHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::StructHandler
end

class YARD::Handlers::C::SymbolHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::SymbolHandler
end

module YARD::Handlers::Common::MethodHandler
  def add_predicate_return_tag(obj); end
end

module YARD::Handlers::Common::MethodHandler
end

class YARD::Handlers::NamespaceMissingError
  def initialize(object); end

  def object(); end

  def object=(object); end
end

class YARD::Handlers::Processor
  def extra_state(); end

  def extra_state=(extra_state); end

  def file(); end

  def file=(file); end

  def find_handlers(statement); end

  def globals(); end

  def globals=(globals); end

  def initialize(parser); end

  def namespace(); end

  def namespace=(namespace); end

  def owner(); end

  def owner=(owner); end

  def parse_remaining_files(); end

  def parser_type(); end

  def parser_type=(parser_type); end

  def process(statements); end

  def scope(); end

  def scope=(scope); end

  def visibility(); end

  def visibility=(visibility); end
end

class YARD::Handlers::Processor
  def self.namespace_for_handler(); end

  def self.register_handler_namespace(type, ns); end
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AttributeHandler
  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::Base
  def parse_block(inner_node, opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Base
  extend ::YARD::Parser::Ruby
  def self.handles?(node); end

  def self.meta_type(type); end

  def self.method_call(name=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ConstantHandler
end

class YARD::Handlers::Ruby::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::DSLHandler
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def handle_comments(); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end
  IGNORE_METHODS = ::T.let(nil, ::T.untyped)
end

module YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::HandlesExtension
  def initialize(name); end

  def matches?(node); end

  def name(); end
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  def parse_block(opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Legacy::Base
  def self.handles?(stmt); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodHandler
  include ::YARD::Handlers::Common::MethodHandler
  def format_args(); end
end

class YARD::Handlers::Ruby::MixinHandler
  def process_mixin(mixin); end

  def recipient(mixin); end
end

class YARD::Handlers::Ruby::MixinHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
  def make_module_function(instance_method, namespace); end
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
end

module YARD::Handlers::Ruby::StructHandlerMethods
  def add_reader_tags(klass, new_method, member); end

  def add_writer_tags(klass, new_method, member); end

  def create_attributes(klass, members); end

  def create_class(classname, superclass); end

  def create_member_method?(klass, member, type=T.unsafe(nil)); end

  def create_reader(klass, member); end

  def create_writer(klass, member); end

  def member_tag_for_member(klass, member, type=T.unsafe(nil)); end

  def members_from_tags(klass); end

  def return_type_from_tag(member_tag); end
end

class YARD::Handlers::Ruby::VisibilityHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class YARD::I18n::Locale
  def self.default(); end

  def self.default=(locale); end
end

class YARD::I18n::Message
  def ==(other); end

  def add_comment(comment); end

  def add_location(path, line); end

  def comments(); end

  def id(); end

  def initialize(id); end

  def locations(); end
end

class YARD::I18n::Message
end

class YARD::I18n::Messages
  include ::Enumerable
  def ==(other); end

  def [](id); end

  def each(&block); end

  def messages(); end

  def register(id); end
end

class YARD::I18n::Messages
end

class YARD::I18n::PotGenerator
  def generate(); end

  def initialize(relative_base_path); end

  def messages(); end

  def parse_files(files); end

  def parse_objects(objects); end
end

class YARD::I18n::PotGenerator
end

class YARD::I18n::Text
  def extract_messages(); end

  def initialize(input, options=T.unsafe(nil)); end

  def translate(locale); end
end

class YARD::I18n::Text
end

class YARD::Logger
  def <<(msg=T.unsafe(nil)); end

  def backtrace(exc, level_meth=T.unsafe(nil)); end

  def capture(msg, nontty_log=T.unsafe(nil)); end

  def clear_progress(); end

  def debug(*args); end

  def enter_level(new_level=T.unsafe(nil)); end

  def initialize(pipe, *args); end

  def io(); end

  def io=(pipe); end

  def print(msg=T.unsafe(nil)); end

  def progress(msg, nontty_log=T.unsafe(nil)); end

  def puts(msg=T.unsafe(nil)); end

  def show_backtraces(); end

  def show_backtraces=(show_backtraces); end

  def show_progress(); end

  def show_progress=(show_progress); end

  def warn(*args); end

  def warn_no_continuations(); end

  def warned(); end

  def warned=(warned); end
  PROGRESS_INDICATORS = ::T.let(nil, ::T.untyped)
end

class YARD::Logger
  def self.instance(pipe=T.unsafe(nil)); end
end

class YARD::Options
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def each(&blk); end

  def merge(opts); end

  def method_missing(meth, *args, &block); end

  def reset_defaults(); end

  def to_hash(); end

  def update(opts); end
end

class YARD::Options
  def self.default_attr(key, default); end
end

class YARD::Parser::Base
  def enumerator(); end

  def initialize(source, filename); end

  def parse(); end

  def tokenize(); end
end

class YARD::Parser::Base
  def self.parse(source, filename=T.unsafe(nil)); end
end

class YARD::Parser::OrderedParser
  def files(); end

  def files=(files); end

  def initialize(global_state, files); end

  def parse(); end
end

module YARD::Parser::Ruby
  def s(*args); end
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value=T.unsafe(nil)); end

  def set_token_position(line, char); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  NEWLINE_TOKEN = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class YARD::Parser::SourceParser
  def contents(); end

  def file(); end

  def file=(file); end

  def globals(); end

  def initialize(parser_type=T.unsafe(nil), globals1=T.unsafe(nil), globals2=T.unsafe(nil)); end

  def parse(content=T.unsafe(nil)); end

  def parser_type(); end

  def tokenize(content); end
  DEFAULT_PATH_GLOB = ::T.let(nil, ::T.untyped)
  ENCODING_BYTE_ORDER_MARKS = ::T.let(nil, ::T.untyped)
  ENCODING_LINE = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LINE = ::T.let(nil, ::T.untyped)
  SHEBANG_LINE = ::T.let(nil, ::T.untyped)
end

class YARD::Parser::SourceParser
  def self.after_parse_file(&block); end

  def self.after_parse_file_callbacks(); end

  def self.after_parse_list(&block); end

  def self.after_parse_list_callbacks(); end

  def self.before_parse_file(&block); end

  def self.before_parse_file_callbacks(); end

  def self.before_parse_list(&block); end

  def self.before_parse_list_callbacks(); end

  def self.parse(paths=T.unsafe(nil), excluded=T.unsafe(nil), level=T.unsafe(nil)); end

  def self.parse_string(content, ptype=T.unsafe(nil)); end

  def self.parser_type(); end

  def self.parser_type=(value); end

  def self.parser_type_extensions(); end

  def self.parser_type_extensions=(value); end

  def self.parser_type_for_extension(extension); end

  def self.parser_types(); end

  def self.parser_types=(value); end

  def self.register_parser_type(type, parser_klass, extensions=T.unsafe(nil)); end

  def self.tokenize(content, ptype=T.unsafe(nil)); end

  def self.validated_parser_type(type); end
end

class YARD::Rake::YardocTask
  def after(); end

  def after=(after); end

  def before(); end

  def before=(before); end

  def define(); end

  def files(); end

  def files=(files); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def stats_options(); end

  def stats_options=(stats_options); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Rake::YardocTask
end

module YARD::Registry
  DEFAULT_PO_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_YARDOC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_YARDOC_INDEX = ::T.let(nil, ::T.untyped)
end

module YARD::Registry
  def self.[](path); end

  def self.all(*types); end

  def self.at(path); end

  def self.checksum_for(data); end

  def self.checksums(); end

  def self.clear(); end

  def self.delete(object); end

  def self.delete_from_disk(); end

  def self.each(&block); end

  def self.instance(); end

  def self.load(files=T.unsafe(nil), reparse=T.unsafe(nil)); end

  def self.load!(file=T.unsafe(nil)); end

  def self.load_all(); end

  def self.load_yardoc(file=T.unsafe(nil)); end

  def self.locale(name); end

  def self.lock_for_writing(file=T.unsafe(nil), &block); end

  def self.locked_for_writing?(file=T.unsafe(nil)); end

  def self.paths(reload=T.unsafe(nil)); end

  def self.po_dir(); end

  def self.po_dir=(dir); end

  def self.proxy_types(); end

  def self.register(object); end

  def self.resolve(namespace, name, inheritance=T.unsafe(nil), proxy_fallback=T.unsafe(nil), type=T.unsafe(nil)); end

  def self.root(); end

  def self.save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def self.single_object_db(); end

  def self.single_object_db=(v); end

  def self.yardoc_file(); end

  def self.yardoc_file=(v); end

  def self.yardoc_file_for_gem(gem, ver_require=T.unsafe(nil), for_writing=T.unsafe(nil)); end
end

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper
  def initialize(registry=T.unsafe(nil)); end

  def lookup_by_path(path, opts=T.unsafe(nil)); end
end

class YARD::RegistryResolver
end

class YARD::RegistryStore
  def [](key); end

  def []=(key, value); end

  def checksums(); end

  def checksums_path(); end

  def delete(key); end

  def destroy(force=T.unsafe(nil)); end

  def file(); end

  def get(key); end

  def keys(reload=T.unsafe(nil)); end

  def load(file=T.unsafe(nil)); end

  def load!(file=T.unsafe(nil)); end

  def load_all(); end

  def load_yardoc(); end

  def locale(name); end

  def lock_for_writing(file=T.unsafe(nil), &block); end

  def locked_for_writing?(file=T.unsafe(nil)); end

  def object_types_path(); end

  def objects_path(); end

  def paths_for_type(type, reload=T.unsafe(nil)); end

  def proxy_types(); end

  def proxy_types_path(); end

  def put(key, value); end

  def root(); end

  def save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def values(reload=T.unsafe(nil)); end

  def values_for_type(type, reload=T.unsafe(nil)); end
end

class YARD::RegistryStore
end

class YARD::Serializers::Base
  def after_serialize(data); end

  def before_serialize(); end

  def exists?(object); end

  def initialize(opts=T.unsafe(nil)); end

  def options(); end

  def serialize(object, data); end

  def serialized_path(object); end
end

class YARD::Serializers::Base
end

class YARD::Serializers::FileSystemSerializer
  def basepath(); end

  def basepath=(value); end

  def extension(); end

  def extension=(value); end
end

class YARD::Serializers::FileSystemSerializer
end

class YARD::Serializers::ProcessSerializer
  def initialize(cmd); end

  def serialize(_object, data); end
end

class YARD::Serializers::ProcessSerializer
end

class YARD::Serializers::StdoutSerializer
  def initialize(wrap=T.unsafe(nil)); end

  def serialize(_object, data); end
end

class YARD::Serializers::StdoutSerializer
end

class YARD::Serializers::YardocSerializer
  def checksums_path(); end

  def complete?(); end

  def complete_lock_path(); end

  def deserialize(path, is_path=T.unsafe(nil)); end

  def initialize(yfile); end

  def lock_for_writing(); end

  def locked_for_writing?(); end

  def object_types_path(); end

  def objects_path(); end

  def processing_path(); end

  def proxy_types_path(); end

  def serialize(object); end
end

class YARD::Serializers::YardocSerializer
end

module YARD::Server
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Adapter
  def add_library(library); end

  def document_root(); end

  def document_root=(document_root); end

  def initialize(libs, opts=T.unsafe(nil), server_opts=T.unsafe(nil)); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def router(); end

  def router=(router); end

  def server_options(); end

  def server_options=(server_options); end

  def start(); end
end

class YARD::Server::Adapter
  def self.setup(); end

  def self.shutdown(); end
end

class YARD::Server::Commands::Base
  def adapter(); end

  def adapter=(adapter); end

  def body(); end

  def body=(body); end

  def cache(data); end

  def caching(); end

  def caching=(caching); end

  def call(request); end

  def command_options(); end

  def command_options=(command_options); end

  def headers(); end

  def headers=(headers); end

  def initialize(opts=T.unsafe(nil)); end

  def not_found(); end

  def path(); end

  def path=(path); end

  def redirect(url); end

  def render(object=T.unsafe(nil)); end

  def request(); end

  def request=(request); end

  def run(); end

  def status(); end

  def status=(status); end
end

class YARD::Server::Commands::Base
end

class YARD::Server::Commands::DisplayFileCommand
  def index(); end

  def index=(index); end
end

class YARD::Server::Commands::DisplayFileCommand
end

class YARD::Server::Commands::DisplayObjectCommand
  include ::YARD::Server::DocServerHelper
  def index(); end
end

class YARD::Server::Commands::DisplayObjectCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::LibraryCommand
  def incremental(); end

  def incremental=(incremental); end

  def library(); end

  def library=(library); end

  def options(); end

  def options=(options); end

  def serializer(); end

  def serializer=(serializer); end

  def single_library(); end

  def single_library=(single_library); end

  def use_fork(); end

  def use_fork=(use_fork); end
  CAN_FORK = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::LibraryCommand
end

class YARD::Server::Commands::LibraryIndexCommand
  def options(); end

  def options=(options); end
end

class YARD::Server::Commands::LibraryIndexCommand
end

class YARD::Server::Commands::ListCommand
  include ::YARD::Templates::Helpers::BaseHelper
end

class YARD::Server::Commands::ListCommand
end

class YARD::Server::Commands::RootRequestCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::YARD::Server::HTTPUtils
end

class YARD::Server::Commands::RootRequestCommand
end

class YARD::Server::Commands::SearchCommand
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper
  def query(); end

  def query=(query); end

  def results(); end

  def results=(results); end

  def visible_results(); end
end

class YARD::Server::Commands::SearchCommand
end

class YARD::Server::Commands::StaticFileCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::YARD::Server::HTTPUtils
  STATIC_PATHS = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::StaticFileCommand
end

module YARD::Server::Commands::StaticFileHelpers
  include ::YARD::Server::HTTPUtils
  def favicon?(); end

  def static_template_file?(); end
end

module YARD::Server::Commands::StaticFileHelpers
  def self.find_file(adapter, url); end
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end

  def base_path(path); end

  def mtime(file); end

  def mtime_url(file); end

  def router(); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
end

module YARD::Server::DocServerHelper
end

class YARD::Server::DocServerSerializer
  def initialize(_command=T.unsafe(nil)); end
end

class YARD::Server::DocServerSerializer
end

class YARD::Server::FinishRequest
end

class YARD::Server::FinishRequest
end

module YARD::Server::HTTPUtils
  DefaultMimeTypes = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  UNESCAPED = ::T.let(nil, ::T.untyped)
  UNESCAPED_FORM = ::T.let(nil, ::T.untyped)
  UNESCAPED_PCHAR = ::T.let(nil, ::T.untyped)
end

class YARD::Server::HTTPUtils::FormData
  def <<(str); end

  def [](*key); end

  def append_data(data); end

  def each_data(); end

  def filename(); end

  def filename=(filename); end

  def initialize(*args); end

  def list(); end

  def name(); end

  def name=(name); end

  def next_data(); end

  def next_data=(next_data); end

  def to_ary(); end
  EmptyHeader = ::T.let(nil, ::T.untyped)
  EmptyRawHeader = ::T.let(nil, ::T.untyped)
end

class YARD::Server::HTTPUtils::FormData
end

module YARD::Server::HTTPUtils
  def self._escape(str, regex); end

  def self._make_regex(str); end

  def self._make_regex!(str); end

  def self._unescape(str, regex); end

  def self.dequote(str); end

  def self.escape(str); end

  def self.escape8bit(str); end

  def self.escape_form(str); end

  def self.escape_path(str); end

  def self.load_mime_types(file); end

  def self.mime_type(filename, mime_tab); end

  def self.normalize_path(path); end

  def self.parse_form_data(io, boundary); end

  def self.parse_header(raw); end

  def self.parse_query(str); end

  def self.parse_qvalues(value); end

  def self.parse_range_header(ranges_specifier); end

  def self.quote(str); end

  def self.split_header_value(str); end

  def self.unescape(str); end

  def self.unescape_form(str); end
end

class YARD::Server::LibraryVersion
  def ==(other); end

  def eql?(other); end

  def equal?(other); end

  def gemspec(); end

  def initialize(name, version=T.unsafe(nil), yardoc=T.unsafe(nil), source=T.unsafe(nil)); end

  def load_yardoc_from_disk(); end

  def load_yardoc_from_gem(); end

  def name(); end

  def name=(name); end

  def prepare!(); end

  def ready?(); end

  def source(); end

  def source=(source); end

  def source_path(); end

  def source_path=(source_path); end

  def source_path_for_disk(); end

  def source_path_for_gem(); end

  def to_s(url_format=T.unsafe(nil)); end

  def version(); end

  def version=(version); end

  def yardoc_file(); end

  def yardoc_file=(yardoc_file); end

  def yardoc_file_for_gem(); end
end

class YARD::Server::LibraryVersion
end

class YARD::Server::NotFoundError
end

class YARD::Server::NotFoundError
end

class YARD::Server::RackAdapter
  include ::YARD::Server::HTTPUtils
  def call(env); end
end

class YARD::Server::RackAdapter
end

class YARD::Server::RackMiddleware
  def call(env); end

  def initialize(app, opts=T.unsafe(nil)); end
end

class YARD::Server::RackMiddleware
end

class YARD::Server::Router
  include ::YARD::Server::StaticCaching
  include ::YARD::Server::Commands
  def adapter(); end

  def adapter=(adapter); end

  def call(request); end

  def docs_prefix(); end

  def final_options(library, paths); end

  def initialize(adapter); end

  def list_prefix(); end

  def parse_library_from_path(paths); end

  def request(); end

  def request=(request); end

  def route(path=T.unsafe(nil)); end

  def route_docs(library, paths); end

  def route_index(); end

  def route_list(library, paths); end

  def route_search(library, paths); end

  def route_static(library, paths); end

  def search_prefix(); end

  def static_prefix(); end
end

class YARD::Server::Router
end

module YARD::Server::StaticCaching
  def check_static_cache(); end
end

module YARD::Server::StaticCaching
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickServlet
  def adapter(); end

  def adapter=(adapter); end

  def do_GET(request, response); end

  def initialize(server, adapter); end
end

class YARD::Server::WebrickServlet
end

module YARD::Server
  def self.register_static_path(path); end
end

class YARD::StubProxy
  def _dump(_depth); end

  def initialize(path, transient=T.unsafe(nil)); end

  def method_missing(meth, *args, &block); end
  FILELEN = ::T.let(nil, ::T.untyped)
end

class YARD::StubProxy
  def self._load(str); end
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end

  def parse_tag_with_name(tag_name, text); end

  def parse_tag_with_options(tag_name, text); end

  def parse_tag_with_title_and_text(tag_name, text); end

  def parse_tag_with_types(tag_name, text); end

  def parse_tag_with_types_and_name(tag_name, text); end

  def parse_tag_with_types_and_title(tag_name, text); end

  def parse_tag_with_types_name_and_default(tag_name, text); end
  TYPELIST_CLOSING_CHARS = ::T.let(nil, ::T.untyped)
  TYPELIST_OPENING_CHARS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
end

class YARD::Tags::DefaultTag
  def defaults(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

class YARD::Tags::DefaultTag
end

class YARD::Tags::Directive
  def after_parse(); end

  def call(); end

  def expanded_text(); end

  def expanded_text=(expanded_text); end

  def handler(); end

  def initialize(tag, parser); end

  def inside_directive?(); end

  def object(); end

  def parser(); end

  def parser=(parser); end

  def tag(); end

  def tag=(tag); end
end

class YARD::Tags::Library
  def abstract_tag(text); end

  def api_tag(text); end

  def attr_reader_tag(text); end

  def attr_tag(text); end

  def attr_writer_tag(text); end

  def attribute_directive(tag, parser); end

  def author_tag(text); end

  def deprecated_tag(text); end

  def directive_create(tag_name, tag_buf, parser); end

  def domain_directive(tag, parser); end

  def endgroup_directive(tag, parser); end

  def example_tag(text); end

  def factory(); end

  def factory=(factory); end

  def group_directive(tag, parser); end

  def has_directive?(tag_name); end

  def has_tag?(tag_name); end

  def initialize(factory=T.unsafe(nil)); end

  def macro_directive(tag, parser); end

  def method_directive(tag, parser); end

  def note_tag(text); end

  def option_tag(text); end

  def overload_tag(text); end

  def override_directive(tag, parser); end

  def param_tag(text); end

  def param_tuple_tag(text); end

  def parse_directive(tag, parser); end

  def private_tag(text); end

  def raise_tag(text); end

  def return_single_parameter_tag(text); end

  def return_tag(text); end

  def return_value_parameter_tag(text); end

  def scope_directive(tag, parser); end

  def see_tag(text); end

  def since_tag(text); end

  def tag_create(tag_name, tag_buf); end

  def todo_tag(text); end

  def type_tag(text); end

  def version_tag(text); end

  def visibility_directive(tag, parser); end

  def yield_tag(text); end

  def yieldparam_single_parameter_tag(text); end

  def yieldparam_tag(text); end

  def yieldpublic_tag(text); end

  def yieldreturn_tag(text); end

  def yieldself_tag(text); end
end

class YARD::Tags::Library
  def self.default_factory(); end

  def self.default_factory=(factory); end

  def self.define_directive(tag, tag_meth=T.unsafe(nil), directive_class=T.unsafe(nil)); end

  def self.define_tag(label, tag, meth=T.unsafe(nil)); end

  def self.directive_method_name(tag_name); end

  def self.factory_method_for(tag); end

  def self.factory_method_for_directive(directive); end

  def self.instance(); end

  def self.labels(); end

  def self.sorted_labels(); end

  def self.tag_method_name(tag_name); end

  def self.transitive_tags(); end

  def self.transitive_tags=(transitive_tags); end

  def self.visible_tags(); end

  def self.visible_tags=(visible_tags); end
end

class YARD::Tags::MethodDirective
  def create_object(); end

  def method_name(); end

  def method_signature(); end

  def sanitized_tag_signature(); end

  def use_indented_text(); end
  SCOPE_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::OptionTag
  def initialize(tag_name, name, pair); end

  def pair(); end

  def pair=(pair); end
end

class YARD::Tags::OptionTag
end

class YARD::Tags::OverloadTag
  def docstring(); end

  def has_tag?(name); end

  def initialize(tag_name, text); end

  def is_a?(other); end

  def kind_of?(other); end

  def method_missing(*args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def object=(value); end

  def parameters(); end

  def signature(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end
end

module YARD::Tags::RefTag
  def owner(); end

  def owner=(owner); end
end

module YARD::Tags::RefTag
end

class YARD::Tags::RefTagList
  def initialize(tag_name, owner, name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def owner(); end

  def owner=(owner); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def tags(); end
end

class YARD::Tags::RefTagList
end

class YARD::Tags::Tag
  def explain_types(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def object(); end

  def object=(object); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def text(); end

  def text=(text); end

  def type(); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TypesExplainer
end

class YARD::Tags::TypesExplainer::CollectionType
  def initialize(name, types); end

  def to_s(_singular=T.unsafe(nil)); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::TypesExplainer::CollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::HashCollectionType
  def initialize(name, key_types, value_types); end

  def key_types(); end

  def key_types=(key_types); end

  def to_s(_singular=T.unsafe(nil)); end

  def value_types(); end

  def value_types=(value_types); end
end

class YARD::Tags::TypesExplainer::HashCollectionType
end

class YARD::Tags::TypesExplainer::Parser
  include ::YARD::CodeObjects
  def initialize(string); end

  def parse(); end
  TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::TypesExplainer::Parser
  def self.parse(string); end
end

class YARD::Tags::TypesExplainer::Type
  def initialize(name); end

  def name(); end

  def name=(name); end

  def to_s(singular=T.unsafe(nil)); end
end

class YARD::Tags::TypesExplainer::Type
end

class YARD::Tags::TypesExplainer
  def self.explain(*types); end

  def self.explain!(*types); end
end

module YARD::Templates::Engine
end

module YARD::Templates::Engine
  def self.generate(objects, options=T.unsafe(nil)); end

  def self.register_template_path(path); end

  def self.render(options=T.unsafe(nil)); end

  def self.template(*path); end

  def self.template!(path, full_paths=T.unsafe(nil)); end

  def self.template_paths(); end

  def self.template_paths=(template_paths); end

  def self.with_serializer(object, serializer); end
end

module YARD::Templates::ErbCache
end

module YARD::Templates::ErbCache
  def self.clear!(); end

  def self.method_for(filename); end
end

module YARD::Templates::Helpers::BaseHelper
  def format_object_title(object); end

  def format_object_type(object); end

  def format_source(value); end

  def format_types(list, brackets=T.unsafe(nil)); end

  def globals(); end

  def h(text); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def linkify(*args); end

  def object(); end

  def object=(object); end

  def owner(); end

  def run_verifier(list); end

  def serializer(); end

  def serializer=(serializer); end
end

module YARD::Templates::Helpers::BaseHelper
end

module YARD::Templates::Helpers::FilterHelper
  def is_class?(object); end

  def is_method?(object); end

  def is_module?(object); end

  def is_namespace?(object); end
end

module YARD::Templates::Helpers::FilterHelper
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def anchor_for(object); end

  def charset(); end

  def format_object_name_list(objects); end

  def format_types(typelist, brackets=T.unsafe(nil)); end

  def h(text); end

  def html_markup_asciidoc(text); end

  def html_markup_html(text); end

  def html_markup_markdown(text); end

  def html_markup_none(text); end

  def html_markup_org(text); end

  def html_markup_pre(text); end

  def html_markup_rdoc(text); end

  def html_markup_ruby(source); end

  def html_markup_text(text); end

  def html_markup_textile(text); end

  def html_markup_textile_strict(text); end

  def html_syntax_highlight(source, type=T.unsafe(nil)); end

  def html_syntax_highlight_plain(source); end

  def htmlify(text, markup=T.unsafe(nil)); end

  def htmlify_line(*args); end

  def insert_include(text, markup=T.unsafe(nil)); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil), anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def mtime(_file); end

  def mtime_url(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def resolve_links(text); end

  def signature(meth, link=T.unsafe(nil), show_extras=T.unsafe(nil), full_attr_name=T.unsafe(nil)); end

  def signature_types(meth, link=T.unsafe(nil)); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
  ASCIIDOC_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  URLMATCH = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::HtmlHelper
  def self.urlencode(text); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def html_syntax_highlight_ruby(source); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
  def fix_typewriter(html); end
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup
  def from_path(); end

  def from_path=(from_path); end

  def initialize(text); end

  def to_html(); end
end

YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP = RDoc::Markup

class YARD::Templates::Helpers::Markup::RDocMarkup
end

module YARD::Templates::Helpers::MarkupHelper
  def load_markup_provider(type=T.unsafe(nil)); end

  def markup_class(type=T.unsafe(nil)); end

  def markup_file_contents(contents); end

  def markup_for_file(contents, filename); end

  def markup_provider(type=T.unsafe(nil)); end
  MARKUP_EXTENSIONS = ::T.let(nil, ::T.untyped)
  MARKUP_FILE_SHEBANG = ::T.let(nil, ::T.untyped)
  MARKUP_PROVIDERS = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::MarkupHelper
  def self.clear_markup_cache(); end

  def self.markup_cache(); end

  def self.markup_cache=(markup_cache); end
end

module YARD::Templates::Helpers::MethodHelper
  def format_args(object); end

  def format_block(object); end

  def format_code(object, _show_lines=T.unsafe(nil)); end

  def format_constant(value); end

  def format_lines(object); end

  def format_return_types(object); end
end

module YARD::Templates::Helpers::MethodHelper
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::TextHelper
  def align_right(text, spacer=T.unsafe(nil), col=T.unsafe(nil)); end

  def h(text); end

  def hr(col=T.unsafe(nil), sep=T.unsafe(nil)); end

  def indent(text, len=T.unsafe(nil)); end

  def signature(meth); end

  def title_align_right(text, col=T.unsafe(nil)); end

  def wrap(text, col=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::TextHelper
end

module YARD::Templates::Helpers::UMLHelper
  def format_path(object); end

  def h(text); end

  def tidy(data); end

  def uml_visibility(object); end
end

module YARD::Templates::Helpers::UMLHelper
end

class YARD::Templates::Section
  def <<(*args); end

  def ==(other); end

  def [](*args); end

  def any(item); end

  def eql?(other); end

  def initialize(name, *args); end

  def name(); end

  def name=(name); end

  def place(*args); end

  def push(*args); end

  def unshift(*args); end
end

class YARD::Templates::Section
end

module YARD::Templates::Template
  include ::YARD::Templates::ErbCache
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::MethodHelper
  def T(*path); end

  def class(); end

  def class=(arg); end

  def erb(section, &block); end

  def erb_file_for(section); end

  def erb_with(content, filename=T.unsafe(nil)); end

  def file(basename, allow_inherited=T.unsafe(nil)); end

  def init(); end

  def initialize(opts=T.unsafe(nil)); end

  def inspect(); end

  def options(); end

  def options=(value); end

  def run(opts=T.unsafe(nil), sects=T.unsafe(nil), start_at=T.unsafe(nil), break_first=T.unsafe(nil), &block); end

  def section(); end

  def section=(section); end

  def sections(*args); end

  def superb(sect=T.unsafe(nil), &block); end

  def yieldall(opts=T.unsafe(nil), &block); end
end

module YARD::Templates::Template::ClassMethods
  def S(*args); end

  def T(*path); end

  def find_file(basename); end

  def find_nth_file(basename, index=T.unsafe(nil)); end

  def full_path(); end

  def full_path=(full_path); end

  def full_paths(); end

  def initialize(path, full_paths); end

  def is_a?(klass); end

  def new(*args); end

  def path(); end

  def path=(path); end

  def reset_full_paths(); end

  def run(*args); end
end

module YARD::Templates::Template::ClassMethods
end

module YARD::Templates::Template
  def self.extra_includes(); end

  def self.extra_includes=(extra_includes); end

  def self.include_extra(template, options); end

  def self.included(klass); end
end

class YARD::Templates::TemplateOptions
  def __globals(); end

  def default_return(); end

  def default_return=(default_return); end

  def embed_mixins(); end

  def embed_mixins=(embed_mixins); end

  def embed_mixins_match?(mixin); end

  def format(); end

  def format=(format); end

  def globals(); end

  def globals=(globals); end

  def hide_void_return(); end

  def hide_void_return=(hide_void_return); end

  def highlight(); end

  def highlight=(highlight); end

  def index(); end

  def index=(index); end

  def markup(); end

  def markup=(markup); end

  def markup_provider(); end

  def markup_provider=(markup_provider); end

  def no_highlight(); end

  def no_highlight=(value); end

  def object(); end

  def object=(object); end

  def owner(); end

  def owner=(owner); end

  def page_title(); end

  def page_title=(page_title); end

  def serialize(); end

  def serialize=(serialize); end

  def serializer(); end

  def serializer=(serializer); end

  def template(); end

  def template=(template); end

  def type(); end

  def type=(type); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Verifier
  def add_expressions(*expressions); end

  def call(object); end

  def expressions(); end

  def expressions=(value); end

  def initialize(*expressions); end

  def method_missing(sym, *args, &block); end

  def o(); end

  def object(); end

  def run(list); end
  NILCLASS_METHODS = ::T.let(nil, ::T.untyped)
end

class YARD::Verifier
end

module YARD
  def self.load_plugins(); end

  def self.parse(*args); end

  def self.parse_string(*args); end

  def self.ruby18?(); end

  def self.ruby19?(); end

  def self.ruby2?(); end

  def self.ruby31?(); end

  def self.ruby3?(); end

  def self.windows?(); end
end

module YARDSorbet
  VERSION = ::T.let(nil, ::T.untyped)
end

module YARDSorbet::Directives
  def self.add_directives(*args, **arg, &blk); end

  def self.extract_directives(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::AbstractDSLHandler
  def process(*args, **arg, &blk); end
  CLASS_TAG_TEXT = ::T.let(nil, ::T.untyped)
  TAG_TEXT = ::T.let(nil, ::T.untyped)
end

class YARDSorbet::Handlers::EnumsHandler
  def process(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::IncludeHandler
  def process(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::MixesInClassMethodsHandler
  def process(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::MixesInClassMethodsHandler
  def self.mixed_in_class_methods(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::SigHandler
  def process(*args, **arg, &blk); end
end

module YARDSorbet::Handlers::StructClassHandler
  def process(*args, **arg, &blk); end
end

class YARDSorbet::Handlers::StructPropHandler
  def process(*args, **arg, &blk); end
end

module YARDSorbet::NodeUtils
  def self.bfs_traverse(*args, **arg, &blk); end

  def self.delete_node(*args, **arg, &blk); end

  def self.get_method_node(*args, **arg, &blk); end

  def self.sibling_node(*args, **arg, &blk); end

  def self.sigable_node?(*args, **arg, &blk); end

  def self.validated_attribute_names(*args, **arg, &blk); end
end

module YARDSorbet::SigToYARD
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.convert(*args, **arg, &blk); end
end

class YARDSorbet::TStructProp
  def self.inherited(grandchild); end
end

module Zeitwerk
  VERSION = ::T.let(nil, ::T.untyped)
end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
end

class Zeitwerk::Loader
  extend ::Zeitwerk::RealModName
end

module Zip
  def case_insensitive_match(); end

  def case_insensitive_match=(case_insensitive_match); end

  def continue_on_exists_proc(); end

  def continue_on_exists_proc=(continue_on_exists_proc); end

  def default_compression(); end

  def default_compression=(default_compression); end

  def force_entry_names_encoding(); end

  def force_entry_names_encoding=(force_entry_names_encoding); end

  def on_exists_proc(); end

  def on_exists_proc=(on_exists_proc); end

  def reset!(); end

  def setup(); end

  def sort_entries(); end

  def sort_entries=(sort_entries); end

  def unicode_names(); end

  def unicode_names=(unicode_names); end

  def validate_entry_sizes(); end

  def validate_entry_sizes=(validate_entry_sizes); end

  def warn_invalid_date(); end

  def warn_invalid_date=(warn_invalid_date); end

  def write_zip64_support(); end

  def write_zip64_support=(write_zip64_support); end
  CDIR_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  CENTRAL_DIRECTORY_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHODS = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_AES = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_BZIP2 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_DEFLATE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_DEFLATE_64 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_CMPSC = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_LZ77 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_TERSE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IMPLODE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_JPEG = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_LZMA = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_PKWARE_DCLI = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_PPMD = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_1 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_2 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_3 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_4 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_SHRINK = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_STORE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_WAVPACK = ::T.let(nil, ::T.untyped)
  FILE_TYPE_DIR = ::T.let(nil, ::T.untyped)
  FILE_TYPE_FILE = ::T.let(nil, ::T.untyped)
  FILE_TYPE_SYMLINK = ::T.let(nil, ::T.untyped)
  FSTYPES = ::T.let(nil, ::T.untyped)
  FSTYPE_ACORN = ::T.let(nil, ::T.untyped)
  FSTYPE_AMIGA = ::T.let(nil, ::T.untyped)
  FSTYPE_ATARI = ::T.let(nil, ::T.untyped)
  FSTYPE_ATHEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_BEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_CPM = ::T.let(nil, ::T.untyped)
  FSTYPE_FAT = ::T.let(nil, ::T.untyped)
  FSTYPE_HPFS = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC_OSX = ::T.let(nil, ::T.untyped)
  FSTYPE_MVS = ::T.let(nil, ::T.untyped)
  FSTYPE_NTFS = ::T.let(nil, ::T.untyped)
  FSTYPE_QDOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TANDEM = ::T.let(nil, ::T.untyped)
  FSTYPE_THEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TOPS20 = ::T.let(nil, ::T.untyped)
  FSTYPE_UNIX = ::T.let(nil, ::T.untyped)
  FSTYPE_VFAT = ::T.let(nil, ::T.untyped)
  FSTYPE_VMS = ::T.let(nil, ::T.untyped)
  FSTYPE_VM_CMS = ::T.let(nil, ::T.untyped)
  FSTYPE_Z_SYSTEM = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = ::T.let(nil, ::T.untyped)
  RUNNING_ON_WINDOWS = ::T.let(nil, ::T.untyped)
  VERSION_MADE_BY = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT_ZIP64 = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  def ==(other); end

  def comment(); end

  def each(&a_proc); end

  def entries(); end

  def get_64_e_o_c_d(buf); end

  def get_e_o_c_d(buf); end

  def initialize(entries=T.unsafe(nil), comment=T.unsafe(nil)); end

  def read_64_e_o_c_d(buf); end

  def read_central_directory_entries(io); end

  def read_e_o_c_d(buf); end

  def read_from_stream(io); end

  def size(); end

  def start_buf(io); end

  def write_to_stream(io); end

  def zip64_file?(buf); end
  END_OF_CDS = ::T.let(nil, ::T.untyped)
  MAX_END_OF_CDS_SIZE = ::T.let(nil, ::T.untyped)
  STATIC_EOCD_SIZE = ::T.let(nil, ::T.untyped)
  ZIP64_END_OF_CDS = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_LOCATOR = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  def self.read_from_stream(io); end
end

class Zip::Compressor
  def finish(); end
end

class Zip::DOSTime
  def dos_equals(other); end

  def to_binary_dos_date(); end

  def to_binary_dos_time(); end
end

class Zip::DOSTime
  def self.from_time(time); end

  def self.parse_binary_dos_format(bin_dos_date, bin_dos_time); end
end

class Zip::Decompressor
  def decompressed_size(); end

  def initialize(input_stream, decompressed_size=T.unsafe(nil)); end

  def input_stream(); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::Decompressor
  def self.decompressor_classes(); end

  def self.find_by_compression_method(compression_method); end

  def self.register(compression_method, decompressor_class); end
end

class Zip::DecryptedIo
  def initialize(io, decrypter); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::Deflater
  def <<(data); end

  def crc(); end

  def initialize(output_stream, level=T.unsafe(nil), encrypter=T.unsafe(nil)); end

  def size(); end
end

class Zip::Entry
  def ==(other); end

  def calculate_local_header_size(); end

  def cdir_header_size(); end

  def check_c_dir_entry_comment_size(); end

  def check_c_dir_entry_signature(); end

  def check_c_dir_entry_static_header_length(buf); end

  def check_name(name); end

  def clean_up(); end

  def comment(); end

  def comment=(comment); end

  def comment_size(); end

  def compressed_size(); end

  def compressed_size=(compressed_size); end

  def compression_method(); end

  def compression_method=(compression_method); end

  def crc(); end

  def crc=(crc); end

  def directory?(); end

  def dirty(); end

  def dirty=(dirty); end

  def encrypted?(); end

  def external_file_attributes(); end

  def external_file_attributes=(external_file_attributes); end

  def extra(); end

  def extra=(extra); end

  def extra_size(); end

  def extract(dest_path=T.unsafe(nil), &block); end

  def file?(); end

  def file_stat(path); end

  def file_type_is?(type); end

  def filepath(); end

  def follow_symlinks(); end

  def follow_symlinks=(follow_symlinks); end

  def fstype(); end

  def fstype=(fstype); end

  def ftype(); end

  def gather_fileinfo_from_srcpath(src_path); end

  def get_extra_attributes_from_path(path); end

  def get_input_stream(&block); end

  def get_raw_input_stream(&block); end

  def gp_flags(); end

  def gp_flags=(gp_flags); end

  def header_signature(); end

  def header_signature=(header_signature); end

  def incomplete?(); end

  def initialize(*args); end

  def internal_file_attributes(); end

  def internal_file_attributes=(internal_file_attributes); end

  def local_entry_offset(); end

  def local_header_offset(); end

  def local_header_offset=(local_header_offset); end

  def mtime(); end

  def name(); end

  def name=(name); end

  def name_is_directory?(); end

  def name_safe?(); end

  def name_size(); end

  def next_header_offset(); end

  def pack_c_dir_entry(); end

  def pack_local_entry(); end

  def parent_as_string(); end

  def read_c_dir_entry(io); end

  def read_c_dir_extra_field(io); end

  def read_local_entry(io); end

  def restore_ownership(); end

  def restore_ownership=(restore_ownership); end

  def restore_permissions(); end

  def restore_permissions=(restore_permissions); end

  def restore_times(); end

  def restore_times=(restore_times); end

  def set_default_vars_values(); end

  def set_extra_attributes_on_path(dest_path); end

  def set_ftype_from_c_dir_entry(); end

  def set_unix_attributes_on_path(dest_path); end

  def size(); end

  def size=(size); end

  def symlink?(); end

  def time(); end

  def time=(value); end

  def unix_gid(); end

  def unix_gid=(unix_gid); end

  def unix_perms(); end

  def unix_perms=(unix_perms); end

  def unix_uid(); end

  def unix_uid=(unix_uid); end

  def unpack_c_dir_entry(buf); end

  def unpack_local_entry(buf); end

  def verify_local_header_size!(); end

  def write_c_dir_entry(io); end

  def write_local_entry(io, rewrite=T.unsafe(nil)); end

  def write_to_zip_output_stream(zip_output_stream); end

  def zipfile(); end

  def zipfile=(zipfile); end
  DEFLATED = ::T.let(nil, ::T.untyped)
  EFS = ::T.let(nil, ::T.untyped)
  STORED = ::T.let(nil, ::T.untyped)
end

class Zip::Entry
  def self.read_c_dir_entry(io); end

  def self.read_local_entry(io); end

  def self.read_zip_64_long(io); end

  def self.read_zip_long(io); end

  def self.read_zip_short(io); end
end

class Zip::EntrySet
  def <<(entry); end

  def ==(other); end

  def delete(entry); end

  def each(&blk); end

  def entries(); end

  def entry_order(); end

  def entry_order=(entry_order); end

  def entry_set(); end

  def entry_set=(entry_set); end

  def find_entry(entry); end

  def glob(pattern, flags=T.unsafe(nil)); end

  def include?(entry); end

  def initialize(an_enumerable=T.unsafe(nil)); end

  def length(); end

  def parent(entry); end

  def push(entry); end

  def size(); end

  def sorted_entries(); end
end

class Zip::ExtraField
  def c_dir_size(); end

  def create(name); end

  def create_unknown_item(); end

  def extra_field_type_exist(binstr, id, len, index); end

  def extra_field_type_unknown(binstr, len, index); end

  def initialize(binstr=T.unsafe(nil)); end

  def local_size(); end

  def merge(binstr); end

  def ordered_values(); end

  def to_c_dir_bin(); end

  def to_local_bin(); end
  ID_MAP = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Generic
  def ==(other); end

  def initial_parse(binstr); end

  def to_c_dir_bin(); end

  def to_local_bin(); end
end

class Zip::ExtraField::Generic
  def self.register_map(); end
end

class Zip::ExtraField::IUnix
  def gid(); end

  def gid=(gid); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def uid(); end

  def uid=(uid); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::NTFS
  def atime(); end

  def atime=(atime); end

  def ctime(); end

  def ctime=(ctime); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
  SEC_TO_UNIX_EPOCH = ::T.let(nil, ::T.untyped)
  WINDOWS_TICK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::OldUnix
  def atime(); end

  def atime=(atime); end

  def gid(); end

  def gid=(gid); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def uid(); end

  def uid=(uid); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::UniversalTime
  def atime(); end

  def atime=(time); end

  def ctime(); end

  def ctime=(time); end

  def flag(); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(time); end

  def pack_for_c_dir(); end

  def pack_for_local(); end
  ATIME_MASK = ::T.let(nil, ::T.untyped)
  CTIME_MASK = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  MTIME_MASK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64
  def compressed_size(); end

  def compressed_size=(compressed_size); end

  def disk_start_number(); end

  def disk_start_number=(disk_start_number); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def original_size(); end

  def original_size=(original_size); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def parse(original_size, compressed_size, relative_header_offset=T.unsafe(nil), disk_start_number=T.unsafe(nil)); end

  def relative_header_offset(); end

  def relative_header_offset=(relative_header_offset); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64Placeholder
  def initialize(_binstr=T.unsafe(nil)); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::File
  def add(entry, src_path, &continue_on_exists_proc); end

  def add_stored(entry, src_path, &continue_on_exists_proc); end

  def close(); end

  def comment=(comment); end

  def commit(); end

  def commit_required?(); end

  def extract(entry, dest_path, &block); end

  def find_entry(entry_name); end

  def get_entry(entry); end

  def get_input_stream(entry, &a_proc); end

  def get_output_stream(entry, permission_int=T.unsafe(nil), comment=T.unsafe(nil), extra=T.unsafe(nil), compressed_size=T.unsafe(nil), crc=T.unsafe(nil), compression_method=T.unsafe(nil), size=T.unsafe(nil), time=T.unsafe(nil), &a_proc); end

  def glob(*args, &block); end

  def initialize(path_or_io, create=T.unsafe(nil), buffer=T.unsafe(nil), options=T.unsafe(nil)); end

  def mkdir(entry_name, permission=T.unsafe(nil)); end

  def name(); end

  def read(entry); end

  def remove(entry); end

  def rename(entry, new_name, &continue_on_exists_proc); end

  def replace(entry, src_path); end

  def restore_ownership(); end

  def restore_ownership=(restore_ownership); end

  def restore_permissions(); end

  def restore_permissions=(restore_permissions); end

  def restore_times(); end

  def restore_times=(restore_times); end

  def write_buffer(io=T.unsafe(nil)); end
  CREATE = ::T.let(nil, ::T.untyped)
  DATA_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  IO_METHODS = ::T.let(nil, ::T.untyped)
  MAX_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  MIN_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  SPLIT_SIGNATURE = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_SIGNATURE = ::T.let(nil, ::T.untyped)
end

class Zip::File
  def self.add_buffer(); end

  def self.foreach(zip_file_name, &block); end

  def self.get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end

  def self.get_segment_count_for_split(zip_file_size, segment_size); end

  def self.get_segment_size_for_split(segment_size); end

  def self.open(file_name, create=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.open_buffer(io, options=T.unsafe(nil)); end

  def self.put_split_signature(szip_file, segment_size); end

  def self.save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

  def self.split(zip_file_name, segment_size=T.unsafe(nil), delete_zip_file=T.unsafe(nil), partial_zip_file_name=T.unsafe(nil)); end
end

module Zip::FileSystem
  def dir(); end

  def file(); end

  def initialize(); end
end

class Zip::FileSystem::ZipFileNameMapper
  def each(&blk); end

  def expand_path(path); end

  def find_entry(filename); end

  def get_entry(filename); end

  def get_input_stream(filename, &a_proc); end

  def get_output_stream(filename, permissions=T.unsafe(nil), &a_proc); end

  def glob(pattern, *flags, &block); end

  def initialize(zip_file); end

  def mkdir(filename, permissions=T.unsafe(nil)); end

  def pwd(); end

  def pwd=(pwd); end

  def read(filename); end

  def remove(filename); end

  def rename(filename, new_name, &continue_on_exists_proc); end
end

class Zip::FileSystem::ZipFsDir
  def chdir(directory_name); end

  def chroot(*_args); end

  def delete(entry_name); end

  def entries(directory_name); end

  def file=(file); end

  def foreach(directory_name); end

  def getwd(); end

  def glob(*args, &block); end

  def initialize(mapped_zip); end

  def mkdir(entry_name, permissions=T.unsafe(nil)); end

  def new(directory_name); end

  def open(directory_name); end

  def pwd(); end

  def rmdir(entry_name); end

  def unlink(entry_name); end
end

class Zip::FileSystem::ZipFsDirIterator
  def close(); end

  def each(&a_proc); end

  def initialize(filenames); end

  def read(); end

  def rewind(); end

  def seek(position); end

  def tell(); end
end

class Zip::FileSystem::ZipFsFile
  def atime(filename); end

  def basename(filename); end

  def blockdev?(_filename); end

  def chardev?(_filename); end

  def chmod(mode, *filenames); end

  def chown(owner, group, *filenames); end

  def ctime(filename); end

  def delete(*args); end

  def dir=(dir); end

  def directory?(filename); end

  def dirname(filename); end

  def executable?(filename); end

  def executable_real?(filename); end

  def exist?(filename); end

  def exists?(filename); end

  def expand_path(path); end

  def file?(filename); end

  def foreach(filename, sep=T.unsafe(nil), &a_proc); end

  def ftype(filename); end

  def grpowned?(filename); end

  def initialize(mapped_zip); end

  def join(*fragments); end

  def link(_filename, _symlink_name); end

  def lstat(filename); end

  def mtime(filename); end

  def new(filename, mode=T.unsafe(nil)); end

  def open(filename, mode=T.unsafe(nil), permissions=T.unsafe(nil), &block); end

  def owned?(filename); end

  def pipe(); end

  def pipe?(_filename); end

  def popen(*args, &a_proc); end

  def read(filename); end

  def readable?(filename); end

  def readable_real?(filename); end

  def readlines(filename); end

  def readlink(_filename); end

  def rename(file_to_rename, new_name); end

  def setgid?(filename); end

  def setuid?(filename); end

  def size(filename); end

  def size?(filename); end

  def socket?(_filename); end

  def split(filename); end

  def stat(filename); end

  def sticky?(filename); end

  def symlink(_filename, _symlink_name); end

  def symlink?(_filename); end

  def truncate(_filename, _len); end

  def umask(*args); end

  def unlink(*args); end

  def utime(modified_time, *filenames); end

  def writable?(filename); end

  def writable_real?(filename); end

  def zero?(filename); end
end

class Zip::FileSystem::ZipFsFile::ZipFsStat
  def atime(); end

  def blksize(); end

  def blockdev?(); end

  def blocks(); end

  def chardev?(); end

  def ctime(); end

  def dev(); end

  def directory?(); end

  def executable?(); end

  def executable_real?(); end

  def file?(); end

  def ftype(); end

  def gid(); end

  def grpowned?(); end

  def initialize(zip_fs_file, entry_name); end

  def ino(); end

  def kind_of?(type); end

  def mode(); end

  def mtime(); end

  def nlink(); end

  def owned?(); end

  def pipe?(); end

  def rdev(); end

  def rdev_major(); end

  def rdev_minor(); end

  def readable?(); end

  def readable_real?(); end

  def setgid?(); end

  def setuid?(); end

  def size(); end

  def size?(); end

  def socket?(); end

  def sticky?(); end

  def symlink?(); end

  def uid(); end

  def writable?(); end

  def writable_real?(); end

  def zero?(); end
end

class Zip::FileSystem::ZipFsFile::ZipFsStat
  def self.delegate_to_fs_file(*methods); end
end

module Zip::IOExtras
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  RANGE_ALL = ::T.let(nil, ::T.untyped)
end

module Zip::IOExtras::AbstractInputStream
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(a_sep_string=T.unsafe(nil), &blk); end

  def each_line(a_sep_string=T.unsafe(nil)); end

  def eof(); end

  def eof?(); end

  def flush(); end

  def gets(a_sep_string=T.unsafe(nil), number_of_bytes=T.unsafe(nil)); end

  def initialize(); end

  def lineno(); end

  def lineno=(lineno); end

  def pos(); end

  def read(number_of_bytes=T.unsafe(nil), buf=T.unsafe(nil)); end

  def readline(a_sep_string=T.unsafe(nil)); end

  def readlines(a_sep_string=T.unsafe(nil)); end

  def ungetc(byte); end
end

module Zip::IOExtras::AbstractOutputStream
  def print(*params); end

  def printf(a_format_string, *params); end

  def putc(an_object); end

  def puts(*params); end

  def write(data); end
end

module Zip::IOExtras::FakeIO
  def kind_of?(object); end
end

module Zip::IOExtras
  def self.copy_stream(ostream, istream); end

  def self.copy_stream_n(ostream, istream, nbytes); end
end

class Zip::Inflater
  def eof(); end

  def eof?(); end

  def initialize(*args); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
end

class Zip::InputStream
  def close(); end

  def get_decompressor(); end

  def get_decrypted_io(); end

  def get_io(io_or_file, offset=T.unsafe(nil)); end

  def get_next_entry(); end

  def initialize(context, offset=T.unsafe(nil), decrypter=T.unsafe(nil)); end

  def input_finished?(); end

  def open_entry(); end

  def produce_input(); end

  def rewind(); end

  def sysread(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::InputStream
  def self.open(filename_or_io, offset=T.unsafe(nil), decrypter=T.unsafe(nil)); end

  def self.open_buffer(filename_or_io, offset=T.unsafe(nil)); end
end

class Zip::NullCompressor
  def <<(_data); end

  def compressed_size(); end

  def size(); end
end

module Zip::NullDecompressor
  def self.eof(); end

  def self.read(_length=T.unsafe(nil), _outbuf=T.unsafe(nil)); end
end

class Zip::NullDecrypter
  def decrypt(data); end

  def reset!(_header); end
end

class Zip::NullEncrypter
  def data_descriptor(_crc32, _compressed_size, _uncomprssed_size); end

  def encrypt(data); end

  def header(_mtime); end

  def reset!(); end
end

module Zip::NullEncryption
  def gp_flags(); end

  def header_bytesize(); end
end

module Zip::NullInputStream
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Zip::OutputStream
  def <<(data); end

  def close(); end

  def close_buffer(); end

  def comment(); end

  def comment=(comment); end

  def copy_raw_entry(entry); end

  def finish(); end

  def initialize(file_name, stream=T.unsafe(nil), encrypter=T.unsafe(nil)); end

  def put_next_entry(entry_name, comment=T.unsafe(nil), extra=T.unsafe(nil), compression_method=T.unsafe(nil), level=T.unsafe(nil)); end
end

class Zip::OutputStream
  def self.open(file_name, encrypter=T.unsafe(nil)); end

  def self.write_buffer(io=T.unsafe(nil), encrypter=T.unsafe(nil)); end
end

class Zip::PassThruCompressor
  def <<(data); end

  def crc(); end

  def initialize(output_stream); end

  def size(); end
end

class Zip::PassThruDecompressor
  def eof(); end

  def eof?(); end

  def initialize(*args); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end
end

class Zip::StreamableDirectory
  def initialize(zipfile, entry, src_path=T.unsafe(nil), permission=T.unsafe(nil)); end
end

class Zip::StreamableStream
  def clean_up(); end

  def get_input_stream(); end

  def get_output_stream(); end

  def initialize(entry); end

  def write_to_zip_output_stream(output_stream); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Zip::TraditionalDecrypter
  def decrypt(data); end

  def reset!(header); end
end

class Zip::TraditionalEncrypter
  def data_descriptor(crc32, compressed_size, uncomprssed_size); end

  def encrypt(data); end

  def header(mtime); end

  def reset!(); end
end

module Zip::TraditionalEncryption
  def decrypt_byte(); end

  def gp_flags(); end

  def header_bytesize(); end

  def initialize(password); end

  def reset_keys!(); end

  def update_keys(num); end
end

Zip::ZipCompressionMethodError = Zip::CompressionMethodError

Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError

Zip::ZipEntryExistsError = Zip::EntryExistsError

Zip::ZipEntryNameError = Zip::EntryNameError

Zip::ZipError = Zip::Error

Zip::ZipInternalError = Zip::InternalError

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipReader
  def self.zcat(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::InProgressError
end

class Zlib::InProgressError
end

class Zlib::Inflate
  def initialize(*arg); end
end
